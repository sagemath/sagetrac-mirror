r"""
Vertex Algebras

Let `R` be a commutative ring. A *super vertex algebra* [Kac1997]_ over `R` is
the datum of:

- an `R` super-module `V` called *the space of states*
- an even vector `|0\rangle \in V` called the *vacuum* vector.
- an even endomorphism `T \in End(V)` called the *translation operator*
- a graded bilinear multiplication map

.. MATH::

    V \otimes V \rightarrow V( (z)), \qquad a \otimes b \mapsto Y(a,z)b =:
    \sum_{n \in \ZZ} a_{(n)}b z^{-1-n}.

Subject to the following set of axioms:

- The vacuum axioms:

.. MATH::

    Y(a,z)|0\rangle = a + Ta \cdot z + O(z^2), \qquad Y(|0\rangle,z)a = a,
    \qquad a \in V.

- Translation invariance:

.. MATH::

    [T,Y(a,z)] = \frac{d}{dz} Y(a,z)

- Locality:

.. MATH::

    (z-w)^n Y(a,z)Y(b,w) = (-1)^{p(a)p(b)} (z-w)^n Y(b,w)Y(a,z),
    \qquad a,b \in V, \: n \gg 0,

where `p(a)` is `0` if `a` is even and `1` if `a` is odd. The `\ZZ`-many
products `a_{(n)}b` defined above are called the
*nth*-products. A vertex algebra together with its non-negative nth-products
and its translation operator `T` is a
:mod:`Lie Conformal Algebra<sage.categories.lie_conformal_algebras>`.
The generating function for these non-negative products

.. MATH::

    [a_\lambda b] = \sum_{n \geq 0} \frac{\lambda^n}{n!} a_{(n)} b

is called the *OPE* or the `\lambda`-bracket of `a` and `b`. This forgetful
functor admits a
left adjoint: to each Lie conformal algebra `L` we attach a universal enveloping
vertex algebra `U(L)`. This vertex algebra admits an embedding (when `R` is a
field of characteristic zero) `L \hookrightarrow U(L)` of Lie conformal
algebras.

A vertex algebra is called H-Graded [DSK2006]_ if there exists a diagonalizable
operator `H \in End(V)` such that

.. MATH::

    [H,Y(a,z)] = Y(Ha,z) + z \frac{d}{dz} Y(a,z).

Equivalently, there exists a decomposition `V = \oplus_{\Delta \in \CC}
V_\Delta` such that the nth product becomes graded of degree `-1-n`, that is

.. MATH::

    a_{(n)}b \in V_{p + q - 1 - n} \qquad a \in V_p, b \in V_q, n \in \ZZ.

.. NOTE::

    Although arbitrary gradings are allowed in the literature, we implement here
    only non-negative rational gradings.

In this situation, for `a \in V_p` we define the *shifted nth-product* `a_n b =
a_{(n+p-1)}b`. With this convention, the *shifted nth-product* map `a \otimes b
\mapsto a_n b`  is graded of degree `-n`.

A vertex algebra is called *strongly generated* by a collection of vectors `a^i
\in V` indexed by an ordered set `I`,
if every vector of `V` can be written as a linear combination of vectors
of the form

.. MATH::

    a^{i_1}_{(-j_{1,1})} \cdots a^{i_1}_{(-j_{1,n_1})} a^{i_2}_{(-j_{2,1})}
    \cdots a^{i_k}_{(-j_{k,n_j})} |0\rangle, \qquad i_1 < \ldots < i_k,
    \: j_{i,l} > 0.

A vertex algebra is called *finitely strongly generated* if there is such a set
with a finite `I`, we will call these vertex algebras simply *finitely
generated*

EXAMPLES:

Typical examples of finitely and strongly generated H-Graded vertex algebra
arise as twisted universal enveloping vertex algebras of a finitely generated
H-Graded :mod:`Lie conformal algebras<sage.categories.lie_conformal_algebras>`.
They are described explicitly in terms of the OPE (`\lambda`-brackets) of
their generators:

- The **Virasoro** vertex algebra of central charge `c` is generated by one
  vector `L` with `\lambda`-bracket

  .. MATH::

        [L_\lambda L] = TL + 2 \lambda L + \frac{\lambda^3}{12} c |0\rangle

- The **universal affine** vertex algebra `V^\kappa(\mathfrak{g})` with level
  `\kappa` associated to a finite dimensional
  Lie algebra `\mathfrak{g}` with non-degenerate,
  invariant `R`-bilinear form `\kappa(,)` is generated by `\mathfrak{g}` with
  `\lambda`-bracket of generators given by

  .. MATH::

        [a_\lambda b] = [a,b] + \lambda \kappa(a,b) |0\rangle,
        \qquad a,b \in \mathfrak{g}


- The **Weyl** vertex algebra, or `\beta-\gamma` system has two generators
  `\beta` and
  `\gamma` The only non-trivial brackets among
  generators are

    .. MATH::

        [\beta_\lambda \gamma] = - [\gamma_\lambda \beta] = |0\rangle

- The **Neveu-Schwarz** super vertex algebra of central charge `c` is a super
  vertex algebra which is an extension of the Virasoro vertex
  algebra. It consists of a Virasoro generator `L` as above
  and an *odd* generator `G`. The remaining brackets are given by:

  .. MATH::

        [L_\lambda G] = \left( T + \frac{3}{2} \lambda \right) G \qquad
        [G_\lambda G] = 2 L + \frac{\lambda^2}{3} c |0\rangle

Every vertex algebra carries a decreasing filtration
called the *Li standard filtration*
[Li2005]_. It is defined as follows, we define `F^pV` to be the subspace spanned
by vectors of the form

.. MATH::

    a^1_{(-n_1-1)} \cdots a^r_{(-n_r -1)} b, \qquad a^i,b \in V, n_i \in
    \ZZ_{\geq 0}, \: n_1 + \cdots n_r \geq p.

The associated graded `\mathrm{gr}_FV` is a
:mod:`Poisson vertex algebra<sage.categories.poisson_vertex_algebras>`
known as the *quasi-classical limit* or *singular support* of `V`.

.. SEEALSO::

    - :mod:`sage.algebras.vertex_algebras.vertex_algebra`
    - :mod:`sage.algebras.vertex_algebras.examples`

AUTHORS:

- Reimundo Heluani (2019-10-09): Initial implementation.
"""

#******************************************************************************
#       Copyright (C) 2019 Reimundo Heluani <heluani@potuz.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from .category_types import Category_over_base_ring
from sage.categories.lie_conformal_algebras import LieConformalAlgebras
from sage.categories.quotients import QuotientsCategory
from sage.misc.abstract_method import abstract_method
from sage.functions.other import factorial
from sage.categories.graded_modules import GradedModulesCategory
from sage.categories.super_modules import SuperModulesCategory
from sage.misc.cachefunc import cached_method
from sage.rings.all import ZZ
from sage.misc.lazy_import import LazyImport

class VertexAlgebras(Category_over_base_ring):
    """
    The category of vertex algebras.

    EXAMPLES::

        sage: VertexAlgebras(QQ)
        Category of vertex algebras over Rational Field
        sage: VertexAlgebras(QQ).is_subcategory(LieConformalAlgebras(QQ))
        True
    """
    @cached_method
    def super_categories(self):
        """
        The super categories of this category.

        EXAMPLES::

            sage: C = VertexAlgebras(QQ)
            sage: C.super_categories()
            [Category of Lie conformal algebras over Rational Field]
        """
        return [LieConformalAlgebras(self.base_ring()),]

    def _repr_object_names(self):
        """
        The name of the objects of this category.

        EXAMPLES::

            sage: VertexAlgebras(QQbar)
            Category of vertex algebras over Algebraic Field
        """
        return "vertex algebras over {}".format(self.base_ring())

    def example(self):
        """
        An example of parent in this category.

        EXAMPLES::

            sage: VertexAlgebras(QQbar).example()
            The Free Bosons vertex algebra with generators (alpha_-1|0>,) over Algebraic Field
        """
        from sage.algebras.vertex_algebras.free_bosons_vertex_algebra import \
                                                    FreeBosonsVertexAlgebra
        return FreeBosonsVertexAlgebra(self.base_ring())

    class ParentMethods:
        @abstract_method(optional=True)
        def arc_algebra(self):
            r"""
            The arc algebra of this vertex algebra.

            The graded Poisson vertex algebra freely generated
            as a differential algebra by the `C_2` quotient of this
            vertex algebra.

            .. TODO::

                We only support arc algebras of universal enveloping
                vertex algebras and their quotients.

            EXAMPLES:

            Let us prove that the simple N=1 super vertex algebra at
            level `7/10` is not classically free. We start by
            computing the irreducible quotient, its arc algebra
            and its classical limit::

                sage: V = vertex_algebras.NeveuSchwarz(QQ,7/10)
                sage: Q = V.quotient(V.ideal(V.find_singular(4)))
                sage: P = Q.classical_limit()
                sage: R = Q.arc_algebra()
                sage: R
                Quotient of The classical limit of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field by the ideal generated by (L_2^2,)
                sage: P
                The classical limit of Quotient of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field by the ideal generated by (L_-2L_-2|0> - 3/2*G_-5/2G_-3/2|0> + 3/10*L_-4|0>,)

            We now check that the arc algebra properly surjects
            onto the classical limit::

                sage: R.hilbert_series(5)
                1 + q^(3/2) + q^2 + q^(5/2) + q^3 + 2*q^(7/2) + 2*q^4 + 3*q^(9/2) + O(q^5)
                sage: P.hilbert_series(5)
                1 + q^(3/2) + q^2 + q^(5/2) + q^3 + 2*q^(7/2) + 2*q^4 + 2*q^(9/2) + O(q^5)

            We compute a vector in the kernel of the projection::

                sage: P.arc_algebra_cover
                Ring morphism:
                  From: Quotient of The classical limit of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field by the ideal generated by (L_2^2,)
                  To:   The classical limit of Quotient of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field by the ideal generated by (L_-2L_-2|0> - 3/2*G_-5/2G_-3/2|0> + 3/10*L_-4|0>,)
                  Defn: L_2 |--> L_2
                        G_3/2 |--> G_3/2
                sage: K = P.arc_algebra_cover.kernel(9/2)
                sage: v= K.an_element().lift(); v
                2*L_3*G_3/2 - 8/3*L_2*G_5/2

            We check that indeed this vector vanishes in the classical
            limit of the quotient by showing that it is equivalent to
            a vector deeper in the Li filtration::

                sage: v.lift()
                2*L_3*G_3/2 - 8/3*L_2*G_5/2
                sage: v.lift().parent()
                The classical limit of The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field
                sage: w = v.lift().lift(); w
                2*L_-3G_-3/2|0> - 8/3*L_-2G_-5/2|0>
                sage: w.parent()
                The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field
                sage: t = Q.retract(w); t
                -16/5*G_-9/2|0>
                sage: t.li_filtration_degree()
                3
                sage: w.li_filtration_degree()
                1
            """
            raise NotImplementedError("arc_algebra is not implemented "\
                                      "for {}".format(self))

        @abstract_method(optional=True)
        def ideal(self, *gens):
            """
            The ideal of this vertex algebra generated by ``gens``.

            INPUT:

            - ``gens`` -- a list or tuple of elements of this vertex
              algebra.

            EXAMPLES:

            We construct the ideal defining the *Virasoro Ising*
            module::

                sage: V = vertex_algebras.Virasoro(QQ,1/2)
                sage: L = V.0
                sage: v = L*(L*L) + 93/64*L.T()*L.T() - 33/16*L.T(2)*L - 9/128*L.T(4)
                sage: I = V.ideal(v)
                sage: I
                ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
            """
            raise NotImplementedError("ideals of {} are not implemented yet"\
                                        .format(self))

        @abstract_method(optional=True)
        def quotient(self, I, names=None):
            """
            The quotient of this vertex algebra by the ideal ``I``.

            INPUT:

            - ``I`` -- a
              :class:`~sage.algebras.vertex_algebras.vertex_algebra_ideal.VertexAlgebraIdeal`
            - ``names`` a list of ``str`` or ``None``
              (default: ``None``); alternative names for the generators

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ,1/2)
                sage: L = V.0
                sage: v = L*(L*L) + 93/64*L.T()*L.T() - 33/16*L.T(2)*L - 9/128*L.T(4)
                sage: I = V.ideal(v)
                sage: Q = V.quotient(I); Q
                Quotient of The Virasoro vertex algebra of central charge 1/2 over Rational Field by the ideal generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)
                sage: Q(L*(L*L))
                -93/64*L_-3L_-3|0> + 33/8*L_-4L_-2|0> + 27/16*L_-6|0>
            """
            raise NotImplementedError("quotients of {} are not implemented yet"\
                                        .format(self))

        def classical_limit(self):
            """
            The Poisson vertex algebra classical limit of this vertex
            algebra.

            EXAMPLES:

            We construct the classical limit of the universal Virasoro
            vertex algebra of central charge `1/2`::

                sage: V = vertex_algebras.Virasoro(QQ, 1/2)
                sage: P = V.classical_limit()
                sage: V.inject_variables()
                Defining L
                sage: (L*L)*L == L*(L*L)
                False
                sage: (P(L)*P(L))*P(L) == P(L)*(P(L)*P(L))
                True
                sage: L.bracket(L)
                {0: L_-3|0>, 1: 2*L_-2|0>, 3: 1/4*|0>}
                sage: P(L).bracket(P(L))
                {}

            We construct the classical limit of the *Ising* model::

                sage: V = vertex_algebras.Virasoro(QQ,1/2); L = V.0
                sage: v = L*(L*L) + 93/64*L.T()*L.T() - 33/16*L.T(2)*L - 9/128*L.T(4)
                sage: Q = V.quotient(V.ideal(v)); P = Q.classical_limit()
                sage: L*(L*L)
                L_-2L_-2L_-2|0>
                sage: Q(L)*(Q(L)*Q(L))
                -93/64*L_-3L_-3|0> + 33/8*L_-4L_-2|0> + 27/16*L_-6|0>
                sage: P(Q(L))*(P(Q(L))*P(Q(L)))
                0

            We check that multiplication is not associative on the
            Free Boson but it is associative in its classical limit::

                sage: V = vertex_algebras.FreeBosons(QQ); P = V.classical_limit()
                sage: V.inject_variables()
                Defining alpha
                sage: (alpha*alpha)*alpha - alpha*(alpha*alpha)
                2*alpha_-3|0>
                sage: a = P(alpha)
                sage: (a*a)*a - a*(a*a)
                0
            """
            from sage.algebras.poisson_vertex_algebras.poisson_vertex_algebra \
                 import PoissonVertexAlgebra
            return PoissonVertexAlgebra(self.base_ring(), self)

        def is_finitely_generated(self):
            """
            If this vertex algebra is finitely generated.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ, 3)
                sage: V.is_finitely_generated()
                True
                sage: W = vertex_algebras.Affine(QQ, 'A1', 1)
                sage: W.is_finitely_generated()
                True
            """
            return self in VertexAlgebras(self.base_ring()).FinitelyGenerated()

        def is_super(self):
            """
            If this vertex algebra is a super vertex algebra.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ,3)
                sage: V.is_super()
                False
                sage: vertex_algebras.NeveuSchwarz(QQ,1/2).is_super()
                True

            Note however that there are purely even super vertex
            algebras::

                sage: R = lie_conformal_algebras.Abelian(QQ,2,parity=(0,0))
                sage: V = R.universal_enveloping_algebra(); V.is_super()
                True
            """
            return self in VertexAlgebras(self.base_ring()).Super()

        def is_graded(self):
            """
            If this vertex algebra is H-Graded.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ, 3)
                sage: V.is_graded()
                True
                sage: W = vertex_algebras.Affine(QQ, 'A1', 1)
                sage: W.is_graded()
                True
            """
            return self in VertexAlgebras(self.base_ring()).Graded()

        def is_with_basis(self):
            """
            Whether this vertex algebra has a preferred basis.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ, 1/2)
                sage: V.is_with_basis()
                True
            """
            return self in VertexAlgebras(self.base_ring()).WithBasis()

        @abstract_method
        def vacuum(self):
            """
            The vacuum vector of this vertex algebra.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ, 3)
                sage: V.vacuum()
                |0>
            """

        @abstract_method
        def zero(self):
            """
            The zero vector in this vertex algebra.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ, 1/2); V.register_lift(); L = V.0
                sage: v = L*(L*L) + 93/64*L.T()*L.T() - 33/16*L.T(2)*L - 9/128*L.T(4)
                sage: Q = V.quotient(V.ideal(v))
                sage: Q(0)
                0
                sage: V(0)
                0
                sage: V(0) == V.zero()
                True
                sage: Q(0) == Q.zero()
                True
            """

        def central_charge(self):
            """
            The central charge of this vertex algebra.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ, 1/2)
                sage: V.central_charge()
                1/2
                sage: B = vertex_algebras.FreeBosons(QQ, 5)
                sage: B.central_charge()
                5
                sage: F = vertex_algebras.FreeFermions(QQ,5)
                sage: F.central_charge()
                5/2
                sage: V = vertex_algebras.Affine(QQ, 'B3', 1)
                sage: V.central_charge()
                7/2
            """
            try:
                return self._c
            except AttributeError:
                raise NotImplementedError("the central charge of {} is not "\
                                          "implemented".format(self))

    class ElementMethods: #VertexAlgebras

        def _nproduct_(self,rhs,n):
            r"""
            The ``n``-th product of these two elements.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ,1/2); L = V.0
                sage: L.nproduct(L,3)
                1/4*|0>
                sage: L.nproduct(L,-3)
                L_-4L_-2|0>
            """
            if n not in ZZ:
                raise ValueError("n must be an integer number")
            if n >= 0:
                return self._bracket_(rhs).get(n,self.parent().zero())
            else:
                return self.T(-n-1)._mul_(rhs)/factorial(-1-n)

        @abstract_method(optional=True)
        def li_filtration_degree(self):
            """
            The smallest space `F^p` in the Li filtration of this
            vertex algebra containing this element.

            EXAMPLES::

                sage: V = vertex_algebras.Virasoro(QQ,1/2); L = V.0
                sage: L.li_filtration_degree()
                0
                sage: (L.T(2)*L.T()).li_filtration_degree()
                3
            """

    class SubcategoryMethods:

        def FinitelyGeneratedAsVertexAlgebra(self):
            """
            The subcategory of finitely generated vertex algebras.

            EXAMPLES::

                sage: VertexAlgebras(QQbar).FinitelyGenerated()
                Category of finitely generated vertex algebras over Algebraic Field
            """
            return self._with_axiom("FinitelyGeneratedAsVertexAlgebra")

        def FinitelyGenerated(self):
            """
            The subcategory of finitely generated vertex algebras.

            EXAMPLES::

                sage: VertexAlgebras(QQbar).FinitelyGenerated()
                Category of finitely generated vertex algebras over Algebraic Field
            """
            return self._with_axiom("FinitelyGeneratedAsVertexAlgebra")

    class Super(SuperModulesCategory):
        """
        The subcategory of super vertex algebras.

        EXAMPLES::

            sage: VertexAlgebras(QQbar).Super()
            Category of super vertex algebras over Algebraic Field
        """
        #Need to do all this to make Super commute with Graded.
        def extra_super_categories(self):
            """
            The extra super categories of this category.

            EXAMPLES::

                sage: VertexAlgebras(QQ).Super().super_categories()
                [Category of super Lie conformal algebras over Rational Field,
                Category of vertex algebras over Rational Field]
            """
            return [self.base_category()]

        def example(self):
            """
            An example of a super vertex algebra.

            EXAMPLES::

                sage: VertexAlgebras(QQ).Super().example()
                The Free Fermions super vertex algebra with generators (psi_-1/2|0>,) over Rational Field
            """
            from sage.algebras.vertex_algebras.free_fermions_vertex_algebra import \
                                                      FreeFermionsVertexAlgebra
            return FreeFermionsVertexAlgebra(self.base_ring())

        class SubcategoryMethods:

            def Graded(self, base_ring=None):
                """
                The subcategory of super H-graded vertex algebras.

                EXAMPLES::

                    sage: VertexAlgebras(QQ).Super().Graded()
                    Category of super H-graded vertex algebras over Rational Field
                """
                assert base_ring is None or base_ring is self.base_ring()
                return GradedModulesCategory.category_of(
                                                  self.base_category()).Super()

    class Graded(GradedModulesCategory):
        """
        The subcategory of H-graded vertex algebras.

        EXAMPLES::

            sage: VertexAlgebras(QQ).Graded()
            Category of H-graded vertex algebras over Rational Field
        """
        def _repr_object_names(self):
            """
            The names of objects in this category.

            EXAMPLES::

                sage: VertexAlgebras(QQ).Graded()
                Category of H-graded vertex algebras over Rational Field
            """
            return "H-graded {}".format(self.base_category()._repr_object_names())

        class Super(SuperModulesCategory):
            """
            The subcategory of H-graded super vertex algebras.

            EXAMPLES::

                sage: VertexAlgebras(AA).Graded().Super()
                Category of super H-graded vertex algebras over Algebraic Real Field

            TESTS::

                sage: C = VertexAlgebras(QQ)
                sage: C.Graded().Super() is C.Super().Graded()
                True
            """
            def extra_super_categories(self):
                """
                The extra super categories of this category.

                EXAMPLES::

                    sage: VertexAlgebras(QQ).Graded().Super().super_categories()
                    [Category of super vertex algebras over Rational Field,
                    Category of H-graded vertex algebras over Rational Field,
                    Category of super H-graded Lie conformal algebras over Rational Field]
                """
                return [self.base_category()]

        class ElementMethods:   #VertexAlgebras.Graded
            """
            Base class for elements of an H-graded vertex algebra.
            """
            @abstract_method
            def degree(self):
                """
                The conformal weight of this element.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2); L = V.0
                    sage: L.degree()
                    2
                    sage: W = vertex_algebras.Affine(QQ, 'A1', 2); E = W.0
                    sage: E.degree()
                    1
                    sage: L.T().degree()
                    3
                    sage: (L + L.T()).degree()
                    Traceback (most recent call last):
                    ...
                    ValueError: element is not homogeneous
                """
                return self.weight()

            def weight(self):
                """
                The conformal weight of this element.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ,1);
                    sage: V.gens()
                    (L_-2|0>, G_-3/2|0>)
                    sage: [g.weight() for g in V.gens()]
                    [2, 3/2]
                """
                return self.degree()

            @abstract_method
            def homogeneous_terms(self):
                """
                Return a tuple with the homogeneous terms of this
                element with respect to conformal weight.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2)
                    sage: V.inject_variables()
                    Defining L
                    sage: (L+L.T(3) + L*L.T() + L.T(7)/factorial(7)).homogeneous_terms()
                    (L_-2|0>, L_-3L_-2|0> + 7*L_-5|0>, L_-9|0>)

                TESTS::

                    sage: V = vertex_algebras.Virasoro(QQ,1); V(0).homogeneous_terms()
                    (0,)
                """

            def nmodeproduct(self, other, n):
                r"""
                The shifted product of these two elements.

                INPUT:

                - ``other`` -- an element of this vertex algebra
                - ``n`` -- a rational.

                OUTPUT:

                The shifted `n`-product of ``self``
                with ``other``, which is defined as follows.

                For an element `a` of degree `p`, that is `a \in V_p`,
                then `a_n b` is defined as `a_{(n+p-1)}b`.

                .. NOTE::

                    For this method to be defined, the element ``self``
                    needs to be homogeneous of rational conformal weight
                    say ``w``. In addition, ``n+w`` needs to be an
                    integer number. If these conditions are not met
                    this method raises ``ValueError``.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ, 1/2); V.register_lift()
                    sage: V.inject_variables()
                    Defining L
                    sage: L.nmodeproduct(L.T(),0)
                    3*L_-3|0>

                    sage: (L + V.vacuum()).nmodeproduct(L,0)
                    Traceback (most recent call last):
                    ...
                    ValueError: couldn't compute weight of |0> + L_-2|0>, is it not homogeneous?
                """
                try:
                    weight = self.weight()
                except ValueError:
                    raise ValueError("couldn't compute weight of {}, "\
                                    "is it not homogeneous?".format(self))
                if n+weight not in ZZ:
                    raise ValueError("{} does not have a mode {}".format(self,
                                                                             n))
                return self._nproduct_(other, n+weight-1)

    class Quotients(QuotientsCategory):
        """
        The category of quotients of vertex algebras.

        EXAMPLES::

            sage: VertexAlgebras(QQbar).Quotients()
            Category of quotients of vertex algebras over Algebraic Field
        """
        def example(self):
            """
            An example parent in this category.

            EXAMPLES::

                sage: VertexAlgebras(QQbar).Quotients().example()
                Quotient of The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Algebraic Field by the ideal generated by (e_-1e_-1|0>, e_-1f_-1|0> + e_-2|0>, f_-1f_-1|0> - 2*e_-1h_-1|0> + f_-2|0>, f_-1h_-1|0> + h_-2|0>, h_-1h_-1|0>)
            """
            from sage.algebras.vertex_algebras.affine_vertex_algebra import \
                                                            AffineVertexAlgebra
            V = AffineVertexAlgebra(self.base_ring(), 'A1', 1,
                                    names=('e','f', 'h'))
            return V.quotient(V.ideal(V.find_singular(2)))

        class ParentMethods:

            @abstract_method
            def defining_ideal(self):
                """
                The defining ideal of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2)
                    sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                    sage: Q.defining_ideal()
                    ideal of The Virasoro vertex algebra of central charge 1/2 over Rational Field generated by (L_-2L_-2L_-2|0> + 93/64*L_-3L_-3|0> - 33/8*L_-4L_-2|0> - 27/16*L_-6|0>,)

                    sage: V = vertex_algebras.Affine(QQ, 'A1', 1, names = ('e','h','f'));
                    sage: Q = V.quotient(V.ideal(V.find_singular(2)))
                    sage: Q.defining_ideal()
                    ideal of The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field generated by (e_-1e_-1|0>, e_-1h_-1|0> + e_-2|0>, h_-1h_-1|0> - 2*e_-1f_-1|0> + h_-2|0>, h_-1f_-1|0> + f_-2|0>, f_-1f_-1|0>)
                """

            @abstract_method
            def cover_algebra(self):
                """
                The covering vertex algebra of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ,7/10); V.register_lift()
                    sage: Q = V.quotient(V.ideal(V.find_singular(4)))
                    sage: I = Q.defining_ideal()
                    sage: I.gens()
                    (L_-2L_-2|0> - 3/2*G_-5/2G_-3/2|0> + 3/10*L_-4|0>,)
                    sage: Q.cover_algebra()
                    The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field
                    sage: Q.cover_algebra() is V
                    True
                """

            def ambient(self):
                """
                The covering vertex algebra of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ,7/10)
                    sage: Q = V.quotient(V.ideal(V.find_singular(4)))
                    sage: I = Q.defining_ideal()
                    sage: I.gens()
                    (L_-2L_-2|0> - 3/2*G_-5/2G_-3/2|0> + 3/10*L_-4|0>,)
                    sage: Q.cover_algebra()
                    The Neveu-Schwarz super vertex algebra of central charge 7/10 over Rational Field
                    sage: Q.cover_algebra() is V
                    True
                """
                return self.cover_algebra()

            def _an_element_(self):
                """
                An element of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ,7/10)
                    sage: Q = V.quotient(V.ideal(V.find_singular(4)));
                    sage: Q.an_element()
                    |0> + 2*G_-3/2|0> + 3*L_-2|0> + L_-2G_-3/2|0>
                """
                return self.retract(self.cover_algebra()._an_element_())

            @cached_method
            def zero(self):
                """
                The zero element of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Virasoro(QQ,1/2)
                    sage: Q = V.quotient(V.ideal(V.find_singular(6)))
                    sage: Q.zero()
                    0

                TESTS::

                    sage: Q.zero() == Q.retract(V.zero())
                    True
                """
                return self.retract(self.cover_algebra().zero())

            @cached_method
            def vacuum(self):
                """
                The vacuum vector of this quotient.

                EXAMPLES::

                    sage: V = vertex_algebras.Affine(QQ, 'A1', 1); V.register_lift()
                    sage: Q = V.quotient(V.ideal(V.find_singular(2)))
                    sage: Q.vacuum()
                    |0>
                """
                return self.retract(self.cover_algebra().vacuum())

        class ElementMethods:

            @abstract_method
            def lift(self):
                """
                Lift this element to the cover vertex algebra.

                EXAMPLES::

                    sage: V = vertex_algebras.Affine(QQ, 'A1', 1, names = ('e','h','f'))
                    sage: Q = V.quotient(V.ideal(V.find_singular(2)))
                    sage: v = Q.an_element(); v
                    |0> + 2*e_-1|0> + 3*h_-1|0> + e_-2|0>
                    sage: v.lift()
                    |0> + 2*e_-1|0> + 3*h_-1|0> + e_-2|0>
                    sage: v.lift().parent()
                    The universal affine vertex algebra of CartanType ['A', 1] at level 1 over Rational Field
                """

            def is_even_odd(self):
                r"""
                Return `0` if this element is *even* and `1` if it is
                *odd*.

                EXAMPLES::

                    sage: V = vertex_algebras.NeveuSchwarz(QQ,7/10)
                    sage: Q = V.quotient(V.ideal(V.find_singular(4)))
                    sage: Q.inject_variables()
                    Defining L, G
                    sage: L.is_even_odd()
                    0
                    sage: G.is_even_odd()
                    1
                """
                return self.lift().is_even_odd()

    WithBasis = LazyImport('sage.categories.vertex_algebras_with_basis',
                            'VertexAlgebrasWithBasis')

    FinitelyGeneratedAsVertexAlgebra = LazyImport(
        'sage.categories.finitely_generated_vertex_algebras',
        'FinitelyGeneratedAsVertexAlgebra')
