r"""
Modules generated by polyhedra.
"""

from sage.misc.cachefunc import cached_method
from sage.categories.category_types import Category_over_base_ring
from sage.categories.filtered_modules_with_basis import FilteredModulesWithBasis

class PolyhedraModules(Category_over_base_ring):

    @cached_method
    def super_categories(self):
        R = self.base_ring()
        return [FilteredModulesWithBasis(R)]

    class ParentMethods:

        def degree_on_basis(self, m):
            r"""
            Polyhedra generate a module filtered by dimension.

            Modulo the linear relations of polyhedra, this is only a filtration,
            not a grading, as the following example shows.

            EXAMPLES::

                sage: from sage.geometry.polyhedron.modules.formal_polyhedra_module import FormalPolyhedraModule
                sage: def closed_interval(a,b): return Polyhedron(vertices=[[a], [b]])
                sage: I01 = closed_interval(0, 1); I01.rename("conv([0], [1])")
                sage: I11 = closed_interval(1, 1); I11.rename("{[1]}")
                sage: I12 = closed_interval(1, 2); I12.rename("conv([1], [2])")
                sage: I02 = closed_interval(0, 2); I02.rename("conv([0], [2])")
                sage: M = FormalPolyhedraModule(QQ, 1, basis=[I01, I11, I12, I02])
                sage: X = M(I01) + M(I12) - M(I02)
                sage: X.degree()
                1

                sage: Y = M(I11)
                sage: Y.degree()
                0

            In the ``FormalPolyhedraModule``, this is actually a grading.
            So we can extract homogeneous components::

                sage: O = M(I01) + M(I11) + M(I12)
                sage: O.homogeneous_component(0)
                [{[1]}]
                sage: O.homogeneous_component(1)
                [conv([0], [1])] + [conv([1], [2])]

            """
            return m.dimension()
