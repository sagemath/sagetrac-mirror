r"""
*******************
Classes of Lattices
*******************

Lattices for tori are defined byy equipping the standard lattice in `\ZZ^n` with a group action.

We allow trivial group actions.


All lattices inherit from :class:`Lattice_generic`, and there are currently
two types of lattices: ambient lattices (:class:`Lattice_ambient`) and sublattices of ambient
lattices (:class:`SubLattice`).

One can define a lattice in 4 different ways:

- Giving a group and matrix actions for each generator.

- Giving a group and an integer.

- Giving a list of matrices.

- Giving an ambient lattice and a list of vectors spanning an invariant submodule.

Lattice_ambient(group, actions)
===============================

You can define a lattice by giving a group and matrix actions for each generator::

    sage: G = PermutationGroup([(1,2), (3,4,5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
    sage: act2 = matrix(3, [1,0,0,0,1,0,0,0,1])
    sage: act = [act1, act2]

We created the group `G` as `C_2 \times C_3`, and the action where `C_2` acts trivially.
One has to be careful when defining the action to match sage's order of the generators::

    sage: L = Lattice_ambient(G,act); L
    Ambient free module of rank 3 over the principal ideal domain Integer Ring

    sage: L._action_matrices
    [
    [0 1 0]  [1 0 0]
    [0 0 1]  [0 1 0]
    [1 0 0], [0 0 1]
    ]

Lattice_ambient(group, n)
=========================

If you provide a group and an integer `n`, you get the lattice of rank `n` with
trivial action of the group::

    sage: L = Lattice_ambient(SymmetricGroup(3), 2); L
    Ambient free module of rank 2 over the principal ideal domain Integer Ring
    sage: L._action_matrices
    [
    [1 0]  [1 0]
    [0 1], [0 1]
    ]

Lattice_ambient(List_of_matrices)
=================================

If you provide a list of matrices, Sage will construct the lattice with rank
equal to the the size of the matrices, and the group will be understood to be
the subgroup of `GL_n(\ZZ)` generated by the provided matrices.
This subgroup should be finite::

    sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
    sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
    sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
    sage: L = Lattice_ambient([m1, m2, m3]); L
    Ambient free module of rank 3 over the principal ideal domain Integer Ring

    sage: L._action_matrices
    [
    [ 0  0  1]  [-1  0  0]  [ 0  1  0]
    [-1 -1 -1]  [ 0 -1  0]  [ 1  0  0]
    [ 1  0  0], [ 0  0 -1], [-1 -1 -1]
    ]

SubLattice(lattice, generators)
===============================

In order to create a sublattice, give a lattice and a list of vectors in the lattice::

    sage: L = Lattice_ambient(DihedralGroup(6), 3)
    sage: x, y, z = L.basis()
    sage: SubLattice(L, [x, y + 2z])
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [1 0 0]
    [0 1 2]

The algorithm checks if the sublattice is stable under the group action::

    sage: L = Lattice_ambient(SymmetricGroup(2), [matrix([[0,1], [1,0]])])
    sage: SubLattice(L, [L.basis()[0]])
    Traceback (most recent call last):
    ...
    ValueError: The basis is not stable under the action of the group

Attributes of a lattice
=======================

- ``lattice._group`` -- the group acting on the lattice

- ``lattice._generators`` -- the generators of that group

- ``lattice._rank`` -- the rank of the lattice

- ``lattice._action_matrices`` -- the matrices through which the group acts

- ``lattice._action._morphism`` -- the map (as a group homomorphism in GAP) from
    the group to ``GL(rank,ZZ)``

- ``lattice._GAPMap`` -- returns the Sage :class:`sage.categories.map.Map` element
    representing Lattice.action_morphism

- ``lattice._action`` -- the Sage action of the group on the lattice

- ``lattice._parent_lattice`` -- the parent lattice; this attribute only exists for
    the SubLattice class

Methods of a lattice
====================

Let us create a few lattices to test the methods.

EXAMPLES::

    sage: G = PermutationGroup([(1,2), (3,4,5)])
    sage: G.gens()
    [(3,4,5), (1,2)]
    sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
    sage: act2 = matrix(3, [1,0,0,0,1,0,0,0,1])
    sage: act = [act1,act2]
    sage: L1 = Lattice_ambient(G, act)

``L1`` is the group `C_2 \times C_3` acting on `\ZZ^3` via the identity for the first component and
an order 3 permutation for the second component.

::

    sage: L2 = Lattice_ambient(SymmetricGroup(3), 4)

``L2`` is the symmetric group `S_3` acting trivially on `\ZZ^4`.

::

    sage: m1 = matrix(3, [0,0,1,-1,-1,-1,1,0,0])
    sage: m2 = matrix(3, [-1,0,0,0,-1,0,0,0,-1])
    sage: m3 = matrix(3, [0,1,0,1,0,0,-1,-1,-1])
    sage: L3 = Lattice_ambient([m1, m2, m3])

``L3`` is the lattice with action of the group generated by the matrices ``m1``, ``m2``, ``m3``,
which is also the group of GAP ID (3,3,3,3)

- :meth:`Lattice_generic.group` -- the group acting on the lattice::

    sage: L1.group()
    Permutation Group with generators [(3,4,5), (1,2)]
    sage: L2.group()
    Symmetric group of order 3! as a permutation group
    sage: L3.group()
    Matrix group over Integer Ring with 3 generators (
    [ 0  0  1]  [-1  0  0]  [ 0  1  0]
    [-1 -1 -1]  [ 0 -1  0]  [ 1  0  0]
    [ 1  0  0], [ 0  0 -1], [-1 -1 -1]
    )

- :meth:`Lattice_generic._act` -- computes the action of the group_element on a lattice element::

    sage: L1._act(L1.group()[1], L1.basis()[0])
    (0, 0, 1)

    sage: L2._act(L2.group()[1], L2.basis()[0])
    (1, 0, 0, 0)

- :meth:`Lattice_generic.isomorphic_ambient_lattice` -- returns an isomorphic ambient lattice.
    It is the identity for lattices that are already ambient, so it is mostly useful for sublattices::

    sage: x, y, z = L1.basis()
    sage: SL = SubLattice(L1, [x-y, y-z])
    sage: L1.isomorphic_ambient_lattice() is L1
    True
    sage: X = SL.isomorphic_ambient_lattice(); X
    Ambient free module of rank 2 over the principal ideal domain Integer Ring
    sage: X._action_matrices
    [
    [ 0 -1]  [1 0]
    [ 1 -1], [0 1]
    ]

::

    sage: L = Lattice_ambient(SymmetricGroup(2), [matrix([[0,1], [1,0]])])
    sage: x, y = L.basis()
    sage: SL = SubLattice(L, [x+y])
    sage: X = SL.isomorphic_ambient_lattice(); X
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    sage: X.basis()
    [
    (1)
    ]
    sage: X._action_matrices
    [[1]]

- :meth:`Lattice_generic.GAPMatrixGroup` -- returns the image of the group inside
    ``GL(rank,ZZ)`` as a GAP group::

    sage: L1.GAPMatrixGroup()
    Group([ [ [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ],
      [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ])
    sage: L2.GAPMatrixGroup()
    Group([ [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ],
      [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ])
    sage: L3.GAPMatrixGroup()
    Group([ [ [ 0, 0, 1 ], [ -1, -1, -1 ], [ 1, 0, 0 ] ],
      [ [ -1, 0, 0 ], [ 0, -1, 0 ], [ 0, 0, -1 ] ],
      [ [ 0, 1, 0 ], [ 1, 0, 0 ], [ -1, -1, -1 ] ] ])


- :meth:`Lattice_generic.colattice` -- returns the lattice on which the action
    of the group is composed with the inverse transpose automorphism of ``GL(n,ZZ)``::

    sage: L = Lattice_ambient(CyclicPermutationGroup(6), [matrix([[0,1], [-1,-1]])])
    sage: L._action_matrices
    [
    [ 0  1]
    [-1 -1]
    ]
    sage: L.colattice()._action_matrices
    [
    [-1  1]
    [-1  0]
    ]

- :meth:`Lattice_generic.Tate_Cohomology` : returns the isomorphism type of the `n`-th Tate Cohomology group.

For L1::

    sage: for i in range(-5,5):
    ....:     print L1.Tate_Cohomology(i)
    []
    [2]
    []
    [2]
    []
    [2]
    []
    [2]
    []
    [2]

For L2::

    sage: for i in range(-5,5):
    ....:     print L2.Tate_Cohomology(i)
    []
    [6, 6, 6, 6]
    []
    [2, 2, 2, 2]
    []
    [6, 6, 6, 6]
    []
    [2, 2, 2, 2]
    []
    [6, 6, 6, 6]

For L3::

    sage: for i in range(-5,5):
    ....:     print L3.Tate_Cohomology(i)
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    [2, 2, 2, 2, 2, 2, 2, 2]
    [2, 2, 2, 2, 2, 2]
    [2, 2, 2]
    [2]
    []
    [2]
    [2]
    [2, 2, 2]
    [2, 2, 2, 2]



- lattice.zero_sum_sublattice(ambient=False): returns the sublattice of elements whose coordinates sum up to zero.
  If ambient is True, then it will give it as an ambient lattice, otherwise just a sublattice.

EXAMPLES::

    sage: L1.zero_sum_sublattice()
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [ 1  0 -1]
    [ 0  1 -1]
    sage: L2.zero_sum_sublattice()
    Free module of degree 4 and rank 3 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0 -1]
    [ 0  1  0 -1]
    [ 0  0  1 -1]


We can make them directly ambient lattices 
::


    sage: L1.zero_sum_sublattice(True)
    Ambient free module of rank 2 over the principal ideal domain Integer Ring
    sage: _._action_matrices
    [
    [ 0  1]  [1 0]
    [-1 -1], [0 1]
    ]
    sage: L2.zero_sum_sublattice(True)
    Ambient free module of rank 3 over the principal ideal domain Integer Ring
    sage: _._action_matrices
    [
    [1 0 0]  [1 0 0]
    [0 1 0]  [0 1 0]
    [0 0 1], [0 0 1]
    ]


Now we decide not to transform it into an ambient lattice, but to create the sublattice of
zero sum vectors.
::


    sage: L=Lattice_ambient(SymmetricGroup(3),5)
    sage: L.zero_sum_sublattice()
    Free module of degree 5 and rank 4 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0  0 -1]
    [ 0  1  0  0 -1]
    [ 0  0  1  0 -1]
    [ 0  0  0  1 -1]
    sage: L.zero_sum_sublattice().zero_sum_sublattice()
    Free module of degree 5 and rank 4 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0  0 -1]
    [ 0  1  0  0 -1]
    [ 0  0  1  0 -1]
    [ 0  0  0  1 -1]

Here we see that the zero sum sublattice of the zero sum sublattice is itself, 
which is not the case when we return an ambient ambient lattice isomorphic to 
the zero sum one.
::

    sage: L=Lattice_ambient(SymmetricGroup(3),5)
    sage: SL=SubLattice(L,[L.basis()[2]+3*L.basis()[4],5*L.basis()[0]+L.basis()[1],L.basis()[1]+6*L.basi
    ....: s()[3]])
    sage: SL
    Free module of degree 5 and rank 4 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0  0 -1]
    [ 0  1  0  0 -1]
    [ 0  0  1  0 -1]
    [ 0  0  0  1 -1]
    sage: SL.zero_sum_sublattice()
    Free module of degree 5 and rank 2 over Integer Ring
    Echelon basis matrix:
    [  5   3  -5  12 -15]
    [  0   4  -7  24 -21]




- lattice.norm_one_restriction(self,group,build=True) : combines the induction and zero sum methods to return the character lattice corresponding to a norm 1 
  restriction of scalars of a Torus.


EXAMPLES::

    sage: L1.norm_one_restriction_of_scalars(SymmetricGroup(5))
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [ 1  0 -1]
    [ 0  1 -1]
    sage: L2.norm_one_restriction_of_scalars(SymmetricGroup(4))
    Free module of degree 4 and rank 3 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0 -1]
    [ 0  1  0 -1]
    [ 0  0  1 -1]

We can check the actions on each norm one restriction

    sage: L1.norm_one_restriction_of_scalars(SymmetricGroup(5))
    Free module of degree 3 and rank 2 over Integer Ring
    Echelon basis matrix:
    [ 1  0 -1]
    [ 0  1 -1]
    sage: L2.norm_one_restriction_of_scalars(SymmetricGroup(4))
    Free module of degree 4 and rank 3 over Integer Ring
    Echelon basis matrix:
    [ 1  0  0 -1]
    [ 0  1  0 -1]
    [ 0  0  1 -1]




##################################################
#
#   CLASS FOR TORI
#
##################################################


Tori are now only implemented as character lattices with an action of 
the Galois group (at least as large as the galois group of a splitting field).
For now this Galois group will just be an abstract group, 
either a permutation group or a finite matrix group in GL(n,ZZ).



 To define a torus we use AlgebraicTorus(character_lattice)

We set up now a few examples of Tori we will use the methods on
EXAMPLES ::

    sage: L=Lattice_ambient(PermutationGroup([()]),1)
    sage: AlgebraicTorus(L)
    Algebraic Torus of rank 1 defined by the following lattice :
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Permutation Group with generators [()]
    sage: T1=_
    
T1 is the split torus Gm, with action of the trivial Galois group.
::


    sage: LL=Lattice_ambient(SymmetricGroup(3),1)
    sage: AlgebraicTorus(LL)
    Algebraic Torus of rank 1 defined by the following lattice :
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Symmetric group of order 3! as a permutation group
    sage: T2=_

T2 is still Gm, with trivial action of a galois group isomorphic to S3. Note that 
this Galois group is not necessarily the one of a minimal splitting extension.
::

    sage: act1=matrix(3,[0,1,0,0,0,1,1,0,0])
    sage: act2=matrix(3,[0,1,0,1,0,0,0,0,1])
    sage: LLL=Lattice_ambient(SymmetricGroup(3),[act1,act2])
    sage: AlgebraicTorus(LLL)
    Algebraic Torus of rank 3 defined by the following lattice :
    Ambient free module of rank 3 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Symmetric group of order 3! as a permutation group
    sage: T3=_


T3 is a non-split anisotropic torus with galois group of splitting field isomorphic to S3
::

    sage: SL=SubLattice(L,[2*L.basis()[0]])
    sage: AlgebraicTorus(SL)
    Algebraic Torus of rank 1 defined by the following lattice :
    Free module of degree 1 and rank 1 over Integer Ring
    Echelon basis matrix:
    [2]
    and an action by the galois group of the form :
    Permutation Group with generators [()]

This torus is obtained from the sublattice of the first lattice L. The torus obtained is isomorphic.





########LIST OF ATTRIBUTES OF AN ALGEBRAIC TORUS########


- torus._lattice : This is the only attribute of a torus right now, it 
returns its defining character lattice


########LIST OF METHODS OF AN ALGEBRAIC TORUS########


- torus.rank() : returns the rank of the torus

EXAMPLES::

    sage: T1.rank()
    1
    sage: T2.rank()
    1
    sage: T3.rank()
    3


- torus.galois_group(): returns the Galois group (as abstract group) of the 
splitting field used to define the torus

EXAMPLES::

    sage: T1.galois_group()
    Permutation Group with generators [()]
    sage: T2.galois_group()
    Symmetric group of order 3! as a permutation group
    sage: T3.galois_group()
    Symmetric group of order 3! as a permutation group

- torus.character_lattice(): returns the character lattice of the torus

    sage: T1.character_lattice()
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    sage: T2.character_lattice()
    Ambient free module of rank 1 over the principal ideal domain Integer Ring
    sage: T3.character_lattice()
    Ambient free module of rank 3 over the principal ideal domain Integer Ring


- torus.cocharacter_lattice():

EXAMPLES ::

    sage: T3.character_lattice()._action_matrices
    [
    [0 1 0]  [0 1 0]
    [0 0 1]  [1 0 0]
    [1 0 0], [0 0 1]
    ]
    sage: T3.cocharacter_lattice()._action_matrices
    [
    [0 1 0]  [0 1 0]
    [0 0 1]  [1 0 0]
    [1 0 0], [0 0 1]
    ]

The matrices are all orthogonal so we get the same lattice. The action will be 
different in the next example.
::



    sage: Lattice_ambient(PermutationGroup([(1,2,3,4,5,6)]),[matrix(2,[0,1,-1,-1])])
    Ambient free module of rank 2 over the principal ideal domain Integer Ring
    sage: T=AlgebraicTorus(_)
    sage: T.character_lattice()._action_matrices
    [
    [ 0  1]
    [-1 -1]
    ]
    sage: T.cocharacter_lattice()._action_matrices
    [
    [-1  1]
    [-1  0]
    ]

- torus.Tate_Cohomology(n): Uses Tate-Nakayama lemma to return the isomorphism
type of the nth Tate Cohomology group of the Torus

EXAMPLES::

    sage: for i in range(-5,5) : print("H^"+str(i)+" : ") , T1.Tate_Cohomology(i)
    H^-5 :  []
    H^-4 :  []
    H^-3 :  []
    H^-2 :  []
    H^-1 :  []
    H^0 :  []
    H^1 :  []
    H^2 :  []
    H^3 :  []
    H^4 :  []




The Galois group is trivial and has obviously trivial cohomology
::

    sage: for i in range(-5,5) : print("H^"+str(i)+" : ") , T2.Tate_Cohomology(i)
    H^-5 :  []
    H^-4 :  [2]
    H^-3 :  []
    H^-2 :  [6]
    H^-1 :  []
    H^0 :  [2]
    H^1 :  []
    H^2 :  [6]
    H^3 :  []
    H^4 :  [2]

We can recognize from class field theory that H^2, which is the Brauer group of
our extension is isomorphic to the cyclic group Cn where n is the order of the 
Galois group. Here the group is S3, which has order 6 so we get C6.

Another way to see it is seeing this H^2 as H^0 of its character lattice. Since the group
acts trivially, the fixed elements are the whole lattice, and the trace map is multiplication
by the order of the group, which is 6, so we get C6^(rank of T1)


Also, H^0 can be seen as the abelianization of the Galois group, which here has order
2 (it is the group of signatures)
::

    sage: for i in range(-5,5) : print("H^"+str(i)+" : ") , T3.Tate_Cohomology(i)
    H^-5 :  []
    H^-4 :  [2]
    H^-3 :  []
    H^-2 :  [2]
    H^-1 :  []
    H^0 :  [2]
    H^1 :  []
    H^2 :  [2]
    H^3 :  []
    H^4 :  [2]
   
In this example, we can see the 2-periodicity of the cohomology groups, consequence
of the group being cyclic.

- torus.restriction_of_scalars(group): returns the torus obtained by restriction of scalars.
The use has to input the (larger) galois group for this extension. More concretely, 
if the torus is defined over K, splits over L, and is defined by the action of Gal(L/K)
on its character lattice, then if one want the restriction of scalars to a smaller field k,
one has to enter Gal(L/k) as argument of this method. 

EXAMPLES ::

    sage: T1.restriction_of_scalars(PermutationGroup([(1,2),(3,4),(5,6),(7,8)]))
    Algebraic Torus of rank 16 defined by the following lattice :
    Ambient free module of rank 16 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Permutation Group with generators [(7,8), (5,6), (3,4), (1,2)]


    sage: T2.restriction_of_scalars(SymmetricGroup(4))
    Algebraic Torus of rank 4 defined by the following lattice :
    Ambient free module of rank 4 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Symmetric group of order 4! as a permutation group
    sage: _.character_lattice()._action_matrices
    [
    [0|0|0|1]  [1|0|0|0]
    [-+-+-+-]  [-+-+-+-]
    [1|0|0|0]  [0|1|0|0]
    [-+-+-+-]  [-+-+-+-]
    [0|1|0|0]  [0|0|0|1]
    [-+-+-+-]  [-+-+-+-]
    [0|0|1|0], [0|0|1|0]
    ]
    sage: T3.restriction_of_scalars(SymmetricGroup(4))
    Algebraic Torus of rank 12 defined by the following lattice :
    Ambient free module of rank 12 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Symmetric group of order 4! as a permutation group
    sage: _.character_lattice()._action_matrices
    [
    [0 0 0|0 0 0|0 0 0|1 0 0]  [0 1 0|0 0 0|0 0 0|0 0 0]
    [0 0 0|0 0 0|0 0 0|0 1 0]  [1 0 0|0 0 0|0 0 0|0 0 0]
    [0 0 0|0 0 0|0 0 0|0 0 1]  [0 0 1|0 0 0|0 0 0|0 0 0]
    [-----+-----+-----+-----]  [-----+-----+-----+-----]
    [0 1 0|0 0 0|0 0 0|0 0 0]  [0 0 0|0 1 0|0 0 0|0 0 0]
    [0 0 1|0 0 0|0 0 0|0 0 0]  [0 0 0|1 0 0|0 0 0|0 0 0]
    [1 0 0|0 0 0|0 0 0|0 0 0]  [0 0 0|0 0 1|0 0 0|0 0 0]
    [-----+-----+-----+-----]  [-----+-----+-----+-----]
    [0 0 0|0 1 0|0 0 0|0 0 0]  [0 0 0|0 0 0|0 0 0|1 0 0]
    [0 0 0|0 0 1|0 0 0|0 0 0]  [0 0 0|0 0 0|0 0 0|0 1 0]
    [0 0 0|1 0 0|0 0 0|0 0 0]  [0 0 0|0 0 0|0 0 0|0 0 1]
    [-----+-----+-----+-----]  [-----+-----+-----+-----]
    [0 0 0|0 0 0|0 1 0|0 0 0]  [0 0 0|0 0 0|1 0 0|0 0 0]
    [0 0 0|0 0 0|0 0 1|0 0 0]  [0 0 0|0 0 0|0 1 0|0 0 0]
    [0 0 0|0 0 0|1 0 0|0 0 0], [0 0 0|0 0 0|0 0 1|0 0 0]
    ]




- torus.norm_one_restriction(group): like the restriction of scalars map except we take the 
torus of norm 1 elements.
::


    sage: T1.norm_one_restriction(PermutationGroup([(1,2),(3,4),(5,6),(7,8)]))
    Algebraic Torus of rank 15 defined by the following lattice :
    Ambient free module of rank 15 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Permutation Group with generators [(7,8), (5,6), (3,4), (1,2)]
    sage: _.character_lattice()._action_matrices[0]
    [ 0  1  0  0  0  0  0  0  0  0  0  0  0  0  0]
    [ 1  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
    [ 0  0  0  1  0  0  0  0  0  0  0  0  0  0  0]
    [ 0  0  1  0  0  0  0  0  0  0  0  0  0  0  0]
    [ 0  0  0  0  0  1  0  0  0  0  0  0  0  0  0]
    [ 0  0  0  0  1  0  0  0  0  0  0  0  0  0  0]
    [ 0  0  0  0  0  0  0  1  0  0  0  0  0  0  0]
    [ 0  0  0  0  0  0  1  0  0  0  0  0  0  0  0]
    [ 0  0  0  0  0  0  0  0  0  1  0  0  0  0  0]
    [ 0  0  0  0  0  0  0  0  1  0  0  0  0  0  0]
    [ 0  0  0  0  0  0  0  0  0  0  0  1  0  0  0]
    [ 0  0  0  0  0  0  0  0  0  0  1  0  0  0  0]
    [ 0  0  0  0  0  0  0  0  0  0  0  0  0  1  0]
    [ 0  0  0  0  0  0  0  0  0  0  0  0  1  0  0]
    [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
    sage: T2.norm_one_restriction(SymmetricGroup(4))
    Algebraic Torus of rank 3 defined by the following lattice :
    Ambient free module of rank 3 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Symmetric group of order 4! as a permutation group
    sage: _.character_lattice()._action_matrices
    [
    [-1 -1 -1]  [ 1  0  0]
    [ 1  0  0]  [ 0  1  0]
    [ 0  1  0], [-1 -1 -1]
    ]
    sage: T3.norm_one_restriction(SymmetricGroup(4))
    Algebraic Torus of rank 11 defined by the following lattice :
    Ambient free module of rank 11 over the principal ideal domain Integer Ring
    and an action by the galois group of the form :
    Symmetric group of order 4! as a permutation group
    sage: _.character_lattice()._action_matrices
    [
    [ 0  0  0  0  0  0  0  0  0  1  0]  [ 0  1  0  0  0  0  0  0  0  0  0]
    [ 0  0  0  0  0  0  0  0  0  0  1]  [ 1  0  0  0  0  0  0  0  0  0  0]
    [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]  [ 0  0  1  0  0  0  0  0  0  0  0]
    [ 0  1  0  0  0  0  0  0  0  0  0]  [ 0  0  0  0  1  0  0  0  0  0  0]
    [ 0  0  1  0  0  0  0  0  0  0  0]  [ 0  0  0  1  0  0  0  0  0  0  0]
    [ 1  0  0  0  0  0  0  0  0  0  0]  [ 0  0  0  0  0  1  0  0  0  0  0]
    [ 0  0  0  0  1  0  0  0  0  0  0]  [ 0  0  0  0  0  0  0  0  0  1  0]
    [ 0  0  0  0  0  1  0  0  0  0  0]  [ 0  0  0  0  0  0  0  0  0  0  1]
    [ 0  0  0  1  0  0  0  0  0  0  0]  [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
    [ 0  0  0  0  0  0  0  1  0  0  0]  [ 0  0  0  0  0  0  1  0  0  0  0]
    [ 0  0  0  0  0  0  0  0  1  0  0], [ 0  0  0  0  0  0  0  1  0  0  0]
    ]

We now compute the cohomologies of all those tori.
For the two latter examples, we check that we get different cohomologies with the
same group, and the norm one restriction of the split torus has nontrivial cohomology
::

    sage: ROS=T1.norm_one_restriction(PermutationGroup([(1,2),(3,4),(5,6),(7,8)]))
    sage: for i in range(-4,6) : print("H^"+str(i)+" : ") , ROS.Tate_Cohomology(i)
    H^-4 :  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    H^-3 :  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    H^-2 :  [2, 2, 2, 2, 2, 2]
    H^-1 :  [2, 2, 2, 2]
    H^0 :  []
    H^1 :  [16]
    H^2 :  []
    H^3 :  [16]
    H^4 :  [2, 2, 2, 2, 2, 2]
    H^5 :  [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]

This torus ROS is the example of Ono where he applies his formula for the Tamagawa
number of a Torus. See his paper 'On the Tamagawa Number of Algebraic Tori'.
::

    sage: ROS2=T2.norm_one_restriction(SymmetricGroup(4))
    sage: for i in range(-4,6) : print("H^"+str(i)+" : ") , T2.Tate_Cohomology(i)
    H^-4 :  [2]
    H^-3 :  []
    H^-2 :  [6]
    H^-1 :  []
    H^0 :  [2]
    H^1 :  []
    H^2 :  [6]
    H^3 :  []
    H^4 :  [2]
    H^5 :  []

    sage: ROS3=T3.norm_one_restriction(SymmetricGroup(4))
    sage: for i in range(-4,6) : print("H^"+str(i)+" : ") , ROS3.Tate_Cohomology(i)
    H^-4 :  [2, 2]
    H^-3 :  [2, 12]
    H^-2 :  [2, 2]
    H^-1 :  [2]
    H^0 :  [2]
    H^1 :  [12]
    H^2 :  []
    H^3 :  [12]
    H^4 :  [2]
    H^5 :  [12]






"""

###########################################################################
#       Copyright (C) 2018 Thomas RÃ¼d <tompa.rud@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
###########################################################################


from __future__ import print_function, absolute_import



from sage.schemes.generic.scheme import Scheme
from sage.categories.morphism import SetMorphism
"""
from sage.modules.free_module import FreeModule_generic_pid
"""
from sage.matrix.action import MatrixMulAction
from sage.categories.action import PrecomposedAction
from six import integer_types
from sage.rings.integer_ring import ZZ
from sage.groups.perm_gps.permgroup import PermutationGroup
from sage.groups.perm_gps.permgroup_element import SymmetricGroupElement
from sage.categories.map import Map
from sage.modules.free_module import FreeModule_ambient_pid 
from sage.modules.free_module import FreeModule_generic
from sage.modules.free_module import FreeModule_submodule_pid
import sage.groups.libgap_group
import sage.matrix.matrix0
from sage.categories.homset import Hom
from sage.groups.matrix_gps.catalog import GL
from sage.libs.gap.element import GapElement
import sage.groups.libgap_wrapper 
import sage.groups.libgap_group
import sage.libs.gap.util
from sage.libs.gap.libgap import libgap
from sage.interfaces.gap import gap
from sage.matrix.constructor import matrix
from sage.combinat.permutation import Permutation
from sage.matrix.matrix_space import MatrixSpace
from sage.groups.matrix_gps.finitely_generated import MatrixGroup
from sage.groups.perm_gps.permgroup import load_hap
from sage.matrix.special import block_matrix




def extended_xgcd(lst,result=[1]):
    if len(lst)==0 :
        raise ValueError("Missing numbers to take the gcd")
    elif len(lst)==1 :
        return (lst[0],result)
    else:
        a,b,c=xgcd(lst[0],lst[1])
        r=[b*i for i in result]
        return extended_xgcd([a]+[lst[i] for i in range(2,len(lst))],r+[c])



###############################################################################
#
# Base class for all group schemes
#
###############################################################################


def is_GroupScheme(X):
    return isinstance(X,GroupScheme)



class GroupScheme(Scheme):
    """Group_scheme"""
    def __init__(self, X=None):
        Scheme.__init__(self,X)
        








class GAPMap_toGLn(Map):
    """Get a Sage Map from a GAP group homomorphism with values in matrices  """
    def __init__(self, galois,rank, hom):
        Map.__init__(self,Hom(galois,GL(rank,ZZ)))
        self._morphism=hom
        self._domain=galois
        self._codomain=GL(rank,ZZ)
    def _call_(self,element):
        if element is tuple:
            Elt=Permutation(element)
        else:
            Elt=element
        return matrix((gap.Image(self._morphism,Elt)).sage())
        



###############################################################################
#
# Base class for all lattices
#
###############################################################################




class Lattice_generic(FreeModule_generic):


 

    def __init__(self, galois, action=1, check=True):
        if type(galois)==list :
            self._group=MatrixGroup(galois)
            self._generators=galois
            self._rank = galois[0].nrows()
            self._action_matrices=galois
            FreeModule_generic.__init__(self,ZZ,self._rank,self._rank)
            A=libgap(galois)
            G=gap.GroupByGenerators(A)
            self._action_morphism=gap.GroupHomomorphismByImages(G,G,A,A)
        else:
            self._group=galois
            self._generators=galois.gens()
            if action  in ZZ: 
                FreeModule_generic.__init__(self,ZZ,action,action)
                self._rank=action
                self._action_matrices=[matrix.identity(action) for i in range(len(self._generators))]
            elif not len(action) :
                raise ValueError('The module is missing the action of the Galois group.')
            else:
                self._action_matrices=action    
                for x in action: 
                    if not x.nrows()==x.ncols():
                        raise ValueError('The matrices for the action need to be squares.')
                    elif not x.nrows()==action[0].nrows(): 
                        raise ValueError('The matrices fot the action need to have same dimension.')
                    elif not x in GL(action[0].nrows(),ZZ):
                     raise ValueError('The matrices need to be invertible in ZZ.')
                    else :
                        self._rank=action[0].nrows()
                        FreeModule_generic.__init__(self,ZZ,self._rank,self._rank)
                if not len(self._generators)==len(action):
                    raise ValueError('The number of action matrices needs to match the number of generators of the Galois group.')
            G=gap(self._group)
            GenG=gap(self._generators)
            Mats=gap(self._action_matrices)
            if self._rank==1 : 
                gl=gap.Group([ [ [ -1 ] ] ])
            else :
                gl=gap.GL(self._rank,ZZ)
            self._action_morphism=gap.GroupHomomorphismByImages(G,gl,GenG,Mats)
            if check and gap.IsBool(self._action_morphism) :
                raise ValueError('The action is not well defined') 

        self._GAPMap=GAPMap_toGLn(self._group,self._rank,self._action_morphism)
        MZ=MatrixSpace(ZZ,self._rank)
        A=MZ.get_action(self)
        self._action=PrecomposedAction(A,self._GAPMap,None)
    def _act(self,g,e):
        return  self._action.act(g,e)






    ##### METHODS FOR LATTICES WITH GROUP ACTIONS######
    def group(self):
        return self._group

    def isomorphic_ambient_lattice(self):
        return self.ambientify()

    def GAPMatrixGroup(self):
        f=self._GAPMap
        return gap.Image(f._morphism)


    def colattice(self):
        newacts = [ i.inverse().transpose() for i in self._action_matrices]
        return Lattice_ambient(self._group,newacts)
    

    def Tate_Cohomology(self,n):
        return self.Tate_Cohomology(n)

    def induced_lattice(self,group,build=True):
        """
        The ambient lattice obtained by inducing the representation of
        the group to a bigger group.

        INPUT:

        - ``group`` -- a group containing the group for this lattice.

        - ``build`` -- boolean (default True).  If False, just returns the matrices
           that define the action on the induced lattice but doesn't build the lattice.

        NOTE::

            This is not yet implemented when a lattice is declared with a matrix group since
            Sage doesn't handle cosets for matrix groups.

        EXAMPLES::

            sage: G = PermutationGroup([(1,2), (3,4,5)])
            sage: act1 = matrix(3, [0,1,0,0,0,1,1,0,0])
            sage: act2 = matrix(3, [1,0,0,0,1,0,0,0,1])
            sage: L1 = Lattice_ambient(G, [act1, act2])
            sage: L1.induced_lattice(SymmetricGroup(5))
            Ambient free module of rank 60 over the principal ideal domain Integer Ring

            sage: L2 = Lattice_ambient(SymmetricGroup(3), 4)
            sage: L2.induced_lattice(SymmetricGroup(4), False)
            [
            [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]  [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]  [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]  [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]  [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [1 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]
            [0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]
            [0 0 1 0|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]
            [0 0 0 1|0 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [0 0 0 0|1 0 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|1 0 0 0]
            [0 0 0 0|0 1 0 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 1 0 0]
            [0 0 0 0|0 0 1 0|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 1 0]
            [0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1]
            [-------+-------+-------+-------]  [-------+-------+-------+-------]
            [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|1 0 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 1 0 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]  [0 0 0 0|0 0 0 0|0 0 1 0|0 0 0 0]
            [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0], [0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0]
            ]
        """
        return self.induced_lattice(group, build)

    def zero_sum_sublattice(self,ambient=False):
        return self.zero_sum_sublattice(ambient)
    def norm_one_restriction_of_scalars(self,group,ambient=False):
        return self.norm_one_restriction_of_scalars(self,group,ambient)









class Lattice_ambient(FreeModule_ambient_pid,Lattice_generic):
    """
    Generates the Character lattice  with Galois action
    If the parameter action is an integer, it will be the rank of the ZZ-module, seen with trivial Galois action. Otherwise, action should be an r-tuple of matrice where r is the number of generators or the group.


    """

    def __init__(self, galois, action=1, check=True):
        Lattice_generic.__init__(self,galois,action,check)
        FreeModule_ambient_pid.__init__(self,ZZ,self._rank)


    def ambientify(self):
        return self








    def Tate_Cohomology(self,n):
        
        MG=self.GAPMatrixGroup()

        if type(self._group[0]) is PermutationGroupElement :
            G=libgap(self._group)  
        elif type(self._group[0]) is SymmetricGroupElement :
            G=gap.Group([gap(i) for i in self._generators])
        else :
            G=gap.Group(self._action_matrices)
        #This is a slight adaptation of the code from Hoshi and Yamasaki done on GAP
        if n==0 :
            M=matrix.zero(self._rank)
            if type(self._group[0]) is PermutationGroupElement or type(self._group[0]) is SymmetricGroupElement  :
                Lst=[libgap(i) for i in self._group]
            else:
                Lst=[i.gap() for i in self._group]
            for i in Lst:
                M+=matrix(gap.Image(self._action_morphism,i).sage())
            #M=matrix((libgap.Sum(MG)).sage())
            S=M.smith_form(False,True)
            R=S.rank()
            RR=[S[i][i] for i in range(R)]
            return [i for i in RR if i>1]
        elif n==-1 :
            m=gap([])
            for i in gap.GeneratorsOfGroup(MG) : 
                m=gap.Concatenation(m,i-gap.Identity(MG))
            ms=matrix(m.sage())
            s=ms.smith_form(False,True)
            r=s.rank()
            rr=gap([s[i][i] for i in range(r)])
            return [i for i in rr if i>1]
        else  :
            load_hap()
            if n>0 :
                #This computes the standard resolution of G in HAP
                R = gap.ResolutionFiniteGroup(G,n+1)
                #Then applies the map to the action to the resolution
                TR = gap.HomToIntegralModule(R,self._action_morphism)
                #Might have a problem because gap does only right actions ?
                return (gap.Cohomology(TR,n)).sage()
            else :
                R = gap.ResolutionFiniteGroup(G,-n)
                TR = gap.TensorWithIntegralModule(R,self._action_morphism)
                return (gap.Homology(TR,-n-1)).sage()



    #.self._induced_lattice(containing_group,build) computes the lattice obtained by induction from 
    #the group defining the lattice to a bigger group "containing_group" 


    #The build argument will ensure that we build the lattice if it is true, 
    #otherwise it just gives us the matrices needed to build the lattice with
    #the group we input, this will be useful to get other constructions like 
    #the character lattice of the norm 1 restriction of scalars torus



    def induced_lattice(self,group,build=True):
        LCos=group.cosets(self._group,'left')
        LCosReps=[i[0] for i in LCos]
        LCosnum=len(LCos)
    #get_coset_index will take an element g of G and return the index of the coset it belongs to
        def get_coset_index(g):
            for i in range(LCosnum):
                if g in LCos[i]:
                    return i
            raise ValueError('Found an element which does not belong to any coset')

    #decomp takes an element g of the big group G, and returns a pair
        def decomp(g):
            i=get_coset_index(g)
            return [i,(LCosReps[i].inverse())*g]
        r"""
        decomp2(element,index) will do the main computation for the group action on the 
        induced lattice (we deal with finite groups so induced is the same as coinduced)
        -\ZZ[G]\otimes_{\ZZ[H]} L -

         To do so, we look at the multiplication g*gi where gi is a representative of the
         ith left coset
        """

        def decomp2(g,i):
            return decomp(g*LCosReps[i])


        #Now we create block matrices corresponding to actions of each generator of G, it 
        #is the composition of a block unimodular matrix for permutation of blocks
        #and the block diagonal matrix applying the correct element of H to each block

        def make_matrix(g):
            Lst=[]
            Bigmatlist = []
            for i in range(LCosnum) : 
                Lst.append(decomp2(g,i))
            Matlist=[matrix.zero(self._rank) for j in range(LCosnum)]
            Matlist=[ matrix((gap.Image(self._action_morphism,gap(j[1]))).sage())   for j in Lst]
            for i in range(LCosnum):
                Bigmatlist+=[Matlist[j] if Lst[j][0]==i else matrix.zero(self._rank)   for j in range(LCosnum)]
            return block_matrix(LCosnum,LCosnum,Bigmatlist)

  

        GGen=self._generators




    



        gens_induced_act = [make_matrix(g) for g in group.gens()]
        if build :
            return Lattice_ambient(group,gens_induced_act)   
        else:
            return gens_induced_act
    #now we build the character lattice for the norm 1 restrictions of scalars        
    def zero_sum_sublattice(self,ambient=False):
        if ambient:
            A=self
            acts=self._action_matrices
            newacts=[A[[i for i in range(A.ncols()-1)],[i for i in range(A.ncols()-1)]]-A[[i for i in range(A.ncols()-1)],[A.ncols()-1]]*matrix(1,[1 for i in range(A.ncols()-1)]) for A in acts]
            return Lattice_ambient(self._group,newacts)
        else :
            oldBasis=self.basis()
            newBasis = [ oldBasis[i]-oldBasis[len(oldBasis)-1]     for i in range(len(oldBasis)-1)  ]
            return SubLattice(self,newBasis)
        r"""
        This does the following, for each nxn matrix defining the action of the induced representation, 
        it extracts two blocks
        (        |   )
        (    A   | B )     A which is of size n-1 x n-1
        (        |   ) and B which is of size n-1 x 1 
        (------------)
        (    C   | D )

        Then it computes the action for the norm 1 restriction of scalars, which is
        A - B * (1,1,...,1)


        Indeed, since the norm 1 restriction lattice will be the sublattice 
        of elements summing up to 1, so we only consider the first n-1 basis elements, 
        doing the matrix computation, the element l=(l_1,...l_(n-1)) is sent to 
        A *l + B * (-sum_i l_i), which is the transformation A-B*(1,...,1)
        """

    def norm_one_restriction_of_scalars(self,group,ambient=True):
        return self.induced_lattice(group).zero_sum_sublattice(ambient)


 


class SubLattice(Lattice_generic,FreeModule_submodule_pid):
    def __init__(self, lattice,basis,check=True):
        Lattice_generic.__init__(self,lattice._group,lattice._action_matrices)
        FreeModule_submodule_pid.__init__(self,lattice,basis)
        self._parent_lattice=lattice
        if check:
            for i in lattice._group.gens():
                for j in basis:
                    if not lattice._act(i,j) in self:
                        raise ValueError("The basis is not stable under the action of the group")

    def ambientify(self):
        oldBasis=self.basis()
        act_builder=[]
        for g in self._group.gens() :
            mat_builder=[]
            for i in oldBasis:
                mat_builder.append(self.coordinate_vector(self._act(g,i)))
            act_builder.append(matrix(mat_builder))
        return Lattice_ambient(self._group,act_builder)

    def Tate_Cohomology(self,n):
        return self.ambientify().Tate_Cohomology(n)

    def induced_lattice(self,group):
        return self.ambientify().induced_lattice(group)

    def norm_one_restriction_of_scalars(self,group):
        return self.ambientify().induced_lattice(group)
    



    def zero_sum_sublattice(self,ambient=False):
        oldBasis=self.basis()
        newBasis=[]
        diagonal=0
        for i in self._parent_lattice.basis():
            diagonal+=i
        totals=[i.inner_product(diagonal) for i in oldBasis]
        gcd,coefs=extended_xgcd(totals)
        if gcd==0 : 
            return self
        dist_elt=0
        for i in range(len(oldBasis)):
            dist_elt+=coefs[i]*oldBasis[i]
        for i in range(len(oldBasis)):
            newBasis.append(oldBasis[i]-(totals[i]/gcd)*dist_elt)
        while 0 in newBasis :
            newBasis.remove(0)
        result=SubLattice(self._parent_lattice,newBasis)
        return result if not ambient else result.ambientify()




		
		
class AlgebraicTorus(GroupScheme):
    """
    Creates an algebraic torus through its equivalence of categories with the action of a Galois Group on an integral lattice.




    """

    def __init__(self, lattice):
        """
        TO DO

        """
        GroupScheme.__init__(self)
        if lattice is None:
        	raise ValueError('You have to specify a lattice.')
        else:
            self._lattice = lattice
    def _repr_(self):
        return "Algebraic Torus of rank %s defined by the following lattice :\n"%(self.rank())+self._lattice._repr_()+"\nand an action by the galois group of the form :\n"+self._lattice._group._repr_() 

    def rank(self):
        return self._lattice._rank

    def galois_group(self):
        return self._lattice._group

    def character_lattice(self):
        return self._lattice

    def cocharacter_lattice(self):
        return self._lattice.colattice()


    def Tate_Cohomology(self,n):
        #This gives the isomorphism type of the nth cohomology group using Tate-Nakayama duality 
        return self._lattice.Tate_Cohomology(2-n)

        #gives the torus representing the Restriction of scalars. 
        #Right now, for a torus defined over K, splitting over L, 
        #to compute the restriction of scalars to k inside K, 
        #the user has to enter the galois group of the extension L/k
        #In the future, when we will have a better notion for Galois group
        #perhaps we can deal with fields directly.


    def restriction_of_scalars(self,group):
        return AlgebraicTorus(self._lattice.induced_lattice(group))
    def norm_one_restriction(self,group):
        return AlgebraicTorus(self._lattice.norm_one_restriction_of_scalars(group,True))
