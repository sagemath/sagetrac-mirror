# -*- coding: utf-8 -*-
"""
Homology and cohomology with a basis

This module provides homology and cohomology vector spaces suitable
for computing cup products and cohomology operations.

REFERENCES:

.. [G-DR03] R. González-Díaz and P. Réal, *Computation of cohomology
   operations on finite simplicial complexes* in Homology,
   Homotopy and Applications 5 (2003), 83-93.

.. [G-DR99] R. González-Díaz and P. Réal, *A combinatorial method for
   computing Steenrod squares* in J. Pure Appl. Algebra 139 (1999), 89-108.

AUTHORS:

- John H. Palmieri (2015-09)
"""

########################################################################
#       Copyright (C) 2015 John H. Palmieri <palmieri@math.washington.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#
#                  http://www.gnu.org/licenses/
########################################################################

from sage.combinat.free_module import CombinatorialFreeModule, CombinatorialFreeModuleElement
from simplicial_complex import SimplicialComplex

class HomologyVectorSpaceWithBasis(CombinatorialFreeModule):
    r"""
    Homology (or cohomology) vector space.

    This is intended to provide enough structure to allow the
    computation of cup products and cohomology operations. The former
    has been implemented, but not the latter (yet).

    It also requires field coefficients (hence the "VectorSpace" in
    the name of the class).

    .. NOTE::

        This is not intended to be used directly by the user, but instead
        via the methods
        :meth:`cell_complex.CellComplex.homology_with_basis` and
        :meth:`cell_complex.CellComplex.cohomology_with_basis`.

    INPUT:

    - ``deg`` -- the degree of this homology group
    - ``contraction`` -- the chain contraction associated to this
      homology computation
    - ``cell_complex`` -- the cell complex whose homology we are
      computing

    EXAMPLES:

    Homology classes are denoted by ``h_{d,i}`` where ``d`` is the
    degree of the homology class and ``i`` is their index in the list
    of basis elements. Cohomology classes are denoted ``h^{1,0}``::

        sage: RP2 = cubical_complexes.RealProjectivePlane()
        sage: RP2.homology_with_basis(1, GF(2))
        Free module generated by (h_{1,0},) over Finite Field of size 2
        sage: RP2.cohomology_with_basis(1, GF(2))
        Free module generated by (h^{1,0},) over Finite Field of size 2
        sage: simplicial_complexes.Torus().homology_with_basis(1, QQ)
        Free module generated by (h_{1,0}, h_{1,1}) over Rational Field

    To access a basis element, use its index (0 or 1 in the 1st
    cohomology group of a torus)::

        sage: H1 = simplicial_complexes.Torus().cohomology_with_basis(1, QQ)
        sage: H1.indices()
        {0, 1}
        sage: H1.basis()[0]
        h^{1,0}
        sage: H1.basis()[1]
        h^{1,1}

    You can then form linear combinations of these easily enough::

        sage: x = H1.basis()[0]
        sage: y = H1.basis()[1]
        sage: 2*x-3*y
        2*h^{1,0} - 3*h^{1,1}

    Or you can use the :meth:`from_vector` method to do this in one step::

        sage: H1.from_vector(vector((2, -3)))
        2*h^{1,0} - 3*h^{1,1}

    You can compute cup products of cohomology classes::

        sage: x.cup_product(y)
        h^{2,0}
        sage: y.cup_product(x)
        -h^{2,0}
        sage: x.cup_product(x)
        0

    This works with simplicial, cubical, and Delta complexes::

        sage: Klein_c = cubical_complexes.KleinBottle()
        sage: H1 = Klein_c.cohomology_with_basis(1, GF(2))
        sage: x,y = H1.basis()
        sage: x.cup_product(x)
        h^{2,0}
        sage: x.cup_product(y)
        0
        sage: y.cup_product(y)
        h^{2,0}

        sage: Klein_d = delta_complexes.KleinBottle()
        sage: H1 = Klein_d.cohomology_with_basis(1, GF(2))
        sage: u,v = H1.basis()
        sage: u.cup_product(u)
        h^{2,0}
        sage: u.cup_product(v)
        0
        sage: v.cup_product(v)
        h^{2,0}

    The basis elements in the simplicial complex case have been chosen
    differently; apply the change of basis `x \mapsto a+b`, `y \mapsto
    b` to see the same product structure. ::

        sage: Klein_s = simplicial_complexes.KleinBottle()
        sage: H1 = Klein_s.cohomology_with_basis(1, GF(2))
        sage: a,b = H1.basis()
        sage: a.cup_product(a)
        0
        sage: a.cup_product(b)
        h^{2,0}
        sage: (a+b).cup_product(a+b)
        h^{2,0}
        sage: b.cup_product(b)
        h^{2,0}

    """
    def __init__(self, deg, contraction, cell_complex):
        """
        Initialize ``self``.

        EXAMPLES::

            sage: RP2 = simplicial_complexes.ProjectivePlane()
            sage: RP2.homology_with_basis(1, QQ) # indirect doctest
            Free module generated by () over Rational Field
            sage: RP2.homology_with_basis(1, GF(2))
            Free module generated by (h_{1,0},) over Finite Field of size 2
            sage: RP2.cohomology_with_basis(1, GF(2))
            Free module generated by (h^{1,0},) over Finite Field of size 2
            sage: RP2.cohomology_with_basis(1, GF(5))
            Free module generated by () over Finite Field of size 5
        """
        self._contraction = contraction
        # M is the homology chain complex.
        M = self._contraction.pi()._codomain
        self._degree = deg
        self._complex = cell_complex
        rank = M.free_module_rank(deg)
        # Homology vs. cohomology is detected by the degree of the
        # differential in the relevant chain complexes:
        self._cohomology = (M.degree_of_differential() == 1)
        CombinatorialFreeModule.__init__(self, M.base_ring(), range(rank))

    def degree(self):
        r"""
        The degree of this homology group: if this is `H_n(K)` for some
        complex `K`, return `n`.

        EXAMPLES::

            sage: H2 = simplicial_complexes.Torus().homology_with_basis(2, GF(7))
            sage: H2.degree()
            2
        """
        return self._degree

    def contraction(self):
        r"""
        The chain contraction associated to this homology computation.

        That is, to work with chain representatives of homology
        classes, we need the chain complex `C` associated to the cell
        complex, the chain complex `H` of its homology (with trivial
        differential), chain maps `\pi: C \to H` and `\iota: H \to C`,
        and a chain contraction `\phi` giving a chain homotopy between
        `1_C` and `\iota \circ \pi`.

        OUTPUT: `\phi`

        See :class:`chain_homotopy.ChainContraction` for information
        about chain contractions, and see
        :func:`algebraic_topological_model.algebraic_topological_model`
        for the construction of this particular chain contraction
        `\phi`.

        EXAMPLES::

            sage: H1 = simplicial_complexes.Simplex(2).homology_with_basis(1, QQ)
            sage: H1.contraction()
            Chain homotopy between
              Chain complex morphism
                From: Chain complex with at most 3 nonzero terms over Rational Field
                To: Chain complex with at most 3 nonzero terms over Rational Field
              and Chain complex morphism
                From: Chain complex with at most 3 nonzero terms over Rational Field
                To: Chain complex with at most 3 nonzero terms over Rational Field

        From the chain contraction, one can also recover the maps `\pi`
        and `\iota`::

            sage: phi = H1.contraction()
            sage: phi.pi()
            Chain complex morphism
              From: Chain complex with at most 3 nonzero terms over Rational Field
              To: Chain complex with at most 1 nonzero terms over Rational Field
            sage: phi.iota()
            Chain complex morphism
              From: Chain complex with at most 1 nonzero terms over Rational Field
              To: Chain complex with at most 3 nonzero terms over Rational Field
        """
        return self._contraction

    def complex(self):
        """
        The cell complex whose homology is being computed.

        EXAMPLES::

            sage: H1 = simplicial_complexes.Simplex(2).homology_with_basis(1, QQ)
            sage: H1.complex()
            Simplicial complex with vertex set (0, 1, 2) and facets {(0, 1, 2)}
        """
        return self._complex

    def _repr_(self):
        """
        EXAMPLES::

            sage: simplicial_complexes.Torus().homology_with_basis(1, QQ)
            Free module generated by (h_{1,0}, h_{1,1}) over Rational Field
        """
        return "Free module generated by {} over {}".format(tuple(self.basis()), self.base_ring())

    def _repr_term(self, i):
        """
        Return ``'h_{d,i}'`` for the ``i``-th generator in degree ``d``
        for homology, ``'h^{d,i}'`` for cohomology.

        EXAMPLES::

            sage: H1 = simplicial_complexes.Torus().homology_with_basis(1, QQ)
            sage: H1.basis()[0] # indirect doctest
            h_{1,0}
            sage: latex(H1.basis()[1]) # indirect doctest
            h_{1,1}
            sage: co = simplicial_complexes.KleinBottle().homology_with_basis(1, GF(2), cohomology=True)
            sage: co.basis()[0] # indirect doctest
            h^{1,0}
        """
        sym = '^' if self._cohomology else '_'
        return 'h{}{{{},{}}}'.format(sym, self.degree(), i)

    _latex_term = _repr_term

    # We need an element class so we can apply iota to the elements,
    # compute cup products, Steenrod operations, etc.

    class Element(CombinatorialFreeModuleElement):

        def to_cycle(self):
            r"""
            (Co)cycle representative of this (co)homology class.

            EXAMPLES::

                sage: S2 = simplicial_complexes.Sphere(2)
                sage: H2 = S2.homology_with_basis(2, QQ)
                sage: H2.basis()[0]
                h_{2,0}
                sage: H2.basis()[0].to_cycle()
                -(0, 1, 2) + (0, 1, 3) - (0, 2, 3) + (1, 2, 3)

            Chains are written as linear combinations of simplices
            `\sigma`. Cochains are written as linear combinations of
            characteristic functions `\chi_{\sigma}` for those
            simplices::

                sage: S2.cohomology_with_basis(2, QQ).basis()[0].to_cycle()
                \chi_(0, 1, 3)
                sage: S2.cohomology_with_basis(0, QQ).basis()[0].to_cycle()
                \chi_(0,) + \chi_(1,) + \chi_(2,) + \chi_(3,)
            """
            deg = self.parent().degree()
            vec = self.parent().contraction().iota().in_degree(deg) * self.to_vector()
            chains = self.parent().complex().n_chains(deg, self.base_ring(),
                                                   cochains=self.parent()._cohomology)
            return chains.from_vector(vec)

        def cup_product(self, other):
            r"""
            The cup product of this element with ``other``.

            INPUT:

            - ``other`` -- a cohomology class from the same cell complex

            Algorithm: see González-Díaz and Réal [G-DR03]_, p. 88.
            Given two cohomology classes, lift them to cocycle
            representatives using :meth:`to_cycle`. In the sum of
            their dimensions, look at all of the homology classes
            `\gamma`: lift each of those to a cycle representative,
            apply the Alexander-Whitney diagonal map to each cell in
            the cycle, evaluate the two cocycles on these factors, and
            multiply. The result is the value of the cup product
            cocycle on this homology class. After this has been done
            for all homology classes, since homology and cohomology
            are dual, one can tell which cohomology class corresponds
            to the cup product.

            EXAMPLES::

                sage: RP3 = simplicial_complexes.RealProjectiveSpace(3)
                sage: H1 = RP3.cohomology_with_basis(1, GF(2))
                sage: c = H1.basis()[0]
                sage: c.cup_product(c).cup_product(c)
                h^{3,0}

                sage: T = simplicial_complexes.Torus()
                sage: x,y = list(T.cohomology_with_basis(1, QQ).basis())
                sage: x.cup_product(y)
                h^{2,0}
                sage: x.cup_product(x)
                0

                sage: one = T.cohomology_with_basis(0, QQ).basis()[0]
                sage: x.cup_product(one)
                h^{1,0}
                sage: one.cup_product(y) == y
                True
                sage: one.cup_product(one)
                h^{0,0}
                sage: x.cup_product(y) + y.cup_product(x)
                0

            This also works with cubical complexes::

                sage: T = cubical_complexes.Torus()
                sage: x,y = list(T.cohomology_with_basis(1, QQ).basis())
                sage: x.cup_product(y)
                -h^{2,0}
                sage: x.cup_product(x)
                0

            and `\Delta`-complexes::

                sage: T_d = delta_complexes.Torus()
                sage: a,b = T_d.cohomology_with_basis(1, QQ).gens()
                sage: a.cup_product(b)
                h^{2,0}
                sage: b.cup_product(a)
                -h^{2,0}
                sage: RP2 = delta_complexes.RealProjectivePlane()
                sage: w = RP2.cohomology_with_basis(1, GF(2)).gens()[0]
                sage: w.cup_product(w)
                h^{2,0}

            A non-connected example::

                sage: K = cubical_complexes.Torus().disjoint_union(cubical_complexes.Torus())
                sage: a,b,c,d = K.cohomology_with_basis(1, QQ).gens()
                sage: x,y = K.cohomology_with_basis(0, QQ).gens()
                sage: a.cup_product(x) == a
                True
                sage: a.cup_product(y)
                0
                sage: K.cohomology_ring(QQ).is_unitary() # long time
                True
            """
            scomplex = self.parent().complex()
            base_ring = self.base_ring()
            if not (scomplex == other.parent().complex()
                    and self.parent()._cohomology
                    and other.parent()._cohomology):
                raise ValueError('these are not cohomology classes from the same complex')
            deg_left = self.parent().degree()
            deg_right = other.parent().degree()
            deg_tot = deg_left + deg_right
            result = []
            for gamma in scomplex.homology_with_basis(deg_tot, base_ring).basis():
                gamma_coeff = base_ring.zero()
                for cell, coeff in gamma.to_cycle():
                    if hasattr(cell, 'alexander_whitney'):
                        # Simplicial and cubical case: each cell has a
                        # method 'alexander_whitney' which computes
                        # the appropriate faces.
                        for (c, left_cell, right_cell) in cell.alexander_whitney(deg_left):
                            left = scomplex.n_chains(deg_left, base_ring)(left_cell)
                            right = scomplex.n_chains(deg_right, base_ring)(right_cell)
                            gamma_coeff += c * coeff * self.to_cycle().eval(left) * other.to_cycle().eval(right)
                    else:
                        # Delta complex case: each "cell" in n_chains
                        # is just a pair (integer, tuple), where the
                        # integer is its index in the list, and the
                        # jth entry of the tuple is the index of its
                        # jth face in the list of (n-1)-chains. Use
                        # this data to compute the appropriate faces
                        # by hand.
                        left_cell = cell
                        for i in range(deg_tot, deg_left, -1):
                            idx = left_cell[1][i]
                            left_cell = (idx, scomplex.n_cells(i-1)[idx])
                        right_cell = cell
                        for i in range(deg_tot, deg_right, -1):
                            idx = right_cell[1][0]
                            right_cell = (idx, scomplex.n_cells(i-1)[idx])
                        left = scomplex.n_chains(deg_left, base_ring)(left_cell)
                        right = scomplex.n_chains(deg_right, base_ring)(right_cell)
                        gamma_coeff += coeff * self.to_cycle().eval(left) * other.to_cycle().eval(right)
                result.append((gamma.leading_support(), gamma_coeff))
            return scomplex.cohomology_with_basis(deg_tot, base_ring).sum_of_terms(result)

        __mul__ = cup_product

        def __pow__(self, n):
            r"""
            This element raised to the ``n``-th power

            INPUT:

            - ``n`` -- a non-negative integer

            If ``n`` is positive, this takes the iterated cup product
            of the element with itself. If ``n`` is zero, this returns
            the unit element of the cohomology ring (even if the
            complex is not connected).

            EXAMPLES::

                sage: RP2 = simplicial_complexes.RealProjectivePlane()
                sage: a = RP2.cohomology_with_basis(1, GF(2)).gens()[0]
                sage: a**0
                h^{0,0}
                sage: a**1
                h^{1,0}
                sage: a**2
                h^{2,0}
                sage: a**3
                0

                sage: a**(-2)
                Traceback (most recent call last):
                ...
                ValueError: the power must be non-negative

            A non-connected example::

                sage: K = cubical_complexes.Torus().disjoint_union(cubical_complexes.Sphere(2))
                sage: a,b = K.cohomology_with_basis(2, QQ).gens()
                sage: a**0
                h^{0,0} + h^{0,1}
            """
            if not self.parent()._cohomology:
                raise ValueError('this is not a cohomology class')
            if n < 0:
                raise ValueError('the power must be non-negative')
            if n == 0:
                scomplex = self.parent().complex()
                zeroth_cohomology = scomplex.cohomology_with_basis(0, self.base_ring())
                return sum(zeroth_cohomology.gens())
            if n == 1:
                return self
            return self.cup_product(self**(n-1))

        def Sq(self, i):
            r"""
            Return the result of applying `Sq^i` to this element.

            INPUT:

            - ``i`` -- nonnegative integer

            .. WARNING::

               This is only implemented for simplicial complexes, not
               cubical complexes.

            This cohomology operation is only defined in
            characteristic 2.

            Algorithm: see González-Díaz and Réal [G-DR99]_, Corollary
            3.2.

            EXAMPLES::

                sage: RP2 = simplicial_complexes.RealProjectiveSpace(2)
                sage: x = RP2.cohomology_with_basis(1, GF(2)).basis()[0]
                sage: x.Sq(1)
                h^{2,0}

                sage: K = RP2.suspension()
                sage: K.set_immutable()
                sage: y = K.cohomology_with_basis(2, GF(2)).basis()[0]
                sage: y.Sq(1)
                h^{3,0}

                sage: RP4 = simplicial_complexes.RealProjectiveSpace(4)
                sage: x = RP4.cohomology_with_basis(1, GF(2)).basis()[0] # long time
                sage: y = RP4.cohomology_with_basis(2, GF(2)).basis()[0] # long time
                sage: z = RP4.cohomology_with_basis(3, GF(2)).basis()[0] # long time
                sage: x.Sq(1)  # long time
                h^{2,0}
                sage: y.Sq(1)  # long time
                0
                sage: y.Sq(2)  # long time
                h^{4,0}
                sage: z.Sq(1)  # long time
                h^{4,0}

            TESTS::

                sage: T = cubical_complexes.Torus()
                sage: x = T.cohomology_with_basis(1, GF(2)).basis()[0]
                sage: x.Sq(1)
                Traceback (most recent call last):
                ...
                NotImplementedError: Steenrod squares are only implemented for simplicial complexes
                sage: S2 = simplicial_complexes.Sphere(2)
                sage: x = S2.cohomology_with_basis(2, GF(7)).basis()[0]
                sage: x.Sq(1)
                Traceback (most recent call last):
                ...
                ValueError: Steenrod squares are only defined in characteristic 2
            """
            scomplex = self.parent().complex()
            if not isinstance(scomplex, SimplicialComplex):
                raise NotImplementedError('Steenrod squares are only implemented for simplicial complexes')
            base_ring = self.base_ring()
            if base_ring.characteristic() != 2:
                raise ValueError('Steenrod squares are only defined in characteristic 2')
            # We keep the same notation as in [G-DR99].
            j = self.parent().degree()
            m = j+i
            # The trivial cases:
            if i == 0:
                # Sq^0 is the identity.
                return self
            target = scomplex.cohomology_with_basis(m, base_ring)
            if target.dimension() == 0:
                return target.zero()
            if i > j:
                return target.zero()
            if i == j:
                return self.cup_product(self)
            n = j-i
            # Now assemble the indices over which the sums take place.
            # S(n) is defined to be floor((m+1)/2) + floor(n/2).
            S_n = (m+1)//2 + n//2
            if n == 0:
                sums = [[S_n]]
            else:
                sums = []
                for i_n in range(S_n, m+1):
                    sums.extend([[i_n] + _ for _ in sum_indices(n-1, i_n, S_n)])
            # At this point, 'sums' is a list of lists of the form
            # [i_n, i_{n-1}, ..., i_0]. (It is reversed from the
            # obvious order because this is closer to the order in
            # which the face maps will be applied.)  Now we sum over
            # these, according to the formula in [G-DR99], Corollary
            # 3.2.
            result = []
            cycle = self.to_cycle()
            for gamma in scomplex.homology_with_basis(m, base_ring).basis():
                gamma_coeff = base_ring.zero()
                for cell, coeff in gamma.to_cycle():
                    for indices in sums:
                        indices = list(indices)
                        left = cell
                        right = cell
                        # Since we are working with a simplicial complex, 'cell' is a simplex.
                        if not m % 2:
                            left_endpoint = m
                            while indices:
                                right_endpoint = indices[0]-1
                                for k in range(left_endpoint, indices.pop(0), -1):
                                    left = left.face(k)
                                try:
                                    left_endpoint = indices[0]-1
                                    for k in range(right_endpoint, indices.pop(0), -1):
                                        right = right.face(k)
                                except IndexError:
                                    pass
                            for k in range(right_endpoint, -1, -1):
                                right = right.face(k)
                        else:
                            right_endpoint = m
                            while indices:
                                left_endpoint = indices[0]-1
                                try:
                                    for k in range(right_endpoint, indices.pop(0), -1):
                                        right = right.face(k)
                                    right_endpoint = indices[0]-1
                                except IndexError:
                                    pass
                                for k in range(left_endpoint, indices.pop(0), -1):
                                    left = left.face(k)
                            for k in range(right_endpoint, -1, -1):
                                right = right.face(k)

                        left = scomplex.n_chains(j, base_ring)(left)
                        right = scomplex.n_chains(j, base_ring)(right)
                        gamma_coeff += coeff * cycle.eval(left) * cycle.eval(right)
                result.append((gamma.leading_support(), gamma_coeff))
            return scomplex.cohomology_with_basis(m, base_ring).sum_of_terms(result)


def sum_indices(k, i_k_plus_one, S_k_plus_one):
    r"""
    This is a recursive function for computing the indices for the
    nested sums in González-Díaz and Réal [G-DR99]_, Corollary 3.2.

    In the paper, given indices `i_n`, `i_{n-1}`, ..., `i_{k+1}`,
    given `k`, and given `S(k+1)`, the number `S(k)` is defined to be

    .. MATH::

        S(k) = -S(k+1) + floor(k/2) + floor((k+1)/2) + i_{k+1},

    and `i_k` ranges from `S(k)` to `i_{k+1}-1`. There are two special
    cases: if `k=0`, then `i_0 = S(0)`. Also, the initial case of
    `S(k)` is `S(n)`, which is set in the method :meth:`Sq` before
    calling this function. For this function, given `k`, `i_{k+1}`,
    and `S(k+1)`, return a list consisting of the allowable possible
    indices `[i_k, i_{k-1}, ..., i_1, i_0]` given by the above
    formula.

    INPUT:

    - ``k`` -- non-negative integer
    - ``i_k_plus_one`` -- the positive integer `i_{k+1}`
    - ``S_k_plus_one`` -- the integer `S(k+1)`

    EXAMPLES::

        sage: from sage.homology.homology_vector_space_with_basis import sum_indices
        sage: sum_indices(1, 3, 3)
        [[1, 0], [2, 1]]
        sage: sum_indices(0, 4, 2)
        [[2]]
    """
    S_k = -S_k_plus_one + k//2 + (k+1)//2 + i_k_plus_one
    if k == 0:
        return [[S_k]]
    ans = []
    for i_k in range(S_k, i_k_plus_one):
        ans.extend([[i_k] + _ for _ in sum_indices(k-1, i_k, S_k)])
    return ans

