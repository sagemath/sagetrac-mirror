r"""
Group homomorphisms for ``LibGAPGroup``.

EXAMPLES::


AUTHORS:

- Simon Brandhorst (2018-02-08): initial version
"""

# ****************************************************************************
#       Copyright (C) 2018 Simon Brandhorst <sbrandhorst@web.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  http://www.gnu.org/licenses/
# ****************************************************************************
from __future__ import print_function
from sage.categories.morphism import Morphism
from sage.misc.latex import latex
from sage.structure.element import Element

class LibGAPGroupMorphism(Morphism):
    r"""
    Group morphism specified by images of generators.

    Some Python code for wrapping GAP's GroupHomomorphismByImages
    function. Can be expensive if the group is large.

    Input:

    - ``homset`` --
    - ``imgs`` --
    - ``check`` -- (default: ``True``)

    EXAMPLES::

        sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
        sage: A = AbelianGroupGap([2,4])
        sage: A.hom([g^2 for g in A.gens()])
        Homomorphism : Abelian group with gap, generator orders (2, 4)
         --> Abelian group with gap, generator orders (2, 4)
    """
    def __init__(self, homset, imgs, check=True):
        r"""
        Constructor method

        TESTS::

            sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
            sage: A = AbelianGroupGap([2,4])
            sage: f = A.hom([g^2 for g in A.gens()])
        """
        from sage.libs.gap.libgap import libgap
        Morphism.__init__(self, homset)
        dom = homset.domain()
        codom = homset.codomain()
        gens = [x.gap() for x in dom.gens()]
        imgs = [codom(x).gap() for x in imgs]
        if check:
            if not len(gens) == len(imgs):
                raise ValueError("provide an image for each generator")
            self._phi = libgap.GroupHomomorphismByImages(dom.gap(), codom.gap(), gens, imgs)
            if not self._phi.IsGroupHomomorphism():
                raise ValueError('the map {}-->{} is not a homomorphism'.format(dom.gens(), imgs))
        else:
            self._phi = libgap.GroupHomomorphismByImagesNC(dom.gap(), codom.gap(), gens, imgs)

    def _repr_type(self):
        r"""
        Part of the implementation of :meth:`_repr_`

        EXAMPLES::

        """
        return "GroupHomomorphism"

    def gap(self):
        r"""
        Return the underlying LibGAP group homomorphism

        OUTPUT:

        A LibGAP element.

        EXAMPLES::


        """
        return self._phi

    def _repr_(self):
        r"""
        EXAMPLES::


        """
        return "Homomorphism : %s --> %s"%(self.domain(),self.codomain())

    def _latex_(self):
        r"""
        EXAMPLES::

        """
        return "%s \\rightarrow{} %s"%(latex(self.domain()), latex(self.codomain()))

    def kernel(self):
        r"""
        Return the kernel of ``self``.

        EXAMPLES::

            sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
            sage: A1 = AbelianGroupGap([6,6])
            sage: A2 = AbelianGroupGap([3,3])
            sage: f = A1.hom(A2.gens())
            sage: f.kernel()
            Subgroup of Abelian group with gap, generator orders (6, 6) generated by (f1*f2, f3*f4)
            sage: f.kernel().order()
            4
        """
        dom = self.domain()
        ker_gen = [dom(g) for g in self.gap().Kernel().GeneratorsOfGroup()]
        return dom.subgroup(ker_gen)

    def pushforward(self, J, *args,**kwds):
        r"""
        The image of an element or a subgroup.

        INPUT:

        ``J`` -- a subgroup or an element of the domain of ``self``

        OUTPUT:

        The image of ``J`` under ``self``.

        .. NOTE::

            ``pushforward`` is the method that is used when a map is called
            on anything that is not an element of its domain. For historical
            reasons, we keep the alias ``image()`` for this method.

        EXAMPLES::



        """
        dom = self.domain()
        codom = self.codomain()
        phi = self.gap()
        if J in self.domain():
            return self(J)
        if not isinstance(J, ParentLibGAP):
            raise ValueError("J(=%s) must be a libgap group" %J)
        if self.gap().IsSubgroup(J.gap()).sage():
                im_gens = phi.Image(gapJ).GeneratorsOfGroup()
                im_gens = [self.codomain()(g) for g in im_gens]
                return codom.subgroup(im_gens)

    image = pushforward

    def _call_(self, g):
        """
        Call syntax for morphisms.

        Some python code for wrapping GAP's ``Images`` function.
        Returns an error if ``g`` is not in ``G``.

        EXAMPLES::

            sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
            sage: A = AbelianGroupGap([2,4])
            sage: f = A.hom([g^2 for g in A.gens()])
            sage: a = A.gens()[1]
            sage: f(a)
            f3
        """
        return self.codomain()(self.gap().Image(g.gap()))

    def lift(self, h):
        r"""
        Return an element of the tomain that maps to ``h``.

        EXAMPLES::

            sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
            sage: A = AbelianGroupGap([2,4])
            sage: f = A.hom([g^2 for g in A.gens()])
            sage: a = A.gens()[1]
            sage: f.lift(a^2)
            f2
            sage: f.lift(a)
            Traceback (most recent call last):
            ...
            ValueError: f2 is not an element of the image of Homomorphism :
             Abelian group with gap, generator orders (2, 4)
             --> Abelian group with gap, generator orders (2, 4)
        """
        if not h in self.codomain():
            raise ValueError("h (=%s) must be an element of the codomain")
        h = self.codomain()(h)
        phi = self.gap()
        if h.gap() in phi.Image():
            return self.domain()(phi.PreImagesRepresentative(h.gap()))
        else:
            raise ValueError("%s is not an element of the image of %s" %(h, self))

    def preimage(self, S):
        r"""
        Return the preimage of ``S``.

        EXAMPLES::

            sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
            sage: A = AbelianGroupGap([2,4])
            sage: f = A.hom([g^2 for g in A.gens()])
            sage: S = A.subgroup(A.gens()[1:])
            sage: f.preimage(S)
            Subgroup of Abelian group with gap, generator orders (2, 4) generated by (f1, f3, 1)
        """
        phi = self.gap()
        try:
            gapS = S.gap()
        except AttributeError:
            pass
        if isinstance(S, list) and all([s in self.codomain() for s in S]):
            gapS = [self.codomain()(s).gap() for s in S]
        if self.codomain().gap().IsSubgroup(S.gap()).sage():
            gens = phi.PreImage(gapS).GeneratorsOfGroup()
            return self.codomain().subgroup(gens)

