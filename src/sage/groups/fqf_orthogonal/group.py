r"""
Orthogonal groups of torsion quadratic forms.

<Paragraph description>

EXAMPLES::

<Lots and lots of examples>

AUTHORS:

- Simon Brandhorst (2018-05-15): initial version
"""

# ****************************************************************************
#       Copyright (C) 2018 Simon Brandhorst <sbrandhorst@web.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.groups.abelian_gps.abelian_aut import AbelianGroupAutomorphismGroup_subgroup, AbelianGroupAutomorphism, AbelianGroupAutomorphismGroup_gap
from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
from sage.misc.cachefunc import cached_method
from sage.modules.torsion_quadratic_module import TorsionQuadraticModule
from sage.rings.all import mod, ZZ, IntegerModRing, Zp, QQ
from sage.matrix.all import matrix
from sage.categories.action import Action

class FqfIsometry(AbelianGroupAutomorphism):
    r"""
    Isometry of a finite quadratic/bilinear form.

    INPUT:

    - ``parent`` -- the parent :class:`~FqfOrthogonalGroup`
    - ``x`` -- a libgap element
    - ``check`` -- bool (default: ``True``)

    EXAMPLES::

        sage:
        sage:
    """

    def _repr_(self):
        r"""
        Return the string represenation of ``self``.

        EXAMPLES::

            sage: q = matrix.diagonal([2/3,4/3])
            sage: q = TorsionQuadraticForm(q)
            sage: G = q.orthogonal_group()
            sage: g = G.gens()[0]
            sage: g
            [2 0]
            [0 2]
        """
        return str(self.matrix())

    def __call__(self, x):
        r"""
        Return the image of ``x`` under ``self``.

        EXAMPLES::

            sage: q = matrix.diagonal([2/3,4/3])
            sage: q = TorsionQuadraticForm(q)
            sage: G = q.orthogonal_group()
            sage: g = G.gens()[0]
            sage: g
            [2 0]
            [0 2]
            sage: x = q.gens()[0]
            sage: g(x)
            (2, 0)
        """
        if x in self.parent().invariant_form():
            return x*self
        else:
            return AbelianGroupAutomorphism.__call__(self, x)

    def _gap_init(self):
        r"""
        """
        s = self.gap().__repr__()
        s = s.replace("->", ",")
        s = "GroupHomomorphismByImages(A, A, " + s + ")"
        return s

class FqfOrthogonalGroup(AbelianGroupAutomorphismGroup_subgroup):
    r"""
    Return the orthogonal group of this torsion quadratic form.

    Do not call this class directly instead use
    :meth:`sage.modules.torsion_quadratic_module.orthogonal_group`.

    INPUT:

        - ``T`` a non degenerate torsion quadratic module.

    EXAMPLES::

        sage: q = matrix.diagonal(QQ, [2/3, 2/3, 4/3])
        sage: T = TorsionQuadraticForm(q)
        sage: T
        Finite quadratic module over Integer Ring with invariants (3, 3, 3)
        Gram matrix of the quadratic form with values in Q/2Z:
        [4/3   0   0]
        [  0 2/3   0]
        [  0   0 2/3]
        sage: T.orthogonal_group()
        Group of isometries of
        Finite quadratic module over Integer Ring with invariants (3, 3, 3)
        Gram matrix of the quadratic form with values in Q/2Z:
        [4/3   0   0]
        [  0 2/3   0]
        [  0   0 2/3]
        generated by 2 elements
        sage: q = matrix(QQ, 3, 3, [3/2, 0, 0, 0, 1/4, 0, 0, 0 , 1/4])
        sage: T = TorsionQuadraticForm(q)
        sage: T
        Finite quadratic module over Integer Ring with invariants (2, 4, 4)
        Gram matrix of the quadratic form with values in Q/2Z:
        [3/2   0   0]
        [  0 1/4   0]
        [  0   0 1/4]
        sage: T.orthogonal_group().order()
        8

    Action on an invariant subquotient::

        sage: T = TorsionQuadraticForm(matrix.diagonal([2/3]*3+ [2/9]+ [2/27]))
        sage: S1 = 3 * T
        sage: S2 = 9 * T
        sage: Q = S1/S2
        sage: G = T.orthogonal_group()
        sage: Q.0*G.4
        (2, 0)
    """
    Element = FqfIsometry

    def __init__(self, ambient, gens, fqf, check=False):
        r"""
        """
        # We act on the smith form generators
        # because they are independent
        if not isinstance(fqf, TorsionQuadraticModule):
            raise TypeError("input must be a torsion quadratic module")
        if not isinstance(ambient, AbelianGroupAutomorphismGroup_gap):
            raise TypeError("input must be a torsion quadratic module")
        if not fqf.invariants() == ambient.domain().gens_orders():
            raise ValueError("invariants of the abelian group do not match")
        gens = [ambient(g) for g in gens]
        self._invariant_form = fqf
        AbelianGroupAutomorphismGroup_subgroup.__init__(self, ambient, gens,check=check)
        if check:
            for g in self.gens():
                if not self._preserves_form(g):
                    raise ValueError("%s does not preserve the quadratic form"%g)

    def invariant_form(self):
        r"""
        """
        return self._invariant_form

    def _gap_init(self):
        r"""
        """
        invs = self.domain().gap().AbelianInvariants().__repr__()
        s = "A:=AbelianGroup(" + invs + ");\n"
        pcgs = self.domain().gap().Pcgs()
        s += "f:=Pcgs(A);"
        for n in range(1,len(pcgs)+1):
            s += "f%s:=f[%s];"%(n,n)
        s += "\n"
        s += "aut:= AutomorphismGroup(A);\n"
        s += "G:=Subgroup(aut, ["
        for g in self.gens():
            s += g._gap_init() + ",\n"
        s = s[:-1]
        s += "]);"
        return s

    def _element_constructor_(self, x, check=False):
        r"""
        Construct an element from ``x`` and handle conversions.

        INPUT:

        - ``x`` -- something that converts it can be:

          * a libgap element
          * an integer matrix in the covering matrix ring
          * a class:`sage.modules.fg_pid.fgp_morphism.FGP_Morphism`
            defining an automorphism -- the domain of ``x`` must have
            invariants equal to ``self.domain().gens_orders()``
            if x in self.invariant_form().W().orthogonal_group()
          * something that acts on the invariant form module

        EXAMPLES::

            sage: L = IntegralLattice("A4").twist(2).direct_sum(IntegralLattice("A2"))
            sage: D = L.discriminant_group()
            sage: OL = L.orthogonal_group()
            sage: OD = D.orthogonal_group()
            sage: f = OL.an_element()
            sage: fbar = OD(f)
            sage: fbar
            [ 0  0  0 15]
            [ 1  1  0  0]
            [ 1  0  0  0]
            [ 1  0  1  1]

        TESTS::

            sage: all([x*f==x*fbar for x in D.gens()])
            True

        Check that conversion of subgroup elements
        works properly::

            sage: t = TorsionQuadraticForm(matrix([1/4]))
            sage: og = t.orthogonal_group()
            sage: s = og.subgroup([])
            sage: og.gen(0) in s
            False

        """
        # the super class knows what to do
        from sage.libs.gap.element import GapElement
        if not type(x) is GapElement:
            try:
                q = self.invariant_form()
                W = q.W()
                if (not len(q.invariants()) == W.degree() and
                    x.ncols() == W.degree()):
                    x = W.orthogonal_group([x]).gen(0)
                    check = True
            except AttributeError:
                pass
            try:
                # if there is an action try that
                gen = self.invariant_form().smith_form_gens()
                x = matrix(ZZ, [(g*x).vector() for g in gen])
            except TypeError:
                pass
        f = AbelianGroupAutomorphismGroup_subgroup._element_constructor_(self, x, check=True)
        if check:
            # double check that the form is preserved
            # this is expensive
            if not self._preserves_form(f):
                raise ValueError("not an isometry")
        return f

    def _preserves_form(self, f):
        r"""
        Return if f preserves the form.

        INPUT:

        Something that acts on the domain.
        """
        g = self.invariant_form().smith_form_gens()
        for i in range(len(g)):
            if (g[i]*f).q() != g[i].q():
                return False
            for j in range(i+1, len(g)):
                if (g[i]*f).b(g[j]*f) != (g[i]*f).b(g[j]*f):
                    return False
        return True

    def _get_action_(self, S, op, self_on_left):
        r"""
        Provide the coercion system with an action.

        EXAMPLES::

            sage: q = matrix.diagonal([2/3,4/3])
            sage: q = TorsionQuadraticForm(q)
            sage: G = q.orthogonal_group()
            sage: G._get_action_(q, operator.mul, False)
            Right action by Group of isometries of
            Finite quadratic module over Integer Ring with invariants (3, 3)
            Gram matrix of the quadratic form with values in Q/2Z:
            [4/3   0]
            [  0 2/3]
            generated by 2 elements on Finite quadratic module over Integer Ring with invariants (3, 3)
            Gram matrix of the quadratic form with values in Q/2Z:
            [4/3   0]
            [  0 2/3]
        """
        import operator
        if op == operator.mul and not self_on_left:
            T = self.invariant_form()
            if S == T:
                return ActionOnFqf(self, S)
            try:
                if S.is_submodule(T):
                    # check if the submodule is invariant
                    if all([T(s)*g in S for s in S.gens() for g in self.gens()]):
                        return ActionOnFqf(self, S, on_subquotient=True)
                elif S.V().is_submodule(T.V()) and T.W().is_submodule(S.W()):   # is a subquotient
                    Q1 = S.V()/T.W()
                    Q2 = S.W()/T.W()
                    if (
                        all([T(q)*g in Q1 for q in Q1.gens() for g in self.gens()]) and
                        all([T(q)*g in Q2 for q in Q2.gens() for g in self.gens()])
                    ):
                        return ActionOnFqf(self, S, on_subquotient=True)
            except AttributeError:
                pass
            try:
                return AbelianGroupAutomorphismGroup_subgroup._get_action_(self, S, op, self_on_left)
            except AttributeError:
                pass

    def _subgroup_constructor(self, libgap_subgroup):
        r"""
        Create a subgroup from the input.

        See :class:`~sage.groups.libgap_wrapper`. Override this in derived
        classes.

        EXAMPLES::

            sage: q = TorsionQuadraticForm(matrix.diagonal([2/3,2/3]))
            sage: G = q.orthogonal_group()
            sage: G.subgroup(G.gens()[:1])
            Group of isometries of
            Finite quadratic module over Integer Ring with invariants (3, 3)
            Gram matrix of the quadratic form with values in Q/2Z:
            [2/3   0]
            [  0 2/3]
            generated by 1 elements
        """
        generators = libgap_subgroup.GeneratorsOfGroup()
        generators = tuple(self(g, False) for g in generators)
        return FqfOrthogonalGroup(self, generators, self.invariant_form())

    def _repr_(self):
        r"""
        The string represenation of ``self``.

        EXAMPLES::

            sage: q = TorsionQuadraticForm(matrix.diagonal([2/3,2/3]))
            sage: q.orthogonal_group()
            Group of isometries of
            Finite quadratic module over Integer Ring with invariants (3, 3)
            Gram matrix of the quadratic form with values in Q/2Z:
            [2/3   0]
            [  0 2/3]
            generated by 2 elements
        """
        return "Group of isometries of \n%s\ngenerated by %s elements"%(self.invariant_form(), len(self.gens()))


class ActionOnFqf(Action):
    r"""
    Action on a finite quadratic module.

    INPUT:

    - ``orthogonal_grp`` --  an instance of :class:`GroupOfIsometries`
    - ``fqf`` -- a torsion quadratic module
    - ``on_subquotient`` -- bool (default: ``False``)
    - ``is_left`` -- bool (default: ``False``)

    EXAMPLES::

        sage: q = matrix.diagonal([2/3,4/3])
        sage: q = TorsionQuadraticForm(q)
        sage: G = q.orthogonal_group()
        sage: g = G.gens()[0]
        sage: g
        [2 0]
        [0 2]
        sage: x = q.gens()[0]
        sage: x*g
        (2, 0)
    """
    def __init__(self, orthogonal_grp, fqf, on_subquotient=False, is_left=False):
        r"""
        Initialize the action

        TESTS::

            sage: from sage.groups.fqf_orthogonal.group import ActionOnFqf
            sage: q = matrix.diagonal([2/3, 4/3])
            sage: q = TorsionQuadraticForm(q)
            sage: G = q.orthogonal_group()
            sage: A = ActionOnFqf(G, q, is_left=True)
            Traceback (most recent call last):
            ...
            ValueError: the action is from the right
        """
        import operator
        self._on_subquotient = on_subquotient
        if is_left:
            raise ValueError("the action is from the right")
        Action.__init__(self, orthogonal_grp, fqf, is_left, operator.mul)

    def _act_(self, g, a):
        r"""
        This defines the group action.

        INPUT:

        - ``a`` -- an element of the invariant submodule
        - ``g`` -- an element of the acting group

        OUTPUT:

        - an element of the invariant submodule

        EXAMPLES::

            sage: from sage.groups.fqf_orthogonal.group import ActionOnFqf
            sage: q = matrix.diagonal([2/3, 4/3])
            sage: q = TorsionQuadraticForm(q)
            sage: G = q.orthogonal_group()
            sage: g = G.gens()[0]
            sage: A = ActionOnFqf(G, q)
            sage: A
            Right action by Group of isometries of
            Finite quadratic module over Integer Ring with invariants (3, 3)
            Gram matrix of the quadratic form with values in Q/2Z:
            [4/3   0]
            [  0 2/3]
            generated by 2 elements on Finite quadratic module over Integer Ring with invariants (3, 3)
            Gram matrix of the quadratic form with values in Q/2Z:
            [4/3   0]
            [  0 2/3]
            sage: x = q.an_element()
            sage: g = G.an_element()
            sage: A(x,g).parent()
            Finite quadratic module over Integer Ring with invariants (3, 3)
            Gram matrix of the quadratic form with values in Q/2Z:
            [4/3   0]
            [  0 2/3]
            sage: q = TorsionQuadraticForm(matrix.diagonal([2/3,2/3,6/8,1/4]))
            sage: G = q.orthogonal_group()
            sage: q2 = q.primary_part(2)
            sage: q2.gen(0)*G.gen(0)
            (3, 0)
        """
        if self.is_left():
            pass
            # this would be a left action but... we do not allow it.
            # v = (a.vector()*g.matrix().inverse())
            # P = a.parent()
            # return P.linear_combination_of_smith_form_gens(v)
        elif self._on_subquotient:
            S = a.parent()
            T = g.parent().invariant_form()
            return S(T(a)*g)
        else:
            v = (a.vector()*g.matrix())
            P = a.parent()
            return P.linear_combination_of_smith_form_gens(v)


def _isom_fqf(A, B=None):
    r"""
    Return isometries from `A` to `B`.

    INPUT:

    - ``A`` -- a torsion quadratic module
    - ``B`` -- (default: ``None``) a torsion quadratic module

    OUTPUT:

    A list of generators of the orthogonal group of A.
    If ``B`` is given returns instead an isometry of `A` and `B` or
    raises an ``ValueError`` if `A` and `B` are not isometric.
    """
    if B is None:
        B = A
        automorphisms = True
    else:
        automorphisms = False
    if A.invariants() != B.invariants():
        raise ValueError()
    na = len(A.smith_form_gens())
    nb = len(B.smith_form_gens())

    b_cand = [[b for b in B if b.q()==a.q() and b.order() == a.order()] for a in A.smith_form_gens()]

    res = []
    G = B.orthogonal_group(tuple(res))
    ambient = G.ambient()
    waiting = [[]]
    while len(waiting) > 0:
        f = waiting.pop()
        i = len(f)
        if i == na:
            if not automorphisms:
                return f
            g = ambient(matrix(f))
            if not g in G:
                res.append(tuple(f))
                G = B.orthogonal_group(tuple(ambient(s.matrix()) for s in G.gens())+(g,))
                waiting = _orbits(G, waiting)
            continue
        a = A.smith_form_gens()[i]
        card = ZZ.prod(A.smith_form_gen(k).order() for k in range(i+1))
        for b in b_cand[i]:
            if all(b.b(f[k])==a.b(A.smith_form_gens()[k]) for k in range(i)):
                fnew = f + [b]
                # check that the elements of fnew are independent
                if B.submodule(fnew).cardinality() == card:
                    waiting.append(fnew)


    if len(res) == 0:
        raise ValueError()
    return res

def _orbits(G, L):
    r"""
    Return the orbits of `L` under `G`.

    INPUT:

    - ``G`` -- a torsion orthogonal group
    - ``L`` -- a list of tuples of elements of the domain of ``G``

    EXAMPLES::

        sage:
        sage:
    """
    D = G.invariant_form()
    A = G.domain()
    L = libgap([[A(g).gap() for g in f] for f in L])
    orb = G.gap().Orbits(L,libgap.OnTuples)
    orb = [g[0] for g in orb]
    orb = [[D.linear_combination_of_smith_form_gens(A(g).exponents()) for g in f] for f in orb]
    return orb
