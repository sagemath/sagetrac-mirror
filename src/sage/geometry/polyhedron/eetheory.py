def phi_function(polytope, acting_group=None, output=None):
    r"""
    Return `\phi` as a rational function in `t` with coefficients in
    the ring of class functions of the ``acting_group`'
    of ``polytope``.

    Here, `\phi = \sum\_{m} \chi\_{m*\text{``polytope``}}*t^m * det(\rho)`.
    The irreducible characters of ``acting_group`` form an orthonormal basis
    for the ring (algebra) of class functions with values in `\mathbb C`.
    The coefficients of `\phi` are expressed in this basis.

    INPUT:

    - ``polytope`` -- polyhedron object. A full dimensional lattice polytope
      with backend='normaliz'.

    - ``acting_group`` -- (default: ``None``) a permgroup object. A subgroup of
      `polytope`'s `restricted_automorphism_group` output as a permutation.
       If ``None``, it is set to the full `restricted_automorphism_group`
       of `polytope`.

    - ``output`` -- string. an output option. The allowed values are:

        * ``None`` (default): returns the rational function `\phi`. `\phi` is a
          rational function in `t` with coefficients in the ring of
          class functions.
        * ``'e_series_list'``: string. Returns a vector of the ehrhart_series
          for the fixed_subpolytopes of each conjugacy class representative.
        * ``'determinant_vec'``: string. Returns a vector of the determinants
          of `Id-\rho*t` for each conjugacy class representative.
        * ``'phi_as_lin_comb'``: string. Returns a vector of the coefficients
          of the irreducible representations in the expression of `\phi`.
        * ``'prod_det_es'``: string. Returns a vector of the product of
          determinants and the Ehrhart series.

    OUTPUT:

    The default output is the rational function `\phi`. `\phi` is a rational
    function in `t` with coefficients in the ring of class functions.
    There are several output options to see the intermediary outputs of the
    function for the purpose of debugging.


    EXAMPLES:

    The `\phi` polynomial of the standard `d-1` dimensional simplex
    `S = conv(e_1, \dots, e_d)` under its ``restricted_automorphism_group``
    is equal to 1 = `1 \cdot \chi_{trivial}` (Prop 6.1, Equivariant Ehrharhart
    Theory, Stapledon). Here is the computation in Sage for the 3-dimensional
    simplex::

        sage: S = polytopes.simplex(3,backend='normaliz')
        sage: S
        A 3-dimensional polyhedron in ZZ^4 defined as the convex hull of 4 vertices
        sage: G = S.restricted_automorphism_group(output='permutation')
        sage: G
        Permutation Group with generators [(2,3), (1,2), (0,1)]
        sage: len(G)
        24
        sage: phi = phi_function(S,G)
        sage: phi
        chi_4
        sage: G.character_table()
        [ 1 -1  1  1 -1]
        [ 3 -1  0 -1  1]
        [ 2  0 -1  2  0]
        [ 3  1  0 -1 -1]
        [ 1  1  1  1  1]

    The next example is 7.6 in Equivariant Ehrhart Theory by Stapledon.
    It shows that `\phi` is not always a polynomial. Let P be the polytope
    with vertices `\pm(0,0,1),\pm(1,0,1),\pm(1,1,1)` and let
    H = `\mathbb Z / 2\mathbb Z` act on P as follows::

        sage: P = Polyhedron(vertices=[[0,0,1],[0,0,-1],[1,0,1],[-1,0,-1],[0,1,1],
        ....: [0,-1,-1],[1,1,1],[-1,-1,-1]],backend='normaliz')
        sage: G = P.restricted_automorphism_group(output='permutation')
        sage: H = G.subgroup(gens = [G[6]])
        sage: H
        Subgroup generated by [(0,2)(1,3)(4,6)(5,7)] of (Permutation Group with generators [(2,4)(3,5), (1,2)(5,6), (0,1)(2,3)(4,5)(6,7), (0,7)(1,3)(2,5)(4,6)])
        sage: conj_reps = H.conjugacy_classes_representatives()
        sage: Dict = match_perms_to_mats(P,conj_reps, acting_group=H)
        sage: Dict[G[6]]
        [-1  0  1  0]
        [ 0  1  0  0]
        [ 0  0  1  0]
        [ 0  0  0  1]
        sage: len(H)
        2
        sage: H.character_table()
        [ 1  1]
        [ 1 -1]

    Then we calculate the rational function `\phi`::

        sage: phi = phi_function(P,H)
        sage: phi
        (chi_0*t^4 + (3*chi_0 + 3*chi_1)*t^3 + (8*chi_0 + 2*chi_1)*t^2 + (3*chi_0 + 3*chi_1)*t + chi_0)/(t + 1)

    To see the exact output that Stapledon has in his example, we can format the output
    with the ``'phi_as_lin_comb'`` option. The first coordinate is the coefficient of
    the trivial character and the second is the coefficient of the sign character::

        sage: phi_as_linear_combination = phi_function(P,H,output = 'phi_as_lin_comb')
        sage: phi_as_linear_combination
        ((t^4 + 3*t^3 + 8*t^2 + 3*t + 1)/(t + 1), (3*t^3 + 2*t^2 + 3*t)/(t + 1))

    """
    # Setting the group
    G_perm = polytope.restricted_automorphism_group(output='permutation')

    if acting_group is not None:
        if not acting_group.is_subgroup(G_perm):
            raise TypeError("The 'acting_group' should be a subgroup of the 'restricted_automorphism_group'.")
        G_perm = acting_group

    # Fixing the conjugacy classes representatives once and for all
    conj_reps = G_perm.conjugacy_classes_representatives()
    group_dict = match_perms_to_mats(polytope, conj_reps, acting_group=G_perm)
    fix_polys = fixed_subpolytopes(polytope, conj_reps)
    list_es = [fix_polys[g].ehrhart_series() for g in conj_reps]

    # get the list of the denominators det([Id - rho (t)])
    Ring = PolynomialRing(QQbar, 't')
    det_vector = list()
    dim = group_dict[G_perm.gens()[0]].dimensions()[0]
    t = Ring.gens()[0]
    ts_matrix = t * identity_matrix(Ring, dim)
    identity = identity_matrix(Ring, dim)

    # create a flag to fix the determinant if polytope isn't full dimensional
    flag = False
    if not polytope.is_full_dimensional():
        flag = True
        codim = polytope.ambient_dim() - polytope.dim()

    for perm in conj_reps:
        mat = group_dict[perm]
        mat = mat.change_ring(Ring)
        new_matrix = identity - mat*ts_matrix
        if flag:
            det = (1-t)**-codim*(new_matrix.determinant())
        else:
            det = new_matrix.determinant()
        det_vector.append(det)

    FF = Ring.fraction_field()
    initial_result = vector(FF, [a*b for a, b in zip(det_vector, list_es)])
    Char = G_perm.character_table().change_ring(FF)
    new_result = Char.solve_left(initial_result)

    new_new_result = _express_phi_as_polynomial_in_t(new_result)
    if output is None:
        return(new_new_result)
    elif output is 'e_series_list':
        return(list_es)
    elif output is 'determinant_vec':
        return(det_vector)
    elif output is 'phi_as_lin_comb':
        return(new_result)
    elif output is 'prod_det_es':
        return(initial_result)


def fixed_subpolytope(polytope, vertex_permutation):
    r"""
    Return the fixed subpolytope of ``polytope`` by the cyclic action of
    ``vertex_permutation``.

    INPUT:

    - ``polytope`` -- polyhedron object; a compact lattice polytope

    - ``vertex_permutation`` -- permutation; a permutation of the vertices of
      ``polytope``.

    OUTPUT:

    A subpolytope of ``polytope``.

    .. NOTE::

        The vertex_permutation is obtained as a permutation of the vertices
        represented as a permutation. For example, vertex_permutation =
        polytope.restricted_automorphism_group(output='permutation').

        Requiring a lattice polytope as opposed to a rational polytope as
        input is purely conventional.

    EXAMPLES:

    The fixed subpolytopes of the cube can be obtained as follows::

        sage: Cube = polytopes.cube(backend = 'normaliz')
        sage: AG = Cube.restricted_automorphism_group(output='permutation')
        sage: reprs = AG.conjugacy_classes_representatives()

    The fixed subpolytope of the identity element of the group is the entire
    cube::
        sage: reprs[0]
        ()
        sage: fixed_subpolytope(Cube,reprs[0])
        A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 8
        vertices
        sage: _.vertices()
        (A vertex at (-1, -1, -1),
         A vertex at (-1, -1, 1),
         A vertex at (-1, 1, -1),
         A vertex at (-1, 1, 1),
         A vertex at (1, -1, -1),
         A vertex at (1, -1, 1),
         A vertex at (1, 1, -1),
         A vertex at (1, 1, 1))

    You can obtain non-trivial examples::

        sage: fsp1 = fixed_subpolytope(Cube,reprs[8]);fsp1
        A 0-dimensional polyhedron in QQ^3 defined as the convex hull of 1 vertex
        sage: fsp1.vertices()
        (A vertex at (0, 0, 0),)
        sage: fsp2 = fixed_subpolytope(Cube,reprs[3]);fsp2
        A 2-dimensional polyhedron in QQ^3 defined as the convex hull of 4 vertices
        sage: fsp2.vertices()
        (A vertex at (-1, -1, 0),
        A vertex at (-1, 1, 0),
        A vertex at (1, -1, 0),
        A vertex at (1, 1, 0))

    The next example shows that fixed_subpolytope still works for rational polytopes::

       sage: P = Polyhedron(vertices = [[0,0],[3/2,0],[3/2,3/2],[0,3/2]],backend='normaliz')
       sage: P.vertices()
       (A vertex at (0, 0),
        A vertex at (0, 3/2),
        A vertex at (3/2, 0),
        A vertex at (3/2, 3/2))
       sage: G = P.restricted_automorphism_group(output='permutation')
       sage: G
       Permutation Group with generators [(1,2), (0,1)(2,3), (0,3)]
       sage: len(G)
       8
       sage: G[2]
       (0,1)(2,3)
       sage: fixed_set = fixed_subpolytope(P,G[2])
       sage: fixed_set
       A 1-dimensional polyhedron in QQ^2 defined as the convex hull of 2 vertices
       sage: fixed_set.vertices()
       (A vertex at (0, 3/4), A vertex at (3/2, 3/4))

    """

    orbits = Set([Set(i) for i in vertex_permutation.cycle_tuples(singletons=True)])

    # If its the identity, returns the polytope
    if not orbits:
        return polytope

    # Make an index shift flag
    shift = True
    if 0 in vertex_permutation.domain():
        shift = False

    vertices = []
    for orbit in orbits:
        size = len(orbit)
        if shift:
            # in this case, the indices in the orbit are 1 more than the index in the V
            s = sum([(polytope.Vrepresentation()[i-1]).vector() for i in orbit])
        else:
            s = sum([(polytope.Vrepresentation()[i]).vector() for i in orbit])
        orbit_barycenter = (1/QQ(size)) * s
        vertices += [orbit_barycenter]

    return Polyhedron(vertices=vertices, backend='normaliz')


def fixed_subpolytopes(polytope, conj_class_reps):
    r"""
    Return the fixed subpolytope of an element in each conjugacy class of a
    subgroup of the automorphism group of ``polytope``.

    INPUT:

    - ``polytope`` -- polyhedron object. a lattice polytope.

    - ``conj_class_reps`` -- a list of representatives of the conjugacy classes
      of the subgroup of the restricted automorphism group of the polytope.
      Each element is written as a permutation of the vertices
      of the polytope.

    OUTPUT:

    A dictionary giving with conj_class_reps as keys and the fixed subpolytopes
    as values.

    NOTE:

    Two elements in the same conjugacy class fix lattice-isomorphic
    subpolytopes.

    EXAMPLES:

    Here is an example for the square::

        sage: p = polytopes.hypercube(2,backend='normaliz')
        sage: p
        A 2-dimensional polyhedron in ZZ^2 defined as the convex hull of 4 vertices
        sage: aut_p = p.restricted_automorphism_group(output='permutation')
        sage: aut_p.order()
        8
        sage: conj_list = aut_p.conjugacy_classes_representatives()
        sage: conj_list
        [(), (1,2), (0,1)(2,3), (0,1,3,2), (0,3)(1,2)]
        sage: fixed_subpolytopes(p,conj_list)
        {(): A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 4 vertices,
        (1,2): A 1-dimensional polyhedron in QQ^2 defined as the convex hull of 2 vertices,
        (0,1)(2,3): A 1-dimensional polyhedron in QQ^2 defined as the convex hull of 2 vertices,
        (0,1,3,2): A 0-dimensional polyhedron in QQ^2 defined as the convex hull of 1 vertex,
        (0,3)(1,2): A 0-dimensional polyhedron in QQ^2 defined as the convex hull of 1 vertex}

    TO DO

    TESTS:


    """
    fixed_subpolytopes = {}

    for element in conj_class_reps:
        fixed_subpoly = fixed_subpolytope(polytope, element)
        fixed_subpolytopes[element] = fixed_subpoly
    return fixed_subpolytopes


def _express_phi_as_polynomial_in_t(initial_phi):
    r"""
    Rewrite the vector representing `\phi` as a linear combination of the irreducible
    representations as a rational function in `t`.

    The function `\phi` is first calculated as a linear combination of the irreducible
    representations of ``polytope.restricted_automorphism_group``. The convention is
    to express `\phi` as a rational function in `t` with coefficients in the ring of
    class functions.

    INPUT:

    - ``result`` -- a vector of rational functions in `t`.

    OUTPUT:

    A rational function in `t` with coefficients in the class ring of
    ``polytope.restricted_automorphism_group()``.

    TO DO:

    Redo the examples now that the code is different.

    EXAMPLES:

    The expression of `\phi` as a polynomial in `t` for a 3-dimensional simplex
    is computed as follows::

    sage: simplex = Polyhedron(vertices=[[0,0,0],[1,0,0],[0,1,0],[0,0,1]],backend='normaliz')
    sage: phi = phi_function(simplex)
    sage: phi
    chi_4

    The polynomial is `\chi_4*1`.We can see which irreducible representation `\chi_4` corresponds
    to by looking at the character table::

    sage: G = simplex.restricted_automorphism_group(output='matrix')
    sage: char = G.character_table()
    sage: char
    [ 1 -1 -1  1  1]
    [ 3  1 -1  0 -1]
    [ 2  0  0 -1  2]
    [ 3 -1  1  0 -1]
    [ 1  1  1  1  1]

    Thus `\chi_4` corresponds to the trivial representation of the group, and for every group
    element in the group evaluates to 1.

    As another example, we can look at `\phi` for the `\pm`1 square::

    sage: square = Polyhedron(vertices = [[1,1,],[-1,1],[-1,-1],[1,-1]],backend ='normaliz')
    sage: phi = phi_function(square)
    sage: phi
    chi_0*t^2 + (2*chi_0 + chi_2 + chi_3 + chi_4)*t + chi_0

    Plugging in the values from the first column of the character table yields the `h^*`
    polynomial of the square, `t^1+6t+1`::

    sage: G = square.restricted_automorphism_group(output='matrix')
    sage: G.character_table()
    [ 1  1  1  1  1]
    [ 1 -1 -1  1  1]
    [ 1  1 -1 -1  1]
    [ 1 -1  1 -1  1]
    [ 2  0  0  0 -2]

    """

    chi_vars = var(','.join('chi_{}'.format(i) for i in range(len(initial_phi))))
    Chi_ring = PolynomialRing(QQbar, chi_vars)
    virtual_ring = PolynomialRing(Chi_ring, initial_phi.base_ring().gens())
    fraction_virtual_ring = virtual_ring.fraction_field()
    new_result = initial_phi.change_ring(fraction_virtual_ring)*vector(fraction_virtual_ring, chi_vars)
    return new_result


def eval_chi(polytope, col_numb, acting_group=None):
    r"""
    Returns the evaluation of `\phi` for the ``restricted_automorphism_group``
    of ``polytope`` at a given conjugacy class.

    `\Phi` is a polynomial in `t` over the ring of class functions of ``polytope``'s
    ``restricted_automorphism_group``. This function evaluates the coefficients of `t`
    at a certain conjugacy class and returns a polynomial in `t` with
    coefficients in `\mathbb Z`.

    INPUT:

    - ``polytope`` -- polyhedron object. A full lattice polytope.

    - ``col_numb`` -- integer. The column index of the character table at
      which to evaluate `\phi`.

    - ``acting_group`` -- (default: ``None``) an acting group. A subgroup of
      ``polytope``'s `restricted_automorphism_group` output as a permutation.
      If ``None``, it is set to the full ``restricted_automorphism_group``
      of ``polytope``.

    OUTPUT:

    A rational function in `t` with coefficients in `\mathbb{Z}`.

    EXAMPLES:


    """
    # get phi
    final_phi = phi_function(polytope, acting_group)

    # set the group
    if acting_group is not None:
        G = acting_group
    else:
        G = polytope.restricted_automorphism_group(output='permutation')

    char_table = G.character_table()

    chi_vars = var(','.join('chi_{}'.format(i) for i in range(char_table.dimensions()[0])))
    my_dict = {}
    column = iter(char_table.column(col_numb))
    for v in chi_vars:
        my_dict[v] = column.next()
    my_vect = [my_dict[v] for v in chi_vars]
    evaluation_res = sum([c(my_vect)*m for c, m in zip(final_phi.numerator().coefficients(), final_phi.numerator().monomials())])/final_phi.denominator()
    return evaluation_res.factor()


def match_perms_to_mats(polytope, conj_class_reps, acting_group=None, additional_elts=None):
    r"""
    An element of the ``polytope``'s ``restricted_autormorphism_group`` may
    be represented either as a permutation of the vertices of ``polytope``
    or as a matrix. This function returns a dictionary with permutations
    as keys and matrices as values.

    When ``additional_elts`` =``None``, the dictionary is returned for the
    generators and conjugacy classes representatives in conj_class_reps of the
    ``restricted_automorphism_group`` or the ``acting_group``.
    When ``additional_elts`` is not ``None``, each element in
    ``additional_elts`` also becomes a key.

    INPUT:

    - ``polytope`` -- polyhedron object. a lattice polytope.

    - ``conj_class_reps`` -- list. a list of the conjugacy classes
      representatives of the acting group.

    - ``acting_group`` -- a subgroup of the ``polytope``'s
      ``restricted_automorphism_group``.

    - ``additional_elts`` -- (default: ``None``) a subset of the
      ``restricted_automorphism_group`` of ``polytope`` expressed as
      permutations.

    OUTPUT:

    A dictionary between elements of ``the restricted_automorphism_group`` or
    ``acting_group`` expressed as permutations (keys) and matrices (values).

    EXAMPLES:

    This example shows the dictionary between permutations and matrices
    for the generators of the ``restricted_automorphism_group`` of the
    `\pm` 2-dimensional square::

        sage: square = Polyhedron(vertices=[[1,1],[-1,1],[-1,-1],[1,-1]],backend='normaliz')
        sage: aut_square = square.restricted_automorphism_group(output='permutation')
        sage: conj = aut_square.conjugacy_classes_representatives()
        sage: gens_dict = match_perms_to_mats(square,conj)
        sage: gens_dict
        {(): [1 0 0]
        [0 1 0]
        [0 0 1],
        (1,2): [0 1 0]
        [1 0 0]
        [0 0 1],
        (0,1)(2,3): [ 1  0  0]
        [ 0 -1  0]
        [ 0  0  1],
        (0,1,3,2): [ 0  1  0]
        [-1  0  0]
        [ 0  0  1],
        (0,3): [ 0 -1  0]
        [-1  0  0]
        [ 0  0  1],
        (0,3)(1,2): [-1  0  0]
        [ 0 -1  0]
        [ 0  0  1]}
        sage: square.vertices()
        (A vertex at (-1, -1),
        A vertex at (-1, 1),
        A vertex at (1, -1),
        A vertex at (1, 1))

    This example tests the functionality for extra elements::

        sage: C = polytopes.cross_polytope(2)
        sage: G = C.restricted_automorphism_group(output = 'permutation')
        sage: conj = G.conjugacy_classes_representatives()
        sage: add_elt = [G[4]]
        sage: match_perms_to_mats(C, conj, additional_elts = add_elt)
        {(): [1 0 0]
         [0 1 0]
         [0 0 1], (1,2): [ 1  0  0]
         [ 0 -1  0]
         [ 0  0  1], (0,1)(2,3): [0 1 0]
         [1 0 0]
         [0 0 1], (0,1,3,2): [ 0 -1  0]
         [ 1  0  0]
         [ 0  0  1], (0,3): [-1  0  0]
         [ 0  1  0]
         [ 0  0  1], (0,3)(1,2): [-1  0  0]
         [ 0 -1  0]
         [ 0  0  1]}
"""

    V = [v.homogeneous_vector() for v in polytope.Vrepresentation()]
    Qplus = sum(v.column() * v.row() for v in V).pseudoinverse()
    Vplus = list(matrix(V) * Qplus)
    W = 1 - sum(V[i].column() * Vplus[i].row() for i in range(len(V)))

    G = polytope.restricted_automorphism_group(output='permutation')
    if acting_group is not None:
        G = acting_group

    group_dict = {}

    for perm in G.gens():
        group_dict[perm] = _match_perm(perm, V, Vplus, W)

    for perm in conj_class_reps:
        group_dict[perm] = _match_perm(perm, V, Vplus, W)

    if additional_elts is not None:
        for perm in additional_elts:
            group_dict[perm] = _match_perm(perm, V, Vplus, W)
    return group_dict


def _match_perm(permutation, V, Vplus, W):
    r"""
    Return the matrix representation of a permutation in the
    ``restricted_autormorphism_group`` of ``polytope``.

    INPUT:

    - ``polytope`` -- polyhedron object. A lattice polytope.

    - ``V`` -- list. a list of vectors from the ``match_perms_to_mats`` function.

    - ``Vplus`` -- list. from the ``match_perms_to_mats`` function.

    - ``W`` -- matrix. from the ``match_perms_to_mats`` function.

    OUTPUT:

    A matrix that acts in the same way on the polytope as the ``permutation``.

    EXAMPLES:
    """

    A = sum(V[permutation(i)].column() * Vplus[i].row() for i in range(len(V)))
    return A + W
