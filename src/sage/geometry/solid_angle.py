r"""
Solid angle of a polyhedral cone

This module implements the *normalized solid angle measure* of polyhedral
cones. The normalized solid angle measure of a cone is the amount of space
the cone takes up in reference to some given set.

EXAMPLES:

Compute the normalized solid angle measure of the first quadrant::

    sage: from sage.geometry.solid_angle import solid_angle_simplicial_2d
    sage: RDF(solid_angle_simplicial_2d(matrix([[0,1],[1,0]])))
    0.25

AUTHORS:

- Yuan Zhou (2022)

- Allison Fitisone (2022)
"""
# ****************************************************************************
#       Copyright (C) 2022 Yuan Zhou <yuan.zhou@uky.edu>
#       Copyright (C) 2022 Allison Fitisone <allison.fitisone@uky.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.symbolic.constants import pi
from sage.matrix.constructor import matrix
from sage.structure.element import is_Matrix
from sage.functions.trig import arccos, atan2
from sage.modules.free_module_element import vector
from sage.calculus.var import var
from sage.symbolic.relation import solve
from sage.symbolic.subring import SymbolicSubring
import logging


def solid_angle_simplicial_2d(A):
    r"""
    Return the normalized solid angle measure of the cone generated by the
    row vector(s) of ``A``.

    INPUT:

    - ``A`` -- 2x2 matrix in the form of ``matrix([[a,b],[c,d]])`` or
      simply ``[[a,b],[c,d]]`` where the nonzero linearly independent
      rows of ``A`` generate the cone in `\RR^2`

    OUTPUT:

    - the normalized solid angle measure of the cone generated by the
      vectors

    EXAMPLES:

    This example shows the normalized measure of the solid angle spanned
    by the rows of the matrix::

        sage: from sage.geometry.solid_angle import solid_angle_simplicial_2d
        sage: solid_angle_simplicial_2d(matrix([[0, 1], [1, 0]]))
        1/4

    The input can be a list of vectors instead of a matrix as well::

        sage: solid_angle_simplicial_2d([[1, 0], [-1, sqrt(3)]])
        1/3

        sage: RDF(solid_angle_simplicial_2d([[2, 13], [-1, 7]]))  # abs tol 1e-15
        0.04687851282419763

    This example illustrates how the solid angle measure will not be
    greater than 0.5 as the function always outputs the minimal angle
    between the two rays::

        sage: RDF(solid_angle_simplicial_2d([[1, 0], [-1, -1]]))  # abs tol 1e-15
        0.375

    .. NOTE::

        This function uses the dot product of two vectors to determine the
        angle between them.

    The following tests check for corner cases where the vectors are
    antiparallel, parallel and perpendicular, respectively::

        sage: solid_angle_simplicial_2d([[1, 1], [-1, -1]])
        0

        sage: solid_angle_simplicial_2d([[1, 2], [2, 4]])
        0

        sage: solid_angle_simplicial_2d([[2, 2], [-1, 1]])
        1/4

    The following tests check the assumptions of the input::

        sage: solid_angle_simplicial_2d([[-3, 2]])
        Traceback (most recent call last):
        ...
        ValueError: input matrix has incorrect dimension

        sage: solid_angle_simplicial_2d([[1, 4], [0, 0]])
        Traceback (most recent call last):
        ...
        ValueError: input matrix has a row that is zero
    """
    if not is_Matrix(A):
        A = matrix(A)
    P = A[0][0].parent()
    if A.nrows() != 2 or A.ncols() != 2:
        raise ValueError("input matrix has incorrect dimension")
    if any(r == 0 for r in A.rows()):
        raise ValueError("input matrix has a row that is zero")
    if A.rank() < 2:
        return P.zero()
    u = A.row(0)
    v = A.row(1)
    p = u.dot_product(v)
    a = u.norm()
    b = v.norm()
    cs = p/(a*b)
    final_calc = arccos(cs) / (2*pi)
    return final_calc


def solid_angle_2d(A):
    r"""
    Return the normalized solid angle measure of the cone spanned by
    vectors in `\RR^2`.

    INPUT:

    - ``A`` -- `n\times 2` matrix whose rows vectors span the cone in `\RR^2`
      of which we look for the solid angle. The input can be in the form of a
      matrix or as a list of vectors in `\RR^2`.

    OUTPUT: The normalized solid angle measure spanned by the row vectors

    EXAMPLES:

    The following three examples show the solid angle measures of the cones
    spanned by the given two, three or four vectors in `\RR^2`, respectively::

        sage: from sage.geometry.solid_angle import solid_angle_2d
        sage: import logging
        sage: logging.disable(logging.INFO)
        sage: A = matrix([[2,3],[-3,-7]])
        sage: RDF(solid_angle_2d(A))  # abs tol 1e-15
        0.4708570082990789

        sage: A = matrix([[1,0],[0,1],[-1,0]])
        sage: solid_angle_2d(A)
        1/2

        sage: A = matrix([[1,1],[1,2],[-1,1],[-3,0]])
        sage: RDF(solid_angle_2d(A))  # abs tol 1e-15
        0.375


    The following examples illustrate how the solid angle measure can equal
    `1`. That is, the span of the rays is all of space.::

        sage: A = matrix([[1,1],[0,-1],[-1,-1],[-3,0]])
        sage: solid_angle_2d(A)
        1

        sage: A = matrix([[0.2,0.2],[0,-1],[-1,-1],[-3,0]])
        sage: solid_angle_2d(A)
        1.00000000000000

        sage: A = matrix([[sqrt(3),0],[-2,-1/5],[-1,14.7]])
        sage: solid_angle_2d(A)
        1

    Check examples where the where cones have affine dimension less than `2`::

        sage: A = matrix([[1,0],[2,0]])
        sage: solid_angle_2d(A)
        0
        sage: A = matrix([[1,2],[-2,-4]])
        sage: solid_angle_2d(A)
        0
        sage: A = matrix([[-2,5],[-4,10],[-1,5/2],[-2/5,1]])
        sage: solid_angle_2d(A)
        0
    """
    import logging
    logging.getLogger().setLevel(logging.INFO)
    if not is_Matrix(A):
        A = matrix(A)
    P = A[0][0].parent()
    if A.rank() < 2:
        return P.zero()
    if A.nrows() == 2:
        return solid_angle_simplicial_2d(A)
    else:
        d = A.nrows()
        v = matrix([A[i]/A[i].norm() for i in range(d)])
        for i in range(d-1):
            for j in range(i+1, d):
                if v[i] == -v[j]:
                    ab = vector([-v[i][1], v[i][0]])
                    if all(A[k] * ab >= 0 for k in range(d)) or \
                       all(A[k] * ab <= 0 for k in range(d)):
                        return P.one()/2
                    else:
                        return P.one()
        for k in range(1, d):
            if v[0] * v[k] < 0:
                for j in range(1, d):
                    var('a b')
                    eqn = (-a * v[0][0] - b * v[k][0] - v[j][0] == 0,
                           -a * v[0][1] - b * v[k][1] - v[j][1] == 0,
                           a >= 0,
                           b >= 0)
                    if len(solve(eqn, (a, b))) != 0:
                        return P.one()
        A_list = simplicial_subcones_decomposition(A)
        logging.info('Decompose into simplicial subcones\n' +
                     ',\n'.join('{}'.format(Ai) for Ai in A_list))
        results = [solid_angle_simplicial_2d(Ai) for Ai in A_list]
        logging.info("Solid angles of the subcones are %s" % results)
        return sum(results)


def simplicial_subcones_decomposition(A):
    r"""
    Return a list of matrices that give the extreme rays
    of the simplicial cones formed from the triangulation
    of ``A``.

    INPUT:

    - ``A`` -- matrix; ``A`` is a matrix whose row vectors are a generating set
      for a cone (not necessarily simplicial.)

    OUTPUT:

    - a list of matrices that corresponds to the dissection of the cone
      spanned by the rows of ``A`` into simplicial cones.
      Each matrix represents a simplicial cone in the dissection.

    EXAMPLES:

    This example shows that the cone spanned by ``[1,0,0], [0,1,0], [0,0,1]``,
    and ``[-1,0,0]`` can be dissected into two simplicial cones, one with
    extreme rays ``[1,0,0], [0,1,0], [0,0,1]`` and the other with extreme
    rays ``[0,1,0], [0,0,1], [-1,0,0]``::

        sage: from sage.geometry.solid_angle import simplicial_subcones_decomposition
        sage: A = matrix([[1,0,0],[0,1,0],[0,0,1],[-1,0,0]])
        sage: simplicial_subcones_decomposition(A)
        [
        [1 0 0]  [ 0  1  0]
        [0 1 0]  [ 0  0  1]
        [0 0 1], [-1  0  0]
        ]

    This example shows that if the input corresponds to a simplicial cone,
    the function returns [input matrix itself]::

        sage: A = matrix([[1,0,0],[1,2,3],[-5,4,2]])
        sage: simplicial_subcones_decomposition(A)
        [
        [ 1  0  0]
        [ 1  2  3]
        [-5  4  2]
        ]

    This example shows that the function works in higher dimensions, such as
    `\RR^4`. Note that the input can also be in the form of a list of vectors::

        sage: A_in = [[1,0,-2,0],[1,2,3,-2],[-1,3,4,4],[-2,-1,0,0],[1,1,1,3]]
        sage: simplicial_subcones_decomposition(A_in)
        [
        [ 1  0 -2  0]  [ 1  0 -2  0]  [ 1  0 -2  0]  [ 1  2  3 -2]
        [ 1  2  3 -2]  [ 1  2  3 -2]  [-1  3  4  4]  [-1  3  4  4]
        [-1  3  4  4]  [-1  3  4  4]  [-2 -1  0  0]  [-2 -1  0  0]
        [-2 -1  0  0], [ 1  1  1  3], [ 1  1  1  3], [ 1  1  1  3]
        ]

    This example shows when the vectors in ``A`` are in `\RR^n`, but the
    cone spanned by the vectors lives in a lower dimensional space::

        sage: A = matrix([[1,0,0],[0,1,0],[3,2,0]])
        sage: simplicial_subcones_decomposition(A)
        [
        [1 0 0]  [0 1 0]
        [3 2 0], [3 2 0]
        ]

    This example shows that the cone in `\RR^4` spanned by the rows of ``A``
    (which is input as a list of lists) is actually a halfspace of affine
    dimension `2`. The triangulation dissects it into three 2-d subcones::

        sage: A_in = [[-3,0,5,0],[0,0,1,0],[-4,0,0,0],[-1,0,0,0],[0,0,-4,0]]
        sage: simplicial_subcones_decomposition(A_in)
        [
        [-3  0  5  0]  [-3  0  5  0]  [-4  0  0  0]
        [ 0  0  1  0], [-4  0  0  0], [ 0  0 -4  0]
        ]

    TESTS:

    Below we show that the function does not determine a minimal description
    of the cone of interest. Note that the cone spanned by vectors [0,1,0],
    [0,1,1], and [0,0,1] is the cone spanned by vectors [0,1,0], and [0,0,1].::

        sage: A=matrix([[0,1,0],[0,0,1]])
        sage: simplicial_subcones_decomposition(A)
        [
        [0 1 0]
        [0 0 1]
        ]

        sage: A = matrix([[0,1,0],[0,1,1],[0,0,1]])
        sage: simplicial_subcones_decomposition(A)
        [
        [0 1 0]  [0 1 1]
        [0 1 1], [0 0 1]
        ]
    """
    if not is_Matrix(A):
        A = matrix(A)
    r = A.rank()
    if A.rank() == A.nrows():
        return [A]
    else:
        from sage.geometry.triangulation.point_configuration \
            import PointConfiguration
        origin = A.nrows()
        pc = PointConfiguration(A.stack(vector([0]*A.ncols())), star=origin)
        triangulation = pc.triangulate()
        matrices = []
        for simplex in triangulation:
            matrices.append(matrix(A[i] for i in simplex if i != origin))
        return matrices


def solid_angle_simplicial_arccos_3d(A):
    r"""
    Return the normalized solid angle measure of the cone spanned by
    the three row vectors of ``A``.

    INPUT:

    - ``A`` -- 3x3 matrix or a list of three vectors in `\RR^3` where the row
      vectors represent the three extreme rays/vectors of the cone in `\RR^3`.
      Any two vectors should not be scalar multiples of each other.

    OUTPUT:

    - the normalized solid angle measure spanned by the three vectors

    EXAMPLES:

    The examples show the measure of the solid angle spanned by the vectors::

        sage: from sage.geometry.solid_angle import solid_angle_simplicial_arccos_3d
        sage: A = matrix([[sqrt(5),0,0],[0,1,0],[0,0,1]])
        sage: solid_angle_simplicial_arccos_3d(A)
        1/8

        sage: A = matrix([[1,0,0],[0,0,1],[-1,-1,-1]])
        sage: RDF(solid_angle_simplicial_arccos_3d(A))  # abs tol 1e-15
        0.2916666666666667

    The input can be a list of vectors instead of a matrix::

        sage: solid_angle_simplicial_arccos_3d(
        ....:         [[0,0,3],[-1,-1,0],[-2,2,0]])
        1/8

        sage: RDF(solid_angle_simplicial_arccos_3d(
        ....:    [[sqrt(7),0,0],[sqrt(2),sqrt(2),0],
        ....:    [1,1,1]]))  # abs tol 1e-15
        0.020833333333333353

    This example shows the solid angle of a cone in 3d with affine dimension 2.
    In contrast to ``solid_angle_3d``, this formula gives a non-zero angle::

        sage: A = matrix([[2,0,0],[0,3,0],[-4,-4,0]])
        sage: solid_angle_simplicial_arccos_3d(A)
        1/2

    It is an error to input a matrix ``A``, which has two vectors
    that are scalar multiples of each other::

        sage: A = matrix([[-1,0,1],[3,0,0],[-1,0,0]])
        sage: solid_angle_simplicial_arccos_3d(A)
        Traceback (most recent call last):
        ...
        ZeroDivisionError: rational division by zero

    It is an error to input vectors from `\RR^2` into this function::

        sage: solid_angle_simplicial_arccos_3d(A=matrix([[1,0],[3,4],[-1,2]]))
        Traceback (most recent call last):
        ...
        ValueError: input matrix has incorrect dimension.

    .. NOTE::

        This function uses the formula given in Proposition 6 of
        Beck et. al.'s 2015 paper entitled "Positivity Theorems
        for Solid-Angle Polynomials."
    """
    if not hasattr(A, 'nrows'):
        A = matrix(A)
    if A.nrows() != 3 or A.ncols() != 3:
        raise ValueError("input matrix has incorrect dimension.")
    v_0 = A.row(0)
    v_1 = A.row(1)
    v_2 = A.row(2)
    c_01 = v_0.cross_product(v_1)
    c_02 = v_0.cross_product(v_2)
    c_12 = v_1.cross_product(v_2)
    n_01 = c_01.norm()
    n_02 = c_02.norm()
    n_12 = c_12.norm()
    d_0 = c_01.dot_product(c_02)
    d_1 = c_01.dot_product(c_12)
    d_2 = c_02.dot_product(c_12)
    a_0 = arccos(d_0/(n_01*n_02))
    a_1 = arccos(-d_1/(n_01*n_12))
    a_2 = arccos(d_2/(n_02*n_12))
    return (a_0+a_1+a_2 - pi)/(4*pi)


def solid_angle_simplicial_arctan_3d(A):
    r"""
    Return the normalized solid angle measure of the cone spanned by
    the three row vectors of ``A``.

    INPUT:

    - ``A`` -- 3x3 matrix or a list of three vectors in `\RR^3` where the row
      vectors represent the three extreme rays/vectors of the cone in `\RR^3`.
      Any two vectors should not be scalar multiples of each other.

    OUTPUT:

    - the normalized solid angle measure spanned by the three vectors

    EXAMPLES:

    This example shows the measure of the solid angle spanned by the vectors::

        sage: from sage.geometry.solid_angle import solid_angle_simplicial_arctan_3d
        sage: A = matrix([[1,0,0],[0,1,0],[0,0,1]])
        sage: solid_angle_simplicial_arctan_3d(A)
        1/8

    The input can be a list of vectors instead of a matrix::

        sage: solid_angle_simplicial_arctan_3d(
        ....:         [[0,0,3],[-1,-1,0],[-2,2,0]])
        1/8

        sage: RDF(solid_angle_simplicial_arctan_3d(
        ....:    [[pi, 0, 0],[1.6, 1.6, 0],
        ....:    [1/sqrt(2), 1/sqrt(2), 1/sqrt(2)]])) # abs tol 1e-15
        0.020833333333333332

    This example shows the solid angle of a cone in 3d with affine dimension 2.
    In contrast to ``solid_angle_3d``, this formula gives a non-zero angle::

        sage: A = matrix([[2,0,0],[0,3,0],[-4,-4,0]])
        sage: RDF(solid_angle_simplicial_arctan_3d(A))  # abs tol 1e-15
        0.5

    It is an error to input a matrix ``A``, which has two vectors
    that are scalar multiples of each other::

        sage: A = matrix([[-1,0,1],[3,0,0],[-1,0,0]])
        sage: RDF(solid_angle_simplicial_arctan_3d(A))
        NaN

    It is an error to input vectors from `\RR^2` into this function::

        sage: solid_angle_simplicial_arctan_3d(matrix([[1,0],[3,4],[-1,2]]))
        Traceback (most recent call last):
        ...
        ValueError: input matrix has incorrect dimension.

    .. NOTE::

        This function uses the formula given in Ribando's
        2006 paper entitled "Measuring Solid Angles Beyond
        Dimension Three." Refer to Oosterom and Strackee (1983)
        and Eriksson (1990) for more information.
    """
    if not hasattr(A, 'nrows'):
        A = matrix(A)
    if A.nrows() != 3 or A.ncols() != 3:
        raise ValueError("input matrix has incorrect dimension.")
    vnorm = [A[i].norm() for i in range(3)]
    a = A[0]/vnorm[0]
    b = A[1]/vnorm[1]
    c = A[2]/vnorm[2]
    w = matrix([a, b, c])
    det = abs(w.determinant())  # same as det of matrix [abc]
    dab = a.dot_product(b)
    dac = a.dot_product(c)
    dbc = b.dot_product(c)
    denom = 1+dab+dac+dbc
    omega = 2*atan2(det, denom)
    return omega/(4*pi)


def solid_angle_3d(A, method="arctan"):
    r"""
    Return the normalized solid angle measure of the cone spanned
    by three vectors in `\RR^3`.

    INPUT:

    - ``A`` -- `n\times 3` matrix whose rows vectors span the cone in `\RR^3`
      of which we look for the solid angle. The input can be in the form of a
      matrix or as a list of vectors in `\RR^3`.

    - ``method`` -- (optional) Either ``arctan`` or ``arccos``.

    OUTPUT: The normalized solid angle measure of the cone spanned by the row
    vectors, as a decimal

    EXAMPLES:

    The following three examples show the solid angles spanned by the given
    three, four or five vectors in `\RR^3`, respectively::

        sage: from sage.geometry.solid_angle import solid_angle_3d
        sage: import logging
        sage: logging.disable(logging.WARNING)
        sage: RDF(solid_angle_3d([[1,0,2],[-1,3,1],[1,0,-1]]))      # abs tol 1e-15
        0.1817687464348209

        sage: A = matrix([[1,0,0],[-1,0,0],[-1,3,1],[1,0,-1]])
        sage: import logging
        sage: logging.disable(logging.WARNING)
        sage: RDF(solid_angle_3d(A))                              # abs tol 1e-15
        0.30120819117478337

        sage: A = matrix([[1,0,0],[0,1,0],[-1,0,0],[0,0,-1],[1,1,1]])
        sage: solid_angle_3d(A)                                # abs tol 1e-15
        3/8

    This example illustrates how using the `arccos` method instead of the
    default `arctan` method gives the same result::

        sage: A = matrix([[1,0,0],[0,1,0],[-1,0,0],[0,0,-1],[1,1,1]])
        sage: RDF(solid_angle_3d(A, method="arccos"))               # abs tol 1e-15
        0.375

    This example illustrates how the solid angle measure can equal 1. That is,
    the span of the rays is all of space::

        sage: A = matrix([[1,0,0],[0,1,0],[-1,0,0],[0,0,1],[0,0,-1],[0,-1,0]])
        sage: solid_angle_3d(A)                                # abs tol 1e-15
        1.0

    Check corner case where the where cones have affine dimension less than 3::

        sage: import logging
        sage: logging.disable(logging.WARNING)
        sage: solid_angle_3d([[1,0,0],[2,0,0],[-1,1,0],[-2,2,0]])
        0

        sage: solid_angle_3d(matrix([[1,0,0],[0,2,3]]))
        0
    """
    import logging
    logging.getLogger().setLevel(logging.INFO)
    if not hasattr(A, 'nrows'):
        A = matrix(A)
    P = A[0][0].parent()
    if A.rank() < 3:
        logging.warning("cone not full-dimensional")
        return P.zero()
    if method == "arctan":
        solid_angle_function = solid_angle_simplicial_arctan_3d
    elif method == "arccos":
        solid_angle_function = solid_angle_simplicial_arccos_3d
    else:
        raise ValueError("method %s of solid_angle_3d is unknown" % method)
    if A.nrows() == 3:
        return solid_angle_function(A)
    A_list = simplicial_subcones_decomposition(A)
    logging.info('Decompose into simplicial subcones\n' +
                 ',\n'.join('{}'.format(Ai) for Ai in A_list))
    results = [solid_angle_function(Ai) for Ai in A_list]
    logging.info("Solid angles of the subcones are %s" % results)
    return sum(results)
