r"""
Solid angle of a polyhedral cone

This module implements the *normalized solid angle measure* of polyhedral
cones. The normalized solid angle measure of a cone is the amount of space
the cone takes up in reference to some given set.

EXAMPLES:

Compute the normalized solid angle measure of the first quadrant::

    sage: from sage.geometry.solid_angle import solid_angle_simplicial_2d
    sage: RDF(solid_angle_simplicial_2d(matrix([[0,1],[1,0]])))
    0.25

AUTHORS:

- Yuan Zhou (2022)

- Allison Fitisone (2022)
"""
# ****************************************************************************
#       Copyright (C) 2022 Yuan Zhou <yuan.zhou@uky.edu>
#       Copyright (C) 2022 Allison Fitisone <allison.fitisone@uky.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.symbolic.constants import pi
from sage.matrix.constructor import matrix
from sage.structure.element import is_Matrix
from sage.functions.trig import arccos
from sage.modules.free_module_element import vector
from sage.calculus.var import var
from sage.symbolic.relation import solve
from sage.symbolic.subring import SymbolicSubring
from sage.rings.integer_ring import ZZ
import logging


def solid_angle_simplicial_2d(A):
    r"""
    Return the normalized solid angle measure of the cone generated by the
    row vector(s) of ``A``.

    INPUT:

    - ``A`` -- 2x2 matrix in the form of ``matrix([[a,b],[c,d]])`` or
      simply ``[[a,b],[c,d]]`` where the nonzero linearly independent
      rows of ``A`` generate the cone in `\RR^2`

    OUTPUT:

    - the normalized solid angle measure of the cone generated by the
      vectors

    EXAMPLES:

    This example shows the normalized measure of the solid angle spanned
    by the rows of the matrix::

        sage: from sage.geometry.solid_angle import solid_angle_simplicial_2d
        sage: solid_angle_simplicial_2d(matrix([[0, 1], [1, 0]]))
        1/4

    The input can be a list of vectors instead of a matrix as well::

        sage: solid_angle_simplicial_2d([[1, 0], [-1, sqrt(3)]])
        1/3

        sage: solid_angle_simplicial_2d(matrix([[0, 1], [4.5, 0]]))
        0.785398163397448/pi

        sage: RDF(solid_angle_simplicial_2d([[2, 13], [-1, 7]]))  # abs tol 1e-15
        0.04687851282419763

    This example illustrates how the solid angle measure will not be
    greater than 0.5 as the function always outputs the minimal angle
    between the two rays::

        sage: RDF(solid_angle_simplicial_2d([[1, 0], [-1, -1]]))  # abs tol 1e-15
        0.375

    .. NOTE::

        This function uses the dot product of two vectors to determine the
        angle between them.

    The following tests check for corner cases where the vectors are
    antiparallel, parallel and perpendicular, respectively::

        sage: solid_angle_simplicial_2d([[1, 1], [-1, -1]])
        0

        sage: solid_angle_simplicial_2d([[1, 2], [2, 4]])
        0

        sage: solid_angle_simplicial_2d([[2, 2], [-1, 1]])
        1/4

    The following tests check the assumptions of the input::

        sage: solid_angle_simplicial_2d([[-3, 2]])
        Traceback (most recent call last):
        ...
        ValueError: input matrix has incorrect dimension

        sage: solid_angle_simplicial_2d([[1, 4], [0, 0]])
        Traceback (most recent call last):
        ...
        ValueError: input matrix has a row that is zero

    TESTS:

    In the following examples, we check the parent of the output corresponding
    to an input whose parent is exact.::

        sage: A = matrix([[2/3, 0], [-1/3, 5]])
        sage: solid_angle_simplicial_2d(A)
        1/2*arccos(-1/226*sqrt(226))/pi
        sage: solid_angle_simplicial_2d(A).parent()
        Symbolic Ring

        sage: A = matrix([[2/3, 0], [-1/3, 0]])
        sage: solid_angle_simplicial_2d(A)
        0
        sage: solid_angle_simplicial_2d(A).parent()
        Symbolic Constants Subring

    In the following examples, we check the parent of the output corresponding
    to an input whose parent is not exact::

        sage: A = matrix([[12, 0], [RBF(1.5), 9]])
        sage: solid_angle_simplicial_2d(A)
        ([0.702823824690135 +/- 4.26e-16])/pi
        sage: solid_angle_simplicial_2d(A).parent()
        Symbolic Ring

        sage: A = matrix([[RBF(12.7), 0], [-1, 0]])
        sage: solid_angle_simplicial_2d(A)
        0
        sage: solid_angle_simplicial_2d(A).parent()
        Real ball field with 53 bits of precision

    In the following examples, we check the parent of the output corresponding
    to an input whose parent is symbolic::

        sage: A = matrix([[12, 0], [sqrt(17), 9]])
        sage: solid_angle_simplicial_2d(A)
        1/2*arccos(1/14*sqrt(17)*sqrt(2))/pi
        sage: solid_angle_simplicial_2d(A).parent()
        Symbolic Ring

        sage: A = matrix([[0, sqrt(18)], [0, -sqrt(pi)]])
        sage: solid_angle_simplicial_2d(A)
        0
        sage: solid_angle_simplicial_2d(A).parent()
        Symbolic Constants Subring
    """
    if not is_Matrix(A):
        A = matrix(A)
    P = A[0][0].parent()
    if A.nrows() != 2 or A.ncols() != 2:
        raise ValueError("input matrix has incorrect dimension")
    if any(r == 0 for r in A.rows()):
        raise ValueError("input matrix has a row that is zero")
    if A.rank() < 2:
        import sage.rings.abc
        if P.is_exact() or isinstance(P, sage.rings.abc.SymbolicRing):
            return SymbolicSubring(no_variables=True)(ZZ(0))
        else:
            return P.zero()
    u = A.row(0)
    v = A.row(1)
    p = u.dot_product(v)
    a = u.norm()
    b = v.norm()
    cs = p/(a*b)
    final_calc = arccos(cs) / (2*pi)
    return final_calc


def solid_angle_2d(A):
    r"""
    Return the normalized solid angle measure of the cone spanned by
    vectors in `\RR^2`.

    INPUT:

    - ``A`` -- `n\times 2` matrix whose rows vectors span the cone in `\RR^2`
      of which we look for the solid angle. The input can be in the form of a
      matrix or as a list of vectors in `\RR^2`.

    OUTPUT: The normalized solid angle measure spanned by the row vectors

    EXAMPLES:

    The following three examples show the solid angle measures of the cones
    spanned by the given two, three or four vectors in `\RR^2`, respectively::

        sage: from sage.geometry.solid_angle import solid_angle_2d
        sage: A = matrix([[2,3],[-3,-7]])
        sage: RDF(solid_angle_2d(A))  # abs tol 1e-15
        0.4708570082990789

        sage: A = matrix([[1,0],[0,1],[-1,0]])
        sage: solid_angle_2d(A)
        1/2

        sage: A = matrix([[1,1],[1,2],[-1,1],[-3,0]])
        sage: import logging
        sage: logging.disable(logging.INFO)
        sage: RDF(solid_angle_2d(A))  # abs tol 1e-15
        0.375

    In the following examples, we show that when a minimum description of the
    cone of interest is not provided, the cone is first triangulated. The solid
    angle measure of each of subcone is logged::

        sage: A = matrix([[1,0],[0,1],[-1,1]])
        sage: logging.disable(logging.NOTSET)
        sage: solid_angle_2d(A)
        INFO:Decompose into simplicial subcones
        [1 0]
        [0 1],
        [ 0  1]
        [-1  1]
        INFO:Solid angles of the subcones are [1/4, 1/2*arccos(1/2*sqrt(2))/pi]
        1/2*arccos(1/2*sqrt(2))/pi + 1/4

        sage: A = matrix([[1,0],[0,1],[1,1]])
        sage: solid_angle_2d(A)
        INFO:Decompose into simplicial subcones
        [1 0]
        [1 1],
        [0 1]
        [1 1]
        INFO:Solid angles of the subcones are [1/2*arccos(1/2*sqrt(2))/pi, 1/2*arccos(1/2*sqrt(2))/pi]
        arccos(1/2*sqrt(2))/pi

    The following examples illustrate how the solid angle measure can equal
    `1`. That is, the span of the rays is all of space.::

        sage: A = matrix([[1,1],[0,-1],[-1,-1],[-3,0]])
        sage: solid_angle_2d(A)
        1

        sage: A = matrix([[0.2,0.2],[0,-1],[-1,-1],[-3,0]])
        sage: solid_angle_2d(A)
        1.00000000000000

        sage: A = matrix([[sqrt(3),0],[-2,-1/5],[-1,14.7]])
        sage: solid_angle_2d(A)
        1

    Check examples where the where cones have affine dimension less than `2`::

        sage: A = matrix([[1,0],[2,0]])
        sage: solid_angle_2d(A)
        0
        sage: A = matrix([[1,2],[-2,-4]])
        sage: solid_angle_2d(A)
        0
        sage: A = matrix([[-2,5],[-4,10],[-1,5/2],[-2/5,1]])
        sage: solid_angle_2d(A)
        0
    """
    logging.getLogger().setLevel(logging.INFO)
    logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.INFO)
    if not is_Matrix(A):
        A = matrix(A)
    P = A[0][0].parent()
    if A.rank() < 2:
        import sage.rings.abc
        if P.is_exact() or isinstance(P, sage.rings.abc.SymbolicRing):
            return SymbolicSubring(no_variables=True)(ZZ(0))
        else:
            return P.zero()
    if A.nrows() == 2:
        return solid_angle_simplicial_2d(A)
    else:
        d = A.nrows()
        v = matrix([A[i]/A[i].norm() for i in range(d)])
        for i in range(d-1):
            for j in range(i+1, d):
                if v[i] == -v[j]:
                    ab = vector([-v[i][1], v[i][0]])
                    if all(A[k] * ab >= 0 for k in range(d)) or \
                       all(A[k] * ab <= 0 for k in range(d)):
                        import sage.rings.abc
                        from sage.rings.rational_field import QQ
                        if P.is_exact() or isinstance(P, sage.rings.abc.SymbolicRing):
                            return SymbolicSubring(no_variables=True)(QQ(1/2))
                        else:
                            return P.one()/2.
                    else:
                        return P.one()
        for k in range(1, d):
            if v[0] * v[k] < 0:
                for j in range(1, d):
                    var('a b')
                    eqn = (-a * v[0][0] - b * v[k][0] - v[j][0] == 0,
                           -a * v[0][1] - b * v[k][1] - v[j][1] == 0,
                           a >= 0,
                           b >= 0)
                    if len(solve(eqn, (a, b))) != 0:
                        return P.one()
        A_list = simplicial_subcones_decomposition(A)
        logging.info('Decompose into simplicial subcones\n' +
                     ',\n'.join('{}'.format(Ai) for Ai in A_list))
        results = [solid_angle_simplicial_2d(Ai) for Ai in A_list]
        logging.info("Solid angles of the subcones are %s" % results)
        return sum(results)


def simplicial_subcones_decomposition(A):
    r"""
    Return a list of matrices that give the extreme rays
    of the simplicial cones formed from the triangulation
    of ``A``.

    INPUT:

    - ``A`` -- matrix; ``A`` is a matrix whose row vectors are a generating set
      for a cone (not necessarily simplicial.)

    OUTPUT:

    - a list of matrices that corresponds to the dissection of the cone
      spanned by the rows of ``A`` into simplicial cones.
      Each matrix represents a simplicial cone in the dissection.

    EXAMPLES:

    This example shows that the cone spanned by ``[1,0,0], [0,1,0], [0,0,1]``,
    and ``[-1,0,0]`` can be dissected into two simplicial cones, one with
    extreme rays ``[1,0,0], [0,1,0], [0,0,1]`` and the other with extreme
    rays ``[0,1,0], [0,0,1], [-1,0,0]``::

        sage: from sage.geometry.solid_angle import simplicial_subcones_decomposition
        sage: A = matrix([[1,0,0],[0,1,0],[0,0,1],[-1,0,0]])
        sage: simplicial_subcones_decomposition(A)
        [
        [1 0 0]  [ 0  1  0]
        [0 1 0]  [ 0  0  1]
        [0 0 1], [-1  0  0]
        ]

    This example shows that if the input corresponds to a simplicial cone,
    the function returns [input matrix itself]::

        sage: A = matrix([[1,0,0],[1,2,3],[-5,4,2]])
        sage: simplicial_subcones_decomposition(A)
        [
        [ 1  0  0]
        [ 1  2  3]
        [-5  4  2]
        ]

    This example shows that the function works in higher dimensions, such as
    `\RR^4`. Note that the input can also be in the form of a list of vectors::

        sage: A_in = [[1,0,-2,0],[1,2,3,-2],[-1,3,4,4],[-2,-1,0,0],[1,1,1,3]]
        sage: simplicial_subcones_decomposition(A_in)
        [
        [ 1  0 -2  0]  [ 1  0 -2  0]  [ 1  0 -2  0]  [ 1  2  3 -2]
        [ 1  2  3 -2]  [ 1  2  3 -2]  [-1  3  4  4]  [-1  3  4  4]
        [-1  3  4  4]  [-1  3  4  4]  [-2 -1  0  0]  [-2 -1  0  0]
        [-2 -1  0  0], [ 1  1  1  3], [ 1  1  1  3], [ 1  1  1  3]
        ]

    This example shows when the vectors in ``A`` are in `\RR^n`, but the
    cone spanned by the vectors lives in a lower dimensional space::

        sage: A = matrix([[1,0,0],[0,1,0],[3,2,0]])
        sage: simplicial_subcones_decomposition(A)
        [
        [1 0 0]  [0 1 0]
        [3 2 0], [3 2 0]
        ]

    This example shows that the cone in `\RR^4` spanned by the rows of ``A``
    (which is input as a list of lists) is actually a halfspace of affine
    dimension `2`. The triangulation dissects it into three 2-d subcones::

        sage: A_in = [[-3,0,5,0],[0,0,1,0],[-4,0,0,0],[-1,0,0,0],[0,0,-4,0]]
        sage: simplicial_subcones_decomposition(A_in)
        [
        [-3  0  5  0]  [-3  0  5  0]  [-4  0  0  0]
        [ 0  0  1  0], [-4  0  0  0], [ 0  0 -4  0]
        ]

    TESTS:

    Below we show that the function does not determine a minimal description
    of the cone of interest. Note that the cone spanned by vectors [0,1,0],
    [0,1,1], and [0,0,1] is the cone spanned by vectors [0,1,0], and [0,0,1].::

        sage: A=matrix([[0,1,0],[0,0,1]])
        sage: simplicial_subcones_decomposition(A)
        [
        [0 1 0]
        [0 0 1]
        ]

        sage: A = matrix([[0,1,0],[0,1,1],[0,0,1]])
        sage: simplicial_subcones_decomposition(A)
        [
        [0 1 0]  [0 1 1]
        [0 1 1], [0 0 1]
        ]
    """
    if not is_Matrix(A):
        A = matrix(A)
    r = A.rank()
    if A.rank() == A.nrows():
        return [A]
    else:
        from sage.geometry.triangulation.point_configuration \
            import PointConfiguration
        origin = A.nrows()
        pc = PointConfiguration(A.stack(vector([0]*A.ncols())), star=origin)
        triangulation = pc.triangulate()
        matrices = []
        for simplex in triangulation:
            matrices.append(matrix(A[i] for i in simplex if i != origin))
        return matrices
