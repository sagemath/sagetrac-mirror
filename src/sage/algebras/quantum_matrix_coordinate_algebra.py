r"""
Quantum Matrix Coordinate Algebras

AUTHORS:

- Travis Scrimshaw (01-2016): initial version
"""

##############################################################################
#       Copyright (C) 2016 Travis Scrimshaw <tscrimsh at umn.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/
##############################################################################

from sage.misc.cachefunc import cached_method
from sage.sets.family import Family
from sage.categories.algebras import Algebras
from sage.categories.bialgebras import Bialgebras
from sage.combinat.free_module import CombinatorialFreeModule
from sage.groups.indexed_free_group import IndexedFreeAbelianGroup
from sage.rings.polynomial.laurent_polynomial_ring import LaurentPolynomialRing
from sage.rings.all import ZZ

class QuantumMatrixCoordinateAlgebra(CombinatorialFreeModule):
    r"""
    A quantum matrix coordinate algebra.

    Let `R` be a commutative ring. The quantum coordinate ring
    of `M_R(m, n)` is the associative algebra over `R[q, q^{-1}]`
    generated by `x_{ij}`, for `i = 1, 2, \ldots, m`, `j = 1, 2, \ldots, n`,
    and subject to the following relations:

    .. MATH::

        \begin{array}{ll}
        x_{it} x_{ij} = q^{-2} x_{ij} x_{it}   & j < t, \\
        x_{sj} x_{ij} = q^{-2} x_{ij} x_{sj}   & i < s, \\
        x_{st} x_{ij} = x_{ij} x_{st}          & i < s, j > t, \\
        x_{st} x_{ij} = x_{ij} x_{st} + (q^{-2} - q^2) x_{it} x_{sj}
                                               & i < s, j < t. \\
        \end{array}

    For `m = n`, it is also a bialgebra given by

    .. MATH::

        \Delta(x_{ij}) = \sum_{k=1}^n x_{ik} \otimes x_{kj},
        \varepsilon(x_{ij}) = \delta_{ij}.

    .. NOTE::

        The `q` considered here is `q^{1/2}` in [FRT]_ or some books
        such as *A guide to quantum groups* by Chari and Pressley or
        *Quantum groups* by Kassel.

    INPUT:

    - ``m`` -- the integer `m`
    - ``n`` -- the integer `n`
    - ``R`` -- (optional) the ring `R` if `q` is not specified (the
      default is `\ZZ`); otherwise the ring containing `q`
    - ``q`` -- (optional) the variable `q`; the default is
      `q \in R[q, q^{-1}]`
    - ``bar`` -- (optional) the involution on the base ring; the
      default is `q \mapsto q^{-1}`

    REFERENCES:

    .. [DD91] R. Dipper and S. Donkin. *Quantum* `GL_n`.
       Proc. London Math. Soc. (3) **63** (1991), no. 1, pp. 165-211.

    .. [FRT] Faddeev, Reshetikhin and Takhtajan.
       *Quantization of Lie Groups and Lie Algebras*.
       Leningrad Math. J. vol. **1** (1990), no. 1.

    .. [Karimipour93] Vahid Karimipour.
       *Representations of the coordinate ring of* `GL_q(n)`.
       (1993). :arxiv:`hep-th/9306058`.

    .. [ZZ05] Hechun Zhang and R. B. Zhang.
       *Dual canonical bases for the quantum special linear group
       and invariant subalgebras*.
       Lett. Math. Phys. **73** (2005), pp. 165-181. :arxiv:`math/0509651`.
    """
    @staticmethod
    def __classcall_private__(cls, m, n=None, q=None, bar=None, R=None):
        """
        Normalize input to ensure a unique representation.

        EXAMPLES::

            sage: R.<q> = LaurentPolynomialRing(ZZ)
            sage: O1 = algebras.QuantumMatrixCoordinate(4)
            sage: O2 = algebras.QuantumMatrixCoordinate(4, 4, q=q)
            sage: O3 = algebras.QuantumMatrixCoordinate(4, R=ZZ)
            sage: O4 = algebras.QuantumMatrixCoordinate(4, R=R, q=q)
            sage: O1 is O2 and O2 is O3 and O3 is O4
            True
            sage: O5 = algebras.QuantumMatrixCoordinate(4, R=QQ)
            sage: O1 is O5
            False
        """
        if n is None:
            n = m
        if R is None:
            R = ZZ
        else:
            if q is not None:
                q = R(q)
        if q is None:
            q = LaurentPolynomialRing(R, 'q').gen()
        return super(QuantumMatrixCoordinateAlgebra, cls).__classcall__(cls, m, n,
                                                                        q=q, bar=bar,
                                                                        R=q.parent())

    def __init__(self, m, n, q, bar, R):
        """
        Initialize ``self``.

        TESTS::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: TestSuite(O).run()
        """
        self._m = m
        self._n = n
        self._q = q
        if bar is None:
            bar = lambda x: x.subs(q=~self._q)
        self._bar = bar
        # Set the names
        gp_indices = [(i, j) for i in range(1, m+1) for j in range(1, n+1)]
        indices = IndexedFreeAbelianGroup(gp_indices)
        if m == n:
            cat = Bialgebras(R.category()).WithBasis()
        else:
            cat = Algebras(R.category()).WithBasis()
        CombinatorialFreeModule.__init__(self, R, indices, category=cat)
        self._assign_names(['x{}{}'.format(*k) for k in gp_indices])

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: algebras.QuantumMatrixCoordinate(4)
            Quantized coordinate algebra of M(4, 4) with q=q over
             Univariate Laurent Polynomial Ring in q over Integer Ring
        """
        return "Quantized coordinate algebra of M({}, {}) with q={} over {}".format(
                    self._m, self._m, self._q, self.base_ring())

    def _latex_(self):
        r"""
        Return a latex representation of ``self``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: latex(O)
            \mathcal{O}_{q}(M(4, 4))
        """
        return "\\mathcal{O}_{%s}(M(%s, %s))"%(self._q, self._m, self._n)

    def _repr_term(self, m):
        """
        Return a string representation of the term indexed by ``m``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: I = O.indices()
            sage: x = I.an_element(); x
            F[(1, 1)]^2*F[(1, 2)]^2*F[(1, 3)]^3
            sage: O._repr_term(x)
            'x[1,1]^2*x[1,2]^2*x[1,3]^3'
            sage: O._repr_term(I.one())
            '1'
            sage: O.q() * O.one()
            q
        """
        S = m._sorted_items()
        if not S:
            return '1'
        exp = lambda e: '^{}'.format(e) if e > 1 else ''
        return '*'.join('x[{},{}]'.format(*k) + exp(e)
                        for k,e in m._sorted_items())

    def _latex_term(self, m):
        """
        Return a latex representation of the term indexed by ``m``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: I = O.indices()
            sage: x = I.an_element(); x
            F[(1, 1)]^2*F[(1, 2)]^2*F[(1, 3)]^3
            sage: O._latex_term(x)
            'x_{1,1}^{2} x_{1,2}^{2} x_{1,3}^{3}'
            sage: O._latex_term(I.one())
            '1'
            sage: latex(O.q() * O.one())
            q
        """
        S = m._sorted_items()
        if not S:
            return '1'
        exp = lambda e: '^{{{}}}'.format(e) if e > 1 else ''
        return ' '.join('x_{{{},{}}}'.format(*k) + exp(e)
                        for k,e in m._sorted_items())

    def m(self):
        """
        Return the value `m`.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4,6)
            sage: O.m()
            4
            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: O.m()
            4
        """
        return self._m

    def n(self):
        """
        Return the value `n`.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4,6)
            sage: O.n()
            6
            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: O.n()
            4
        """
        return self._n

    def q(self):
        """
        Return the variable ``q``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: O.q()
            q
            sage: O.q().parent()
            Univariate Laurent Polynomial Ring in q over Integer Ring
            sage: O.q().parent() is O.base_ring()
            True
        """
        return self._q

    @cached_method
    def one_basis(self):
        """
        Return the basis element indexing `1`.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: O.one_basis()
            1
            sage: O.one()
            1

        TESTS::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: O.one_basis() == O.indices().one()
            True
        """
        return self._indices.one()

    @cached_method
    def algebra_generators(self):
        """
        Return the group generators of ``self``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(2)
            sage: O.algebra_generators()
            Finite family {(1, 2): x[1,2], (1, 1): x[1,1],
                           (2, 1): x[2,1], (2, 2): x[2,2]}
        """
        l = [(i,j) for i in range(1, self._m+1) for j in range(1, self._n+1)]
        G = self._indices.monoid_generators()
        one = self.base_ring().one()
        return Family(l, lambda x: self.element_class(self, {G[x]:one}))

    @cached_method
    def gens(self):
        """
        Return the generators of ``self`` as a tuple.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(3)
            sage: O.gens()
            (x[1,1], x[1,2], x[1,3],
             x[2,1], x[2,2], x[2,3],
             x[3,1], x[3,2], x[3,3])
        """
        return tuple(self.algebra_generators())

    @cached_method
    def quantum_determinant(self):
        """
        Return the quantum determinant of ``self``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(2)
            sage: O.quantum_determinant()
            x[1,1]*x[2,2] - q^2*x[1,2]*x[2,1]

        We verify that the quantum determinant is central::

            sage: for n in range(2,5):
            ....:     O = algebras.QuantumMatrixCoordinate(n)
            ....:     qdet = O.quantum_determinant()
            ....:     assert all(g * qdet == qdet * g for g in O.algebra_generators())
        """
        if self._m != self._n:
            raise ValueError("undefined for non-square quantum matrices")
        from sage.combinat.permutation import Permutations
        q = self._q
        return self.sum(self.term(self._indices({(i,p(i)): 1 for i in range(1, self._n+1)}),
                                  (-q**2)**p.length())
                        for p in Permutations(self._n))

    def product_on_basis(self, a, b):
        """
        Return the product of basis elements indexed by ``a`` and ``b``.

        TESTS::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: x = O.algebra_generators()
            sage: b = x[1,4] * x[2,1] * x[3,4]  # indirect doctest
            sage: b * (b * b) == (b * b) * b
            True
            sage: p = prod(list(O.algebra_generators())[:10])
            sage: p * (p * p) == (p * p) * p  # long time
            True
            sage: x = O.an_element()
            sage: y = x^2 + x[4,4] * x[3,3] * x[1,2]
            sage: z = x[2,2] * x[1,4] * x[3,4] * x[1,1]
            sage: x * (y * z) == (x * y) * z
            True
        """
        al = a._sorted_items()
        bl = b._sorted_items()
        # Check for multiplication by 1
        if not al:
            return self.monomial(b)
        if not bl:
            return self.monomial(a)
        if al[-1][0] < bl[0][0]: # Already in order
            return self.monomial(a*b)
        G = self._indices.monoid_generators()
        one = self.base_ring().one()
        ret = self.zero()
        q = self._q
        qi2 = q**-2
        monomial = b
        coeff = one
        for pos in range(len(al)-1,-1,-1):
            ax,ae = al[pos]
            for bx,be in bl:
                if ax[0] < bx[0]:
                    # In order, so nothing more to do
                    break
                elif ax[0] == bx[0]:
                    if ax[1] > bx[1]:
                        # x_{it} x_{ij} = q^{-2} x_{ij} x_{it} if t < j
                        coeff *= qi2**(ae*be)
                    else:
                        # In order, so nothing more to do
                        break
                elif ax[1] == bx[1]:
                    # x_{sj} x_{ij} = q^{-2} x_{ij} x_{sj} if s > i
                    coeff *= qi2**(ae*be)
                elif ax[1] > bx[1]: # By this point, we must have ax[0] > bx[0]
                    # x_{st} x_{ij} = x_{ij} x_{st} + (q^{-2} - q^2) x_{it} x_{sj}
                    # if s > i, t > j

                    # By Lemma 2.7 (with fixed typo) in H. Zhang and R.B. Zhang:
                    # x_{st} x_{ij}^k = x_{ij}^k x_{st}
                    #                  + (q^{2-4k} - q^2) x_{ij}^{k-1} x_{it} x_{sj}
                    m1 = G[bx]**be * G[ax]
                    m2 = G[bx]**(be-1) * G[(bx[0],ax[1])] * G[(ax[0],bx[1])]
                    ret = self._from_dict({m1: one, m2: (q**(2-4*be) - q**2)})
                    ml = monomial._sorted_items()
                    index = ml.index((bx, be))
                    a_key = self._indices(dict(al[:pos]))
                    bp_key = self._indices(dict(ml[:index])) * G[ax]**(ae-1)
                    return (self.monomial(a_key)
                            * self.monomial(bp_key)
                            * ret
                            * self.term(self._indices(dict(ml[index+1:])), coeff))

                # Otherwise ax[1] > bx[1], but for this case they commute:
                # x_{st} x_{ij} = x_{ij} x_{st} if s > i, t < j
                # So there is nothing to do to coeff
            monomial *= G[ax]**ae
        return self.term(monomial, coeff)

    @cached_method
    def _bar_on_basis(self, x):
        """
        Return the bar involution on the basis element indexed by ``x``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: x = O.an_element()
            sage: O._bar_on_basis(x.leading_support())
            (q^-32)*x[1,1]^2*x[1,2]^2*x[1,3]^3
        """
        ret = self.one()
        for k,e in reversed(x._sorted_items()):
            ret *= self.monomial(self._indices({k:e}))
        return ret

    def coproduct_on_basis(self, x):
        """
        Return the coproduct on the basis element indexed by ``x``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: x24 = O.algebra_generators()[2,4]
            sage: O.coproduct_on_basis(x24.leading_support())
            x[2,1] # x[1,4] + x[2,2] # x[2,4] + x[2,3] # x[3,4] + x[2,4] # x[4,4]

        TESTS:

        We check that it is an algebra morphism::

            sage: O = algebras.QuantumMatrixCoordinate(3)
            sage: G = O.algebra_generators()
            sage: all(x.coproduct() * y.coproduct() == (x * y).coproduct()
            ....:     for x in G for y in G)
            True
        """
        if self._m != self._n:
            raise ValueError("undefined for non-square quantum matrices")
        T = self.tensor_square()
        I = self._indices.group_generators()
        return T.prod(T.sum_of_monomials((I[t[0], k], I[k, t[1]])
                                  for k in range(1,self._n+1))**e
                      for t,e in x._sorted_items())

    def counit_on_basis(self, x):
        """
        Return the counit on the basis element indexed by ``x``.

        EXAMPLES::

            sage: O = algebras.QuantumMatrixCoordinate(4)
            sage: G = O.algebra_generators()
            sage: I = [1,2,3,4]
            sage: matrix([[G[i,j].counit() for i in I] for j in I])  # indirect doctest
            [1 0 0 0]
            [0 1 0 0]
            [0 0 1 0]
            [0 0 0 1]
        """
        if all(t[0] == t[1] for t,e in x._sorted_items()):
            return self.base_ring().one()
        else:
            return self.base_ring().zero()

    # Antipode code for when the coordinate algebra of quantum SL is implemented
    #@cached_method
    #def _antipode_on_generator(self, i, j):
    #    """
    #    Return the antipode on the generator indexed by ``i``.
    #
    #    EXAMPLES::
    #
    #        sage: O = algebras.QuantumMatrixCoordinate(2, SL=True)
    #    """
    #    from sage.combinat.permutation import Permutations
    #    q = self._q
    #    I = range(1, i) + range(i+1, self._n+1)
    #    lift = lambda p: [val if val < j else val + 1 for val in p]
    #    gens = self.algebra_generators()
    #    t_tilde = self.sum((-q)**p.length()
    #                       * self.prod( gens[I[i],val] for i, val in enumerate(lift(p)) )
    #                       for p in Permutations(self._n-1))
    #    return (-q)**(i - j) * t_tilde
    #
    #def antipode_on_basis(self, x):
    #    """
    #    Return the antipode of the basis element indexed by ``x``.
    #
    #    EXAMPLES::
    #
    #        sage: O = algebras.QuantumMatrixCoordinate(2, SL=True)
    #    """
    #    if self._m != self._n:
    #        raise ValueError("undefined for non-square quantum matrices")
    #    ret = self.one()
    #    for k,e in reversed(x._sorted_items()):
    #        ret *= self._antipode_on_generator(*k)**e
    #    return ret

    class Element(CombinatorialFreeModule.Element):
        def bar(self):
            r"""
            Return the image of ``self`` under the bar involution.

            The bar involution is the `\QQ`-algebra anti-automorphism
            defined by `x_{ij} \mapsto x_{ji}` and `q \mapsto q^{-1}`.

            EXAMPLES::

                sage: O = algebras.QuantumMatrixCoordinate(4)
                sage: x = O.an_element()
                sage: x.bar()
                (q^-32)*x[1,1]^2*x[1,2]^2*x[1,3]^3
                sage: x = O.an_element() * O.algebra_generators()[2,4]; x
                x[1,1]^2*x[1,2]^2*x[1,3]^3*x[2,4]
                sage: xb = x.bar(); xb
                (q^-32)*x[1,1]^2*x[1,2]^2*x[1,3]^3*x[2,4]
                 + (q^-42-q^-30)*x[1,1]^2*x[1,2]^2*x[1,3]^2*x[1,4]*x[2,3]
                 + (q^-44-q^-36)*x[1,1]^2*x[1,2]*x[1,3]^3*x[1,4]*x[2,2]
                 + (q^-48-q^-40)*x[1,1]*x[1,2]^2*x[1,3]^3*x[1,4]*x[2,1]
                sage: xb.bar()
                x[1,1]^2*x[1,2]^2*x[1,3]^3*x[2,4]
            """
            P = self.parent()
            return P.sum(P._bar(c) * P._bar_on_basis(m) for m,c in self)

