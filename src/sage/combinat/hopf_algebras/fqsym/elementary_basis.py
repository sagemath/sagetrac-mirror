# -*- coding: utf-8 -*-
r"""
The elementary basis of FQSym Hopf algebra.

E-basis of FQSym
"""
#*****************************************************************************
#       Copyright (C) 2013 Jean-Baptiste Priez <jbp@kerios.fr>.
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from sage.combinat.hopf_algebras.fqsym import FreeQuasiSymmetricFunctions


class Elementary(FreeQuasiSymmetricFunctions.Bases.Base):
    '''
    This multiplicative basis is called the elementary basis of
    FQSym, denoted: `(\mathcal{E}_\sigma)`.

    EXAMPLES::

        sage: E = FQSym(QQ).E(); E
        The combinatorial Hopf algebra of Free Quasi-Symmetric Functions over the Rational Field on the Elementary basis

    An element `\mathcal E_\sigma` is defined as the sum of all
    element in the fundamental basis generated by the permutations
    `\mu` such that `\mu` is greater than `\sigma`
    for weak order. (greater in the right permutohedron)

    .. MATH::

        \mathcal{E}_\sigma = \sum_{\mu \succeq \sigma} \mathbb{F}_\mu

    EXAMPLES::

        sage: F = FQSym(QQ).F()
        sage: F(E[2,1,3])
        F[2, 1, 3] + F[2, 3, 1] + F[3, 2, 1]

    (See [NCSF-VII]_.)

    TESTS::

        sage: E = FQSym(QQ).E(); E
        The combinatorial Hopf algebra of Free Quasi-Symmetric Functions over the Rational Field on the Elementary basis
        sage: TestSuite(E).run()
    '''
    _prefix = "E"

    def dual_basis(self):
        return self.realization_of().n()

    def product_on_basis(self, e1, e2):
        '''
        TESTS::

            sage: E = FQSym(QQ).E()
            sage: E[1,2] * E[2,1]
            E[1, 2, 4, 3]
            sage: E[3,1,2] * E[3,2,1]
            E[3, 1, 2, 6, 5, 4]
        '''
        if len(e1) == 0:
            return self.monomial(e2)
        return self.monomial(
            self.basis().keys()(list(e1) + [i + max(e1) for i in e2]))

    def build_morphisms(self):
        '''
        TESTS::

            sage: FQS = FQSym(QQ)
            sage: F = FQS.F(); E = FQS.E()
            sage: F(E[3,1,2])
            F[3, 1, 2] + F[3, 2, 1]
            sage: F(E[1,2,3])
            F[1, 2, 3] + F[1, 3, 2] + F[2, 1, 3] + F[2, 3, 1] + F[3, 1, 2] + F[3, 2, 1]
            sage: F(E[3,2,1])
            F[3, 2, 1]
            sage: H = FQS.H()
            sage: E(H[3,1,2])
            E[1, 2, 3] - E[2, 1, 3]
        '''
        morph = lambda F, T, func, tri = None, comp = None: (
            F._module_morphism(func, codomain=T, triangular=tri, cmp=comp)
            if comp is not None else
            F._module_morphism(func, codomain=T, triangular=tri))

        F = self.realization_of().F()
        E = self

        # F <-> E
        E_to_F = morph(E, F,
            lambda sigma: F.sum_of_monomials(sigma.permutohedron_greater()),
            tri="lower")
        E_to_F.register_as_coercion()
        (~E_to_F).register_as_coercion()

