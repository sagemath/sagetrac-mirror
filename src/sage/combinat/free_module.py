# -*- coding: utf-8 -*-
"""
Free modules
"""
#*****************************************************************************
#       Copyright (C) 2007      Mike Hansen <mhansen@gmail.com>,
#                     2007-2009 Nicolas M. Thiery <nthiery at users.sf.net>
#                     2010      Christian Stump <christian.stump@univie.ac.at>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************
from __future__ import print_function
from six.moves import range

from sage.structure.unique_representation import UniqueRepresentation
from sage.structure.parent import Parent
from sage.structure.indexed_generators import IndexedGenerators, parse_indices_names
from sage.modules.module import Module
from sage.misc.misc import repr_lincomb
from sage.rings.all import Integer
from sage.structure.element import parent
from sage.modules.with_basis.indexed_element import IndexedFreeModuleElement
from sage.sets.finite_enumerated_set import FiniteEnumeratedSet
from sage.combinat.cartesian_product import CartesianProduct_iters
from sage.sets.disjoint_union_enumerated_sets import DisjointUnionEnumeratedSets
from sage.misc.cachefunc import cached_method
from sage.misc.lazy_attribute import lazy_attribute
from sage.categories.morphism import SetMorphism
from sage.categories.all import Category, Sets, ModulesWithBasis
from sage.categories.category import JoinCategory
from sage.categories.realizations import Category_realization_of_parent
from sage.categories.tensor import tensor, TensorProductsCategory
import sage.data_structures.blas_dict as blas
from sage.typeset.ascii_art import AsciiArt
from sage.typeset.unicode_art import UnicodeArt
from sage.misc.superseded import deprecation

import six


class CombinatorialFreeModule(UniqueRepresentation, Module, IndexedGenerators):
    r"""
    Class for free modules with a named basis

    INPUT:

    - ``R`` - base ring

    - ``basis_keys`` - list, tuple, family, set, etc. defining the
      indexing set for the basis of this module

    - ``element_class`` - the class of which elements of this module
      should be instances (optional, default None, in which case the
      elements are instances of
      :class:`~sage.modules.with_basis.indexed_element.IndexedFreeModuleElement`)

    - ``category`` - the category in which this module lies (optional,
      default None, in which case use the "category of modules with
      basis" over the base ring ``R``); this should be a subcategory
      of :class:`ModulesWithBasis`

    For the options controlling the printing of elements, see
    :class:`~sage.structure.indexed_generators.IndexedGenerators`.

    .. NOTE::

        These print options may also be accessed and modified using the
        :meth:`print_options` method, after the module has been defined.

    EXAMPLES:

    We construct a free module whose basis is indexed by the letters a, b, c::

        sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])
        sage: F
        Free module generated by {'a', 'b', 'c'} over Rational Field

    Its basis is a family, indexed by a, b, c::

        sage: e = F.basis()
        sage: e
        Finite family {'a': B['a'], 'c': B['c'], 'b': B['b']}

    ::

        sage: [x for x in e]
        [B['a'], B['b'], B['c']]
        sage: [k for k in e.keys()]
        ['a', 'b', 'c']

    Let us construct some elements, and compute with them::

        sage: e['a']
        B['a']
        sage: 2*e['a']
        2*B['a']
        sage: e['a'] + 3*e['b']
        B['a'] + 3*B['b']

    Some uses of
    :meth:`sage.categories.commutative_additive_semigroups.CommutativeAdditiveSemigroups.ParentMethods.summation`
    and :meth:`.sum`::

        sage: F = CombinatorialFreeModule(QQ, [1,2,3,4])
        sage: F.summation(F.monomial(1), F.monomial(3))
        B[1] + B[3]

        sage: F = CombinatorialFreeModule(QQ, [1,2,3,4])
        sage: F.sum(F.monomial(i) for i in [1,2,3])
        B[1] + B[2] + B[3]

    Note that free modules with a given basis and parameters are unique::

        sage: F1 = CombinatorialFreeModule(QQ, (1,2,3,4))
        sage: F1 is F
        True

    The identity of the constructed free module depends on the order of the
    basis and on the other parameters, like the prefix. Note that :class:`CombinatorialFreeModule` is
    a :class:`~sage.structure.unique_representation.UniqueRepresentation`. Hence,
    two combinatorial free modules evaluate equal if and only if they are
    identical::

        sage: F1 = CombinatorialFreeModule(QQ, (1,2,3,4))
        sage: F1 is F
        True
        sage: F1 = CombinatorialFreeModule(QQ, [4,3,2,1])
        sage: F1 == F
        False
        sage: F2 = CombinatorialFreeModule(QQ, [1,2,3,4], prefix='F')
        sage: F2 == F
        False

    Because of this, if you create a free module with certain parameters and
    then modify its prefix or other print options, this affects all modules
    which were defined using the same parameters.
    ::

        sage: F2.print_options(prefix='x')
        sage: F2.prefix()
        'x'
        sage: F3 = CombinatorialFreeModule(QQ, [1,2,3,4], prefix='F')
        sage: F3 is F2   # F3 was defined just like F2
        True
        sage: F3.prefix()
        'x'
        sage: F4 = CombinatorialFreeModule(QQ, [1,2,3,4], prefix='F', bracket=True)
        sage: F4 == F2   # F4 was NOT defined just like F2
        False
        sage: F4.prefix()
        'F'

        sage: F2.print_options(prefix='F') #reset for following doctests

    The constructed module is in the category of modules with basis
    over the base ring::

        sage: CombinatorialFreeModule(QQ, Partitions()).category()
        Category of vector spaces with basis over Rational Field

    If furthermore the index set is finite (i.e. in the category
    ``Sets().Finite()``), then the module is declared as being finite
    dimensional::

        sage: CombinatorialFreeModule(QQ, [1,2,3,4]).category()
        Category of finite dimensional vector spaces with basis over Rational Field
        sage: CombinatorialFreeModule(QQ, Partitions(3),
        ....:                         category=Algebras(QQ).WithBasis()).category()
        Category of finite dimensional algebras with basis over Rational Field

    See :mod:`sage.categories.examples.algebras_with_basis` and
    :mod:`sage.categories.examples.hopf_algebras_with_basis` for
    illustrations of the use of the ``category`` keyword, and see
    :class:`sage.combinat.root_system.weight_space.WeightSpace` for an
    example of the use of ``element_class``.

    Customizing print and LaTeX representations of elements::

        sage: F = CombinatorialFreeModule(QQ, ['a','b'], prefix='x')
        sage: original_print_options = F.print_options()
        sage: sorted(original_print_options.items())
        [('bracket', None),
         ('latex_bracket', False), ('latex_prefix', None),
         ('latex_scalar_mult', None), ('prefix', 'x'),
         ('scalar_mult', '*'),
         ('sorting_key', <function <lambda> at ...>),
         ('sorting_reverse', False), ('string_quotes', True),
         ('tensor_symbol', None)]

        sage: e = F.basis()
        sage: e['a'] - 3 * e['b']
        x['a'] - 3*x['b']

        sage: F.print_options(prefix='x', scalar_mult=' ', bracket='{')
        sage: e['a'] - 3 * e['b']
        x{'a'} - 3 x{'b'}
        sage: latex(e['a'] - 3 * e['b'])
        x_{a} - 3 x_{b}

        sage: F.print_options(latex_prefix='y')
        sage: latex(e['a'] - 3 * e['b'])
        y_{a} - 3  y_{b}

        sage: F.print_options(sorting_reverse=True)
        sage: e['a'] - 3 * e['b']
        -3 x{'b'} + x{'a'}
        sage: F.print_options(**original_print_options) # reset print options

        sage: F = CombinatorialFreeModule(QQ, [(1,2), (3,4)])
        sage: e = F.basis()
        sage: e[(1,2)] - 3 * e[(3,4)]
        B[(1, 2)] - 3*B[(3, 4)]

        sage: F.print_options(bracket=['_{', '}'])
        sage: e[(1,2)] - 3 * e[(3,4)]
        B_{(1, 2)} - 3*B_{(3, 4)}

        sage: F.print_options(prefix='', bracket=False)
        sage: e[(1,2)] - 3 * e[(3,4)]
        (1, 2) - 3*(3, 4)

    TESTS:

    Before :trac:`14054`, combinatorial free modules violated the unique
    parent condition. That caused a problem. The tensor product construction
    involves maps, but maps check that their domain and the parent of a
    to-be-mapped element are identical (not just equal). However, the tensor
    product was cached by a :class:`~sage.misc.cachefunc.cached_method`, which
    involves comparison by equality (not identity). Hence, the last line of
    the following example used to fail with an assertion error::

        sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix="F")
        sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix="G")
        sage: f =   F.monomial(1) + 2 * F.monomial(2)
        sage: g = 2*G.monomial(3) +     G.monomial(4)
        sage: tensor([f, g])
        2*F[1] # G[3] + F[1] # G[4] + 4*F[2] # G[3] + 2*F[2] # G[4]
        sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix='x')
        sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix='y')
        sage: f =   F.monomial(1) + 2 * F.monomial(2)
        sage: g = 2*G.monomial(3) +     G.monomial(4)
        sage: tensor([f, g])
        2*x[1] # y[3] + x[1] # y[4] + 4*x[2] # y[3] + 2*x[2] # y[4]

    We check that we can use the shorthand ``C.<a,b,...> = ...``::

        sage: C.<x,y,z> = CombinatorialFreeModule(QQ)
        sage: C
        Free module generated by {'x', 'y', 'z'} over Rational Field
        sage: a = x - y + 4*z; a
        x - y + 4*z
        sage: a.parent() is C
        True

    TESTS::

        sage: XQ = SchubertPolynomialRing(QQ)
        sage: XZ = SchubertPolynomialRing(ZZ)
        sage: XQ == XZ
        False
        sage: XQ == XQ
        True
    """

    @staticmethod
    def __classcall_private__(cls, base_ring, basis_keys=None, category=None,
                              prefix=None, names=None, **keywords):
        """
        TESTS::

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: G = CombinatorialFreeModule(QQ, ('a','b','c'))
            sage: F is G
            True

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'], latex_bracket=['LEFT', 'RIGHT'])
            sage: F.print_options()['latex_bracket']
            ('LEFT', 'RIGHT')

            sage: F is G
            False

        We check that the category is properly straightened::

            sage: F  = CombinatorialFreeModule(QQ, ['a','b'])
            sage: F1 = CombinatorialFreeModule(QQ, ['a','b'], category = ModulesWithBasis(QQ))
            sage: F2 = CombinatorialFreeModule(QQ, ['a','b'], category = [ModulesWithBasis(QQ)])
            sage: F3 = CombinatorialFreeModule(QQ, ['a','b'], category = (ModulesWithBasis(QQ),))
            sage: F4 = CombinatorialFreeModule(QQ, ['a','b'], category = (ModulesWithBasis(QQ),CommutativeAdditiveSemigroups()))
            sage: F5 = CombinatorialFreeModule(QQ, ['a','b'], category = (ModulesWithBasis(QQ),Category.join((LeftModules(QQ), RightModules(QQ)))))
            sage: F1 is F, F2 is F, F3 is F, F4 is F, F5 is F
            (True, True, True, True, True)

            sage: G  = CombinatorialFreeModule(QQ, ['a','b'], category = AlgebrasWithBasis(QQ))
            sage: F is G
            False
        """
        if isinstance(basis_keys, range):
            basis_keys = tuple(basis_keys)
        if isinstance(basis_keys, (list, tuple)):
            basis_keys = FiniteEnumeratedSet(basis_keys)
        category = ModulesWithBasis(base_ring).or_subcategory(category)
        # bracket or latex_bracket might be lists, so convert
        # them to tuples so that they're hashable.
        bracket = keywords.get('bracket', None)
        if isinstance(bracket, list):
            keywords['bracket'] = tuple(bracket)
        latex_bracket = keywords.get('latex_bracket', None)
        if isinstance(latex_bracket, list):
            keywords['latex_bracket'] = tuple(latex_bracket)

        names, basis_keys, prefix = parse_indices_names(names, basis_keys, prefix, keywords)
        if prefix is None:
            prefix = "B"

        return super(CombinatorialFreeModule, cls).__classcall__(cls,
            base_ring, basis_keys, category=category, prefix=prefix, names=names,
            **keywords)

    # We make this explicitly a Python class so that the methods,
    #   specifically _mul_, from category framework still works. -- TCS
    # We also need to deal with the old pickles too. -- TCS
    Element = IndexedFreeModuleElement

    @lazy_attribute
    def element_class(self):
        """
        The (default) class for the elements of this parent

        Overrides :meth:`Parent.element_class` to force the
        construction of Python class. This is currently needed to
        inherit really all the features from categories, and in
        particular the initialization of ``_mul_`` in
        :meth:`Magmas.ParentMethods.__init_extra__`.

        EXAMPLES::

            sage: A = Algebras(QQ).WithBasis().example(); A
            An example of an algebra with basis: 
            the free algebra on the generators ('a', 'b', 'c') over Rational Field

            sage: A.element_class.mro()
            [<class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category.element_class'>,
             <... 'sage.modules.with_basis.indexed_element.IndexedFreeModuleElement'>,
             ...]
            sage: a,b,c = A.algebra_generators()
            sage: a * b
            B[word: ab]

        TESTS::

            sage: A.__class__.element_class.__module__
            'sage.combinat.free_module'
        """
        return self.__make_element_class__(self.Element,
                                           name="%s.element_class"%self.__class__.__name__,
                                           module=self.__class__.__module__,
                                           inherit=True)

    def __init__(self, R, basis_keys=None, element_class=None, category=None,
                 prefix=None, names=None, **kwds):
        r"""
        TESTS::

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])

            sage: F.category()
            Category of finite dimensional vector spaces with basis over Rational Field

        One may specify the category this module belongs to::

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'], category=AlgebrasWithBasis(QQ))
            sage: F.category()
            Category of finite dimensional algebras with basis over Rational Field

            sage: F = CombinatorialFreeModule(GF(3), ['a','b','c'],
            ....:                             category=(Modules(GF(3)).WithBasis(), Semigroups()))
            sage: F.category()
            Join of Category of finite semigroups
                 and Category of finite dimensional modules with basis over Finite Field of size 3
                 and Category of vector spaces with basis over Finite Field of size 3

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'], category = FiniteDimensionalModulesWithBasis(QQ))
            sage: F.basis()
            Finite family {'a': B['a'], 'c': B['c'], 'b': B['b']}
            sage: F.category()
            Category of finite dimensional vector spaces with basis over Rational Field

            sage: TestSuite(F).run()

        TESTS:

        Regression test for :trac:`10127`: ``self._indices`` needs to be
        set early enough, in case the initialization of the categories
        use ``self.basis().keys()``. This occured on several occasions
        in non trivial constructions. In the following example,
        :class:`AlgebrasWithBasis` constructs ``Homset(self,self)`` to
        extend by bilinearity method ``product_on_basis``, which in
        turn triggers ``self._repr_()``::

            sage: class MyAlgebra(CombinatorialFreeModule):
            ....:     def _repr_(self):
            ....:         return "MyAlgebra on %s"%(self.basis().keys())
            ....:     def product_on_basis(self,i,j):
            ....:         pass
            sage: MyAlgebra(ZZ, ZZ, category = AlgebrasWithBasis(QQ))
            MyAlgebra on Integer Ring

        A simpler example would be welcome!

        We check that unknown options are caught::

            sage: CombinatorialFreeModule(ZZ, [1,2,3], keyy=2)
            Traceback (most recent call last):
            ...
            ValueError: keyy is not a valid print option.
        """
        #Make sure R is a ring with unit element
        from sage.categories.all import Rings
        if R not in Rings():
            raise TypeError("argument R must be a ring")

        if element_class is not None:
            self.Element = element_class

        # The following is to ensure that basis keys is indeed a parent.
        # tuple/list are converted to FiniteEnumeratedSet and set/frozenset to
        # Set
        # (e.g. root systems passes lists)
        basis_keys = Sets()(basis_keys, enumerated_set=True)

        # This is needed for the Cartesian product
        # TODO: Remove this duplication from __classcall_private__
        names, basis_keys, prefix = parse_indices_names(names, basis_keys, prefix, kwds)
        if prefix is None:
            prefix = "B"

        # ignore the optional 'key' since it only affects CachedRepresentation
        kwds.pop('key', None)
        if 'monomial_key' in kwds:
            kwds['sorting_key'] = kwds.pop('monomial_key')
        if 'monomial_reverse' in kwds:
            kwds['sorting_reverse'] = kwds.pop('monomial_reverse')
        IndexedGenerators.__init__(self, basis_keys, prefix, **kwds)

        if category is None:
            category = ModulesWithBasis(R)
        elif isinstance(category, tuple):
            category = Category.join(category)
        if basis_keys in Sets().Finite():
            category = category.FiniteDimensional()

        Parent.__init__(self, base=R, category=category, names=names)

        self._order = None

    # For backwards compatibility
    _repr_term = IndexedGenerators._repr_generator
    _latex_term = IndexedGenerators._latex_generator

    def _ascii_art_term(self, m):
        r"""
        Return an ascii art representation of the term indexed by ``m``.

        TESTS::

            sage: R = NonCommutativeSymmetricFunctions(QQ).R()
            sage: ascii_art(R.one())  # indirect doctest
            1
        """
        try:
            if m == self.one_basis():
                return AsciiArt(["1"])
        except Exception:
            pass
        return IndexedGenerators._ascii_art_generator(self, m)

    def _unicode_art_term(self, m):
        r"""
        Return an unicode art representation of the term indexed by ``m``.

        TESTS::

            sage: R = NonCommutativeSymmetricFunctions(QQ).R()
            sage: unicode_art(R.one())  # indirect doctest
            1
        """
        from sage.typeset.unicode_art import UnicodeArt
        try:
            if m == self.one_basis():
                return UnicodeArt(["1"])
        except Exception:
            pass
        return IndexedGenerators._unicode_art_generator(self, m)

    # mostly for backward compatibility
    @lazy_attribute
    def _element_class(self):
        """
        TESTS::

            sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: F._element_class
            <class 'sage.combinat.free_module.CombinatorialFreeModule_with_category.element_class'>
        """
        return self.element_class

    def _an_element_(self):
        """
        EXAMPLES::

            sage: CombinatorialFreeModule(QQ, ("a", "b", "c")).an_element()
            2*B['a'] + 2*B['b'] + 3*B['c']
            sage: CombinatorialFreeModule(QQ, ("a", "b", "c"))._an_element_()
            2*B['a'] + 2*B['b'] + 3*B['c']
            sage: CombinatorialFreeModule(QQ, ()).an_element()
            0
            sage: CombinatorialFreeModule(QQ, ZZ).an_element()
            3*B[-1] + B[0] + 3*B[1]
            sage: CombinatorialFreeModule(QQ, RR).an_element()
            B[1.00000000000000]
        """
        # Try a couple heuristics to build a not completely trivial
        # element, while handling cases where R.an_element is not
        # implemented, or R has no iterator, or R has few elements.
        x = self.zero()
        I = self.basis().keys()
        R = self.base_ring()
        try:
            x = x + self.monomial(I.an_element())
        except Exception:
            pass
        try:
            g = iter(self.basis().keys())
            for c in range(1,4):
                x = x + self.term(next(g), R(c))
        except Exception:
            pass
        return x

    # What semantic do we want for containment?
    # Accepting anything that can be coerced is not reasonable, especially
    # if we allow coercion from the enumerated set.
    # Accepting anything that can be converted is an option, but that would
    # be expensive. So far, x in self if x.parent() == self

    def __contains__(self, x):
        """
        TESTS::

            sage: F = CombinatorialFreeModule(QQ,["a", "b"])
            sage: G = CombinatorialFreeModule(ZZ,["a", "b"])
            sage: F.monomial("a") in F
            True
            sage: G.monomial("a") in F
            False
            sage: "a" in F
            False
            sage: 5/3 in F
            False
        """
        return parent(x) == self # is self?

    def _element_constructor_(self, x):
        """
        Convert ``x`` into ``self``.

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ,["a", "b"])
            sage: F(F.monomial("a"))   # indirect doctest
            B['a']

        Do not rely on the following feature which may be removed in the future::

            sage: QS3 = SymmetricGroupAlgebra(QQ,3)
            sage: QS3([2,3,1])     # indirect doctest
            [2, 3, 1]

        instead, use::

            sage: P = QS3.basis().keys()
            sage: QS3.monomial(P([2,3,1]))   # indirect doctest
            [2, 3, 1]

        or:
            sage: B = QS3.basis()
            sage: B[P([2,3,1])]
            [2, 3, 1]

        TODO: The symmetric group algebra (and in general,
        combinatorial free modules on word-like object could instead
        provide an appropriate short-hand syntax QS3[2,3,1]).

        Rationale: this conversion is ambiguous in situations like::

            sage: F = CombinatorialFreeModule(QQ,[0,1])

        Is ``0`` the zero of the base ring, or the index of a basis
        element?  I.e. should the result be ``0`` or ``B[0]``?

            sage: F = CombinatorialFreeModule(QQ,[0,1])
            sage: F(0) # this feature may eventually disappear
            0
            sage: F(1)
            Traceback (most recent call last):
            ...
            TypeError: do not know how to make x (= 1) an element of Free module generated by ... over Rational Field

        It is preferable not to rely either on the above, and instead, use::

            sage: F.zero()
            0

        Note that, on the other hand, conversions from the ground ring
        are systematically defined (and mathematically meaningful) for
        algebras.

        Conversions between distinct free modules are not allowed any
        more::

            sage: F = CombinatorialFreeModule(ZZ, ["a", "b"]);      F.rename("F")
            sage: G = CombinatorialFreeModule(QQ, ["a", "b"]);      G.rename("G")
            sage: H = CombinatorialFreeModule(ZZ, ["a", "b", "c"]); H.rename("H")
            sage: G(F.monomial("a"))
            Traceback (most recent call last):
            ...
            TypeError: do not know how to make x (= B['a']) an element of self (=G)
            sage: H(F.monomial("a"))
            Traceback (most recent call last):
            ...
            TypeError: do not know how to make x (= B['a']) an element of self (=H)

        Here is a real life example illustrating that this yielded
        mathematically wrong results::

            sage: S = SymmetricFunctions(QQ)
            sage: s = S.s(); p = S.p()
            sage: ss = tensor([s,s]); pp = tensor([p,p])
            sage: a = tensor((s[2],s[2]))

        The following originally used to yield ``p[[2]] # p[[2]]``, and if
        there was no natural coercion between ``s`` and ``p``, this would
        raise a ``NotImplementedError``. Since :trac:`15305`, this takes the
        coercion between ``s`` and ``p`` and lifts it to the tensor product. ::

            sage: pp(a)
            1/4*p[1, 1] # p[1, 1] + 1/4*p[1, 1] # p[2] + 1/4*p[2] # p[1, 1] + 1/4*p[2] # p[2]

        Extensions of the ground ring should probably be reintroduced
        at some point, but via coercions, and with stronger sanity
        checks (ensuring that the codomain is really obtained by
        extending the scalar of the domain; checking that they share
        the same class is not sufficient).

        TESTS:

        Conversion from the ground ring is implemented for algebras::

            sage: QS3 = SymmetricGroupAlgebra(QQ,3)
            sage: QS3(2)
            2*[1, 2, 3]
        """
        R = self.base_ring()

        #Coerce ints to Integers
        if isinstance(x, int):
            x = Integer(x)

        if x in R:
            if x == 0:
                return self.zero()
            else:
                raise TypeError("do not know how to make x (= %s) an element of %s"%(x, self))
        #x is an element of the basis enumerated set;
        # This is a very ugly way of testing this
        elif ((hasattr(self._indices, 'element_class') and
               isinstance(self._indices.element_class, type) and
               isinstance(x, self._indices.element_class))
              or (parent(x) == self._indices)):
            return self.monomial(x)
        elif x in self._indices:
            return self.monomial(self._indices(x))
        else:
            if hasattr(self, '_coerce_end'):
                try:
                    return self._coerce_end(x)
                except TypeError:
                    pass
            raise TypeError("do not know how to make x (= %s) an element of self (=%s)"%(x,self))

    def _convert_map_from_(self, S):
        """
        Implement the conversion from formal sums.

        EXAMPLES::

            sage: E = CombinatorialFreeModule(QQ, ["a", "b", "c"])
            sage: f = FormalSum([[2, "a"], [3, "b"]]); f
            2*a + 3*b
            sage: E._convert_map_from_(f.parent())
            Generic morphism:
              From: Abelian Group of all Formal Finite Sums over Integer Ring
              To:   Free module generated by {'a', 'b', 'c'} over Rational Field
            sage: E(f)
            2*B['a'] + 3*B['b']

            sage: E._convert_map_from_(ZZ)
        """
        from sage.structure.formal_sum import FormalSums
        K = self.base_ring()
        if isinstance(S, FormalSums) and K.has_coerce_map_from(S.base_ring()):
            G = self.basis().keys()
            return SetMorphism(S.Hom(self, category=self.category() | S.category()),
                               lambda x: self.sum_of_terms( (G(g), K(c)) for c,g in x ))

    def _an_element_impl(self): # TODO: REMOVE?
        """
        Return an element of ``self``, namely the zero element.

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F._an_element_impl()
            0
            sage: _.parent() is F
            True
        """
        return self.element_class(self, {})

    def _first_ngens(self, n):
        """
        Used by the preparser for ``F.<x> = ...``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ZZ)
            sage: C._first_ngens(3)
            (B[0], B[1], B[-1])

            sage: R.<x,y> = FreeAlgebra(QQ, 2)
            sage: x,y
            (x, y)
        """
        try:
            # Try gens first for compatibility with classes that
            #   rely on this (e.g., FreeAlgebra)
            return tuple(self.gens())[:n]
        except (AttributeError, ValueError, TypeError):
            pass
        B = self.basis()
        it = iter(self._indices)
        return tuple(B[next(it)] for i in range(n))

    def dimension(self):
        """
        Return the dimension of the free module (which is given
        by the number of elements in the basis).

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.dimension()
            3
            sage: F.basis().cardinality()
            3
            sage: F.basis().keys().cardinality()
            3

        Rank is available as a synonym::

            sage: F.rank()
            3

        ::

            sage: s = SymmetricFunctions(QQ).schur()
            sage: s.dimension()
            +Infinity
        """
        return self._indices.cardinality()

    rank = dimension

    def is_exact(self):
        r"""
        Return ``True`` if elements of ``self`` have exact representations,
        which is true of ``self`` if and only if it is true of
        ``self.basis().keys()`` and ``self.base_ring()``.

        EXAMPLES::

            sage: GroupAlgebra(GL(3, GF(7))).is_exact()
            True
            sage: GroupAlgebra(GL(3, GF(7)), RR).is_exact()
            False
            sage: GroupAlgebra(GL(3, pAdicRing(7))).is_exact() # not implemented correctly (not my fault)!
            False
        """
        # The index set may not have a check for exactness
        # Assume the index set is exact if we cannot check
        try:
            if not self.basis().keys().is_exact():
                return False
        except AttributeError:
            pass
        return self.base_ring().is_exact()

    def set_order(self, order):
        """
        Set the order of the elements of the basis.

        If :meth:`set_order` has not been called, then the ordering is
        the one used in the generation of the elements of self's
        associated enumerated set.

        .. WARNING::

            Many cached methods depend on this order, in
            particular for constructing subspaces and quotients.
            Changing the order after some computations have been
            cached does not invalidate the cache, and is likely to
            introduce inconsistencies.

        EXAMPLES::

            sage: QS2 = SymmetricGroupAlgebra(QQ,2)
            sage: b = list(QS2.basis().keys())
            sage: b.reverse()
            sage: QS2.set_order(b)
            sage: QS2.get_order()
            [[2, 1], [1, 2]]
        """
        self._order = order
        from sage.combinat.ranker import rank_from_list
        self._rank_basis = rank_from_list(self._order)

    @cached_method
    def get_order(self):
        """
        Return the order of the elements in the basis.

        EXAMPLES::

            sage: QS2 = SymmetricGroupAlgebra(QQ,2)
            sage: QS2.get_order()                    # note: order changed on 2009-03-13
            [[2, 1], [1, 2]]
        """
        if self._order is None:
            self.set_order(self.basis().keys().list())
        return self._order

    def get_order_cmp(self):
        """
        Return a comparison function on the basis indices that is
        compatible with the current term order.

        DEPRECATED by :trac:`24548`.

        EXAMPLES::

            sage: A = FiniteDimensionalAlgebrasWithBasis(QQ).example()
            sage: Acmp = A.get_order_cmp()
            doctest:warning...:
            DeprecationWarning: comparison should use keys
            See http://trac.sagemath.org/24548 for details.

            sage: sorted(A.basis().keys(), Acmp)
            ['x', 'y', 'a', 'b']
            sage: A.set_order(list(reversed(A.basis().keys())))
            sage: Acmp = A.get_order_cmp()
            sage: sorted(A.basis().keys(), Acmp)
            ['b', 'a', 'y', 'x']
        """
        deprecation(24548, 'comparison should use keys')
        self.get_order()
        return self._order_cmp

    def _order_cmp(self, x, y):
        """
        Compare `x` and `y` w.r.t. the term order.

        DEPRECATED by :trac:`24548`.

        INPUT:

        - ``x``, ``y`` -- indices of the basis of ``self``

        OUTPUT:

        `-1`, `0`, or `1` depending on whether `x<y`, `x==y`, or `x>y`
        w.r.t. the term order.

        EXAMPLES::

            sage: A = CombinatorialFreeModule(QQ, ['x','y','a','b'])
            sage: A.set_order(['x', 'y', 'a', 'b'])
            sage: A._order_cmp('x', 'y')
            doctest:warning...:
            DeprecationWarning: comparison should use keys
            See http://trac.sagemath.org/24548 for details.
            -1
            sage: A._order_cmp('y', 'y')
            0
            sage: A._order_cmp('a', 'y')
            1
        """
        deprecation(24548, 'comparison should use keys')
        ix = self._rank_basis(x)
        iy = self._rank_basis(y)
        if ix < iy:
            return -1
        elif ix > iy:
            return 1
        else:
            return 0

    def get_order_key(self):
        """
        Return a comparison key on the basis indices that is
        compatible with the current term order.

        EXAMPLES::

            sage: A = FiniteDimensionalAlgebrasWithBasis(QQ).example()
            sage: A.set_order(['x', 'y', 'a', 'b'])
            sage: Akey = A.get_order_key()
            sage: sorted(A.basis().keys(), key=Akey)
            ['x', 'y', 'a', 'b']
            sage: A.set_order(list(reversed(A.basis().keys())))
            sage: Akey = A.get_order_key()
            sage: sorted(A.basis().keys(), key=Akey)
            ['b', 'a', 'y', 'x']
        """
        self.get_order()
        return self._order_key

    def _order_key(self, x):
        """
        Return a key for `x` compatible with the term order.

        INPUT:

        - ``x`` -- indices of the basis of ``self``

        EXAMPLES::

            sage: A = CombinatorialFreeModule(QQ, ['x','y','a','b'])
            sage: A.set_order(['x', 'y', 'a', 'b'])
            sage: A._order_key('x')
            0
            sage: A._order_key('y')
            1
            sage: A._order_key('a')
            2
        """
        return self._rank_basis(x)

    def from_vector(self, vector):
        """
        Build an element of ``self`` from a (sparse) vector.

        .. SEEALSO:: :meth:`get_order`, :meth:`CombinatorialFreeModule.Element._vector_`

        EXAMPLES::

            sage: QS3 = SymmetricGroupAlgebra(QQ, 3)
            sage: b = QS3.from_vector(vector((2, 0, 0, 0, 0, 4))); b
            2*[1, 2, 3] + 4*[3, 2, 1]
            sage: a = 2*QS3([1,2,3])+4*QS3([3,2,1])
            sage: a == b
            True
        """
        cc = self.get_order()
        return self._from_dict({cc[index]: coeff for (index,coeff) in six.iteritems(vector)})

    def sum(self, iter_of_elements):
        """
        Return the sum of all elements in ``iter_of_elements``.

        Overrides method inherited from commutative additive monoid as it
        is much faster on dicts directly.

        INPUT:

        - ``iter_of_elements`` -- iterator of elements of ``self``

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ,[1,2])
            sage: f = F.an_element(); f
            2*B[1] + 2*B[2]
            sage: F.sum( f for _ in range(5) )
            10*B[1] + 10*B[2]
        """
        D = blas.sum(element._monomial_coefficients for element in iter_of_elements)
        return self._from_dict(D, remove_zeros=False)

    def linear_combination(self, iter_of_elements_coeff, factor_on_left=True):
        """
        Return the linear combination `\lambda_1 v_1 + \cdots +
        \lambda_k v_k` (resp.  the linear combination `v_1 \lambda_1 +
        \cdots + v_k \lambda_k`) where ``iter_of_elements_coeff`` iterates
        through the sequence `((\lambda_1, v_1), ..., (\lambda_k, v_k))`.

        INPUT:

        - ``iter_of_elements_coeff`` -- iterator of pairs ``(element, coeff)``
          with ``element`` in ``self`` and ``coeff`` in ``self.base_ring()``

        - ``factor_on_left`` -- (optional) if ``True``, the coefficients are
          multiplied from the left if ``False``, the coefficients are
          multiplied from the right

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ,[1,2])
            sage: f = F.an_element(); f
            2*B[1] + 2*B[2]
            sage: F.linear_combination( (f,i) for i in range(5) )
            20*B[1] + 20*B[2]
        """
        return self._from_dict(blas.linear_combination( ((element._monomial_coefficients, coeff)
                                                        for element, coeff in iter_of_elements_coeff),
                                                        factor_on_left=factor_on_left ),
                               remove_zeros=False)

    def term(self, index, coeff=None):
        """
        Construct a term in ``self``.

        INPUT:

        - ``index`` -- the index of a basis element
        - ``coeff`` -- an element of the coefficient ring (default: one)

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.term('a',3)
            3*B['a']
            sage: F.term('a')
            B['a']

        Design: should this do coercion on the coefficient ring?
        """
        if coeff is None:
            coeff = self.base_ring().one()
        return self._from_dict({index: coeff})

    def _monomial(self, index):
        """
        TESTS::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F._monomial('a')
            B['a']
        """
        return self._from_dict({index: self.base_ring().one()}, remove_zeros=False)

    @lazy_attribute
    def monomial(self):
        """
        Return the basis element indexed by ``i``.

        INPUT:

        - ``i`` -- an element of the index set

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.monomial('a')
            B['a']

        ``F.monomial`` is in fact (almost) a map::

            sage: F.monomial
            Term map from {'a', 'b', 'c'} to Free module generated by {'a', 'b', 'c'} over Rational Field
        """
        # Should use a real Map, as soon as combinatorial_classes are enumerated sets, and therefore parents
        from sage.categories.poor_man_map import PoorManMap
        return PoorManMap(self._monomial, domain=self._indices, codomain=self, name="Term map")

    def sum_of_terms(self, terms, distinct=False):
        """
        Construct a sum of terms of ``self``.

        INPUT:

        - ``terms`` -- a list (or iterable) of pairs ``(index, coeff)``
        - ``distinct`` -- (default: ``False``) whether the indices are
          guaranteed to be distinct

        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.sum_of_terms([('a',2), ('c',3)])
            2*B['a'] + 3*B['c']

        If ``distinct`` is True, then the construction is optimized::

            sage: F.sum_of_terms([('a',2), ('c',3)], distinct = True)
            2*B['a'] + 3*B['c']

        .. WARNING::

            Use ``distinct=True`` only if you are sure that the
            indices are indeed distinct::

                sage: F.sum_of_terms([('a',2), ('a',3)], distinct = True)
                3*B['a']

        Extreme case::

            sage: F.sum_of_terms([])
            0
        """
        if distinct:
            return self._from_dict(dict(terms))
        return self.sum(self.term(index, coeff) for (index, coeff) in terms)

    @cached_method
    def zero(self):
        """
        EXAMPLES::

            sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])
            sage: F.zero()
            0
        """
        return self._from_dict({}, remove_zeros=False)

    def _from_dict(self, d, coerce=False, remove_zeros=True):
        r"""
        Construct an element of ``self`` from an ``{index: coefficient}``
        dictionary.

        INPUT:

        - ``d`` -- a dictionary ``{index: coeff}`` where each ``index`` is
          the index of a basis element and each ``coeff`` belongs to the
          coefficient ring ``self.base_ring()``

        - ``coerce`` -- a boolean (default: ``False``), whether to coerce
          the coefficients ``coeff`` to the coefficient ring

        - ``remove_zeros`` -- a boolean (default: ``True``), if some
          coefficients ``coeff`` may be zero and should therefore be removed

        EXAMPLES::

            sage: e = SymmetricFunctions(QQ).elementary()
            sage: s = SymmetricFunctions(QQ).schur()
            sage: a = e([2,1]) + e([1,1,1]); a
            e[1, 1, 1] + e[2, 1]
            sage: s._from_dict(a.monomial_coefficients())
            s[1, 1, 1] + s[2, 1]

        If the optional argument ``coerce`` is ``True``, then the
        coefficients are coerced into the base ring of ``self``::

            sage: part = Partition([2,1])
            sage: d = {part:1}
            sage: a = s._from_dict(d,coerce=True); a
            s[2, 1]
            sage: a.coefficient(part).parent()
            Rational Field

        With ``remove_zeros=True``, zero coefficients are removed::

            sage: s._from_dict({part:0})
            0

        .. WARNING::

            With ``remove_zeros=True``, it is assumed that no
            coefficient of the dictionary is zero. Otherwise, this may
            lead to illegal results::

                sage: list(s._from_dict({part:0}, remove_zeros=False))
                [([2, 1], 0)]
        """
        assert isinstance(d, dict)
        if coerce:
            R = self.base_ring()
            d = {key: R(coeff) for key,coeff in six.iteritems(d)}
        if remove_zeros:
            d = {key: coeff for key, coeff in six.iteritems(d) if coeff}
        return self.element_class( self, d )

    @cached_method
    def tensor_unit(self, category = None, **keywords):
        if not category:
            category = self.category()
        return TensorUnit(category=category.TensorProducts(), **keywords)

class CombinatorialFreeModuleElement(CombinatorialFreeModule.Element):
    """
    Deprecated. Use
    :class:`sage.modules.with_basis.indexed_element.IndexedFreeModuleElement`
    or :class:`CombinatorialFreeModule.Element` instead.
    """
    def __init__(self, *args, **kwds):
        """
        TESTS::

            sage: from sage.combinat.free_module import CombinatorialFreeModuleElement
            sage: class Test(CombinatorialFreeModule):
            ....:     class Element(CombinatorialFreeModuleElement):
            ....:         pass
            sage: T = Test(QQ, (1,2))
            sage: T.an_element()
            doctest:warning
            ...
            DeprecationWarning: CombinatorialFreeModuleElement is deprecated.
             Use IndexedFreeModuleElement or CombinatorialFreeModule.Element instead.
            See http://trac.sagemath.org/22632 for details.
            2*B[1] + 2*B[2]
        """
        from sage.misc.superseded import deprecation
        deprecation(22632, "CombinatorialFreeModuleElement is deprecated."
                           " Use IndexedFreeModuleElement"
                           " or CombinatorialFreeModule.Element instead.")
        super(CombinatorialFreeModuleElement, self).__init__(*args, **kwds)


class CombinatorialFreeModule_Tensor(CombinatorialFreeModule):
        """
        Tensor Product of Free Modules

        This class should not be constructed directly.
        Please use `tensor`.

        EXAMPLES:

        We construct two free modules, assign them short names, and construct their tensor product::

            sage: F = CombinatorialFreeModule(ZZ, [1,2]); F.__custom_name = "F"
            sage: G = CombinatorialFreeModule(ZZ, [3,4]); G.__custom_name = "G"
            sage: T = tensor([F, G]); T
            F # G

            sage: T.category()
            Category of finite dimensional tensor products of modules with basis over Integer Ring

            sage: T.construction() # todo: not implemented
            [tensor, ]

        T is a free module, with same base ring as F and G::

            sage: T.base_ring()
            Integer Ring

        The basis of T is indexed by tuples of basis indices of F and G::

            sage: T.basis().keys()
            Image of Cartesian product of {1, 2}, {3, 4} by <... 'tuple'>
            sage: T.basis().keys().list()
            [(1, 3), (1, 4), (2, 3), (2, 4)]

        FIXME: Should elements of a CartesianProduct be tuples (making them hashable)? M.S. votes: Yes!

        Here are the basis elements themselves::

            sage: T.basis().cardinality()
            4
            sage: list(T.basis())
            [B[1] # B[3], B[1] # B[4], B[2] # B[3], B[2] # B[4]]

        The tensor product is associative and flattens sub tensor products::

            sage: H = CombinatorialFreeModule(ZZ, [5,6]); H.rename("H")
            sage: tensor([F, tensor([G, H])])
            F # G # H
            sage: tensor([tensor([F, G]), H])
            F # G # H
            sage: tensor([F, G, H])
            F # G # H

        We now compute the tensor product of elements of free modules::

            sage: f =   F.monomial(1) + 2 * F.monomial(2)
            sage: g = 2*G.monomial(3) +     G.monomial(4)
            sage: h =   H.monomial(5) +     H.monomial(6)
            sage: tensor([f, g])
            2*B[1] # B[3] + B[1] # B[4] + 4*B[2] # B[3] + 2*B[2] # B[4]

        Again, the tensor product is associative on elements::

            sage: tensor([f, tensor([g, h])]) == tensor([f, g, h])
            True
            sage: tensor([tensor([f, g]), h]) == tensor([f, g, h])
            True

        Note further that the tensor product spaces need not preexist::

            sage: t = tensor([f, g, h])
            sage: t.parent()
            F # G # H


        TESTS::

            sage: tensor([tensor([F, G]), H]) == tensor([F, G, H])
            True
            sage: tensor([F, tensor([G, H])]) == tensor([F, G, H])
            True

        Implementation notes:

        Tensor products are implemented for free modules with distinguished basis over a commutative ring `R`.
        They are implemented as modules with basis with index set given by tuples
        of the index sets of the tensor factors. They are automatically flattened so that there is no
        nesting of tensor products.

        Although the one-fold tensor product::

            sage: M = CombinatorialFreeModule(ZZ, [1,2])
            sage: T1M = tensor([M])
            sage: T1M == M
            False

        of a module is isomorphic to the module, they are different to the code: the category of the one-fold
        tensor is a subclass of ModulesWithBasis(R).TensorProducts() since it was created by the tensor construction,
        whereas the original module has category subclassing ModulesWithBasis(R).

        Mathematically there is a zero-fold tensor product which is the unit object in the tensor category.
        It is the base ring `R` viewed as a free module over itself. It is implemented as a special free
        module of rank 1::

            sage: MR = M.tensor_unit()
            sage: T1M == tensor([M, MR])
            True

        """
        @staticmethod
        def __classcall_private__(cls, modules, category, **options):
            """
            TESTS::

                sage: F = CombinatorialFreeModule(ZZ, [1,2])
                sage: G = CombinatorialFreeModule(ZZ, [3,4])
                sage: H = CombinatorialFreeModule(ZZ, [4])
                sage: tensor([tensor([F, G]), H]) == tensor([F, G, H])
                True
                sage: tensor([F, tensor([G, H])]) == tensor([F, G, H])
                True
                sage: U = F.tensor_unit()
                sage: tensor([U, G, U, F]) == tensor([G,F])
                True
                sage: U == tensor([U,U])
                True

            Check that :trac:`19608` is fixed::

                sage: T = tensor([F, G, H])
                sage: T in Modules(ZZ).FiniteDimensional()
                True
            """
            # category should be a subcategory of a tensor category
            # this code finds the first tensor category in a join and returns its base category
            base_category = None
            if isinstance(category, Category_realization_of_parent):
                category = category.base()
            if isinstance(category, JoinCategory):
                for supercategory in category.super_categories():
                    if isinstance(supercategory, TensorProductsCategory):
                        base_category = supercategory.base_category()
                        break
            elif isinstance(category, TensorProductsCategory):
                base_category = category.base_category()
            if base_category is None:
                raise TypeError("category (%s) should be a subcategory of tensor products of modules"%category)
            R = base_category.base_ring()
            if modules:
                tensor_unit = modules[0].tensor_unit(category=base_category)
                # TODO: need more accurate check for tensor units; this won't match if category disagrees
                modules = [module for module in modules if module != tensor_unit]
                if not modules:
                    return tensor_unit
                # flatten the tensor product
                modules = sum((module._sets
                              if isinstance(module, CombinatorialFreeModule_Tensor)
                              else (module,)
                              for module in modules), ())
            if all('FiniteDimensional' in M.category().axioms() for M in modules):
                category = category.FiniteDimensional()
            return super(CombinatorialFreeModule_Tensor, cls).__classcall__(cls,
                                                    modules, category, **options)

        def __init__(self, modules, category, **options):
            """
            TESTS::

                sage: F = CombinatorialFreeModule(ZZ, [1,2]); F
                F
                sage: tensor([F,F])
                F # F

            """
            from sage.categories.tensor import tensor
            # save the flattened tensor factors
            self._sets = modules
            base_category = None
            if isinstance(category, JoinCategory):
                for supercategory in category.super_categories():
                    if isinstance(supercategory, TensorProductsCategory):
                        if base_category is None:
                            base_category = supercategory.base_category()
                        else:
                            base_category = Category.join((base_category, supercategory.base_category()))
            elif isinstance(category, TensorProductsCategory):
                base_category = category.base_category()
            if base_category is None:
                raise TypeError("category (%s) should be a subcategory of tensor products of modules"%category)
            R = base_category.base_ring()
            category = Category.join((category,ModulesWithBasis(R)))
            CombinatorialFreeModule.__init__(self, R, CartesianProduct_iters(*[module.basis().keys() for module in modules]).map(tuple), category=category, **options)

            # the following is not the best option, but it's better than nothing.
            self._print_options['tensor_symbol'] = options.get('tensor_symbol', tensor.symbol)

        def _repr_(self):
            """
            This is customizable by setting
            ``self.print_options('tensor_symbol'=...)``.

            TESTS::

                sage: F = CombinatorialFreeModule(ZZ, [1,2,3])
                sage: G = CombinatorialFreeModule(ZZ, [1,2,3,8])
                sage: F.rename("F")
                sage: tensor([F])
                F
                sage: G.rename("G")
                sage: T = tensor([F, G])
                sage: T # indirect doctest
                F # G
                sage: T.print_options(tensor_symbol= ' @ ')  # note the spaces
                sage: T # indirect doctest
                F @ G

            To avoid a side\--effect on another doctest, we revert the change::

                sage: T.print_options(tensor_symbol= ' # ')
            """
            from sage.categories.tensor import tensor
            if hasattr(self, "_print_options"):
                symb = self._print_options['tensor_symbol']
                if symb is None:
                    symb = tensor.symbol
            else:
                symb = tensor.symbol
            return symb.join(["%s"%module for module in self._sets])
            # TODO: make this overridable by setting _name

        def _ascii_art_(self, term):
            """
            TESTS::

                sage: R = NonCommutativeSymmetricFunctions(QQ).R()
                sage: Partitions.options(diagram_str="#", convention="french")
                sage: ascii_art(tensor((R[1,2], R[3,1,2])))
                R   # R
                 #     ###
                 ##      #
                         ##
            """
            if hasattr(self, "_print_options"):
                symb = self._print_options['tensor_symbol']
                if symb is None:
                    symb = tensor.symbol
            else:
                symb = tensor.symbol
            it = iter(zip(self._sets, term))
            module, t = next(it)
            rpr = module._ascii_art_term(t)
            for (module,t) in it:
                rpr += AsciiArt([symb], [len(symb)])
                rpr += module._ascii_art_term(t)
            return rpr

        _ascii_art_term = _ascii_art_

        def _unicode_art_(self, term):
            """
            TESTS::

                sage: R = NonCommutativeSymmetricFunctions(QQ).R()
                sage: Partitions.options(diagram_str="#", convention="french")
                sage: unicode_art(tensor((R[1,2], R[3,1,2])))
                R    # R
                      
                     
                       
                          
            """
            if hasattr(self, "_print_options"):
                symb = self._print_options['tensor_symbol']
                if symb is None:
                    symb = tensor.symbol
            else:
                symb = tensor.symbol
            it = iter(zip(self._sets, term))
            module, t = next(it)
            rpr = module._unicode_art_term(t)
            for (module, t) in it:
                rpr += UnicodeArt([symb], [len(symb)])
                rpr += module._unicode_art_term(t)
            return rpr

        _unicode_art_term = _unicode_art_

        def _latex_(self):
            """
            TESTS::

                sage: F = CombinatorialFreeModule(ZZ, [1,2,3])
                sage: G = CombinatorialFreeModule(ZZ, [1,2,3,8])
                sage: F.rename("F")
                sage: G.rename("G")
                sage: latex(tensor([F, F, G])) # indirect doctest
                \text{\texttt{F}} \otimes \text{\texttt{F}} \otimes \text{\texttt{G}}
                sage: F._latex_ = lambda : "F"
                sage: G._latex_ = lambda : "G"
                sage: latex(tensor([F, F, G])) # indirect doctest
                F \otimes F \otimes G
            """
            from sage.misc.latex import latex
            symb = " \\otimes "
            return symb.join(["%s"%latex(module) for module in self._sets])

        def _repr_term(self, term):
            """
            TESTS::

                sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix="F")
                sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix="G")
                sage: f =   F.monomial(1) + 2 * F.monomial(2)
                sage: g = 2*G.monomial(3) +     G.monomial(4)
                sage: tensor([f, g]) # indirect doctest
                2*F[1] # G[3] + F[1] # G[4] + 4*F[2] # G[3] + 2*F[2] # G[4]
            """
            if hasattr(self, "_print_options"):
                symb = self._print_options['tensor_symbol']
                if symb is None:
                    symb = tensor.symbol
            else:
                symb = tensor.symbol
            return symb.join(module._repr_term(t) for (module, t) in zip(self._sets, term))

        def _latex_term(self, term):
            """
            TESTS::

                sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix='x')
                sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix='y')
                sage: f =   F.monomial(1) + 2 * F.monomial(2)
                sage: g = 2*G.monomial(3) +     G.monomial(4)
                sage: latex(tensor([f, g])) # indirect doctest
                2x_{1} \otimes y_{3} + x_{1} \otimes y_{4} + 4x_{2} \otimes y_{3} + 2x_{2} \otimes y_{4}
            """
            symb = " \\otimes "
            return symb.join(module._latex_term(t) for (module, t) in zip(self._sets, term))

        @cached_method
        def tensor_constructor(self, modules, **keywords):
            r"""
            INPUT:

             - ``modules`` -- a tuple `(F_1,\dots,F_n)` of
               free modules whose tensor product is self

            Returns the canonical multilinear morphism from
            `F_1 \times \dots \times F_n` to `F_1 \otimes \dots \otimes F_n`

            EXAMPLES::

                sage: F = CombinatorialFreeModule(ZZ, [1,2]); F.__custom_name = "F"
                sage: G = CombinatorialFreeModule(ZZ, [3,4]); G.__custom_name = "G"
                sage: H = CombinatorialFreeModule(ZZ, [5,6]); H.rename("H")

                sage: f =   F.monomial(1) + 2 * F.monomial(2)
                sage: g = 2*G.monomial(3) +     G.monomial(4)
                sage: h =   H.monomial(5) +     H.monomial(6)
                sage: FG  = tensor([F, G   ])
                sage: phi_fg = FG.tensor_constructor((F, G))
                sage: phi_fg(f,g)
                2*B[1] # B[3] + B[1] # B[4] + 4*B[2] # B[3] + 2*B[2] # B[4]

                sage: FGH = tensor([F, G, H])
                sage: phi_fgh = FGH.tensor_constructor((F, G, H))
                sage: phi_fgh(f, g, h)
                2*B[1] # B[3] # B[5] + 2*B[1] # B[3] # B[6] + B[1] # B[4] # B[5] + B[1] # B[4] # B[6] + 4*B[2] # B[3] # B[5] + 4*B[2] # B[3] # B[6] + 2*B[2] # B[4] # B[5] + 2*B[2] # B[4] # B[6]

                sage: phi_fg_h = FGH.tensor_constructor((FG, H))
                sage: phi_fg_h(phi_fg(f, g), h)
                2*B[1] # B[3] # B[5] + 2*B[1] # B[3] # B[6] + B[1] # B[4] # B[5] + B[1] # B[4] # B[6] + 4*B[2] # B[3] # B[5] + 4*B[2] # B[3] # B[6] + 2*B[2] # B[4] # B[5] + 2*B[2] # B[4] # B[6]
            """
            assert(module in ModulesWithBasis(self.base_ring()) for module in modules)
            assert(tensor(modules) == self)
            # a list l such that l[i] is True if modules[i] is readily a tensor product
            is_tensor = [isinstance(module, CombinatorialFreeModule_Tensor) for module in modules]
            # the tensor_constructor, on basis elements
            result = self.monomial * CartesianProductWithFlattening(is_tensor) #.
            # TODO: make this into an element of Hom( A x B, C ) when those will exist
            for i in range(0, len(modules)):
                result = modules[i]._module_morphism(result, position = i, codomain = self)
            return result

        def _tensor_of_elements(self, elements, **keywords):
            """
            Returns the tensor product of the specified elements.
            The result should be in ``self``.

            EXAMPLES::

                sage: F = CombinatorialFreeModule(ZZ, [1,2]); F.__custom_name = "F"
                sage: G = CombinatorialFreeModule(ZZ, [3,4]); G.__custom_name = "G"
                sage: H = CombinatorialFreeModule(ZZ, [5,6]); H.rename("H")

                sage: f =   F.monomial(1) + 2 * F.monomial(2)
                sage: g = 2*G.monomial(3) +     G.monomial(4)
                sage: h =   H.monomial(5) +     H.monomial(6)

                sage: GH  = tensor([G, H])
                sage: gh = GH._tensor_of_elements([g, h]); gh
                2*B[3] # B[5] + 2*B[3] # B[6] + B[4] # B[5] + B[4] # B[6]

                sage: FGH = tensor([F, G, H])
                sage: FGH._tensor_of_elements([f, g, h])
                2*B[1] # B[3] # B[5] + 2*B[1] # B[3] # B[6] + B[1] # B[4] # B[5] + B[1] # B[4] # B[6] + 4*B[2] # B[3] # B[5] + 4*B[2] # B[3] # B[6] + 2*B[2] # B[4] # B[5] + 2*B[2] # B[4] # B[6]

                sage: FGH._tensor_of_elements([f, gh])
                2*B[1] # B[3] # B[5] + 2*B[1] # B[3] # B[6] + B[1] # B[4] # B[5] + B[1] # B[4] # B[6] + 4*B[2] # B[3] # B[5] + 4*B[2] # B[3] # B[6] + 2*B[2] # B[4] # B[5] + 2*B[2] # B[4] # B[6]

                sage: tensor([F])._tensor_of_elements([f])
                B[1] + 2*B[2]

            """
            return self.tensor_constructor(tuple(element.parent() for element in elements), **keywords)(*elements)

        def _a_basis_key(self):
            r"""
            A basis key.

            EXAMPLES::

                sage: F = CombinatorialFreeModule(ZZ,[1,2])
                sage: G = CombinatorialFreeModule(ZZ,[3,4,5])
                sage: FG = tensor([F,G])
                sage: FG._a_basis_key()
                (1, 3)
            """
            return tuple([x.an_element() for x in self.basis().keys().cc.iters])

        def a_monomial(self):
            r"""
            A monomial of ``self``.

            EXAMPLES::

                sage: F = CombinatorialFreeModule(ZZ,[1,2])
                sage: G = CombinatorialFreeModule(ZZ,[3,4,5])
                sage: FG = tensor([F,G])
                sage: FG.a_monomial()
                B[1] # B[3]
            """
            return self.monomial(self._a_basis_key())

        def an_element(self):
            r"""
            An element of ``self``.

            EXAMPLES::

                sage: F = CombinatorialFreeModule(ZZ,[1,2])
                sage: G = CombinatorialFreeModule(ZZ,[3])
                sage: FG = tensor([F,G])
                sage: FG.an_element()
                4*B[1] # B[3] + 4*B[2] # B[3]

            """
            return self(tensor([module.an_element() for module in self._sets]))

        def _coerce_map_from_(self, R):
            """
            Return ``True`` if there is a coercion from ``R`` into ``self`` and
            ``False`` otherwise.  The things that coerce into ``self`` are:

            - Anything with a coercion into ``self.base_ring()``.

            - A tensor algebra whose factors have a coercion into the
              corresponding factors of ``self``.

            TESTS::

                sage: C = CombinatorialFreeModule(ZZ, ZZ)
                sage: C2 = CombinatorialFreeModule(ZZ, NN)
                sage: M = C.module_morphism(lambda x: C2.monomial(abs(x)), codomain=C2)
                sage: M.register_as_coercion()
                sage: C2(C.basis()[3])
                B[3]
                sage: C2(C.basis()[3] + C.basis()[-3])
                2*B[3]
                sage: S = C.tensor(C)
                sage: S2 = C2.tensor(C2)
                sage: S2.has_coerce_map_from(S)
                True
                sage: S.has_coerce_map_from(S2)
                False
                sage: S.an_element()
                9*B[-1] # B[-1] + 3*B[-1] # B[0] + 9*B[-1] # B[1] + 3*B[0] # B[-1] + B[0] # B[0] + 3*B[0] # B[1] + 9*B[1] # B[-1] + 3*B[1] # B[0] + 9*B[1] # B[1]
                sage: S2(S.an_element())
                B[0] # B[0] + 6*B[0] # B[1] + 6*B[1] # B[0] + 36*B[1] # B[1]

            ::

                sage: C = CombinatorialFreeModule(ZZ, Set([1,2]))
                sage: D = CombinatorialFreeModule(ZZ, Set([2,4]))
                sage: f = C.module_morphism(on_basis=lambda x: D.monomial(2*x), codomain=D)
                sage: f.register_as_coercion()
                sage: T = tensor((C,C))
                sage: p = D.an_element()
                sage: T(tensor((p,p)))
                Traceback (most recent call last):
                ...
                NotImplementedError
                sage: T = tensor((D,D))
                sage: p = C.an_element()
                sage: T(tensor((p,p)))
                4*B[2] # B[2] + 4*B[2] # B[4] + 4*B[4] # B[2] + 4*B[4] # B[4]
            """
            if R in ModulesWithBasis(self.base_ring()).TensorProducts() \
                    and isinstance(R, CombinatorialFreeModule_Tensor) \
                    and len(R._sets) == len(self._sets) \
                    and all(self._sets[i].has_coerce_map_from(M)
                            for i,M in enumerate(R._sets)):
                modules = R._sets
                vector_map = [self._sets[i]._internal_coerce_map_from(M)
                              for i,M in enumerate(modules)]
                return R.module_morphism(lambda x: self._tensor_of_elements(
                        [vector_map[i](M.monomial(x[i]))
                         for i,M in enumerate(modules)]),
                                         codomain=self)

            return super(CombinatorialFreeModule_Tensor, self)._coerce_map_from_(R)

        def _tensor_of_maps(self, maps, **keywords):
            r"""
            Tensor product of maps.

            EXAMPLES::

                sage: from sage.categories.morphism import SetMorphism
                sage: Sym = SymmetricFunctions(QQ)
                sage: s = Sym.s()
                sage: id_s = s._identity_map()
                sage: antipode_map = SetMorphism(Hom(s,s),lambda x: s.antipode(x))
                sage: iS = tensor([id_s, antipode_map])
                sage: ss = tensor([s,s])
                sage: coproduct_map = s.module_morphism(on_basis=s.coproduct_on_basis, codomain=ss)
                sage: product_map = ss.module_morphism(on_basis=lambda x: s[x[0]]*s[x[1]], codomain=s)
                sage: U = s.tensor_unit()
                sage: counit_map = SetMorphism(Hom(s,U),lambda x: s.counit(x)*U.one())
                sage: unit_map = U.module_morphism(on_basis=lambda x: s.one(), codomain=s)
                sage: b = s.an_element(); b
                2*s[] + 2*s[1] + 3*s[2]
                sage: (unit_map * counit_map)(b)
                2*s[]
                sage: (product_map*iS*coproduct_map)(b)
                2*s[]

            """
            tensor_unit = self.tensor_unit()
            # delete any map from the tensor unit to itself
            maps = [map for map in maps if map.domain() != tensor_unit or map.codomain() != tensor_unit]
            if len(maps) == 0:
                return tensor_unit._identity_map()
            category = self.category()
            base_category = None
            if isinstance(category, JoinCategory):
                for supercategory in category.super_categories():
                    if isinstance(supercategory,TensorProductsCategory):
                        if base_category is None:
                            base_category = supercategory.base_category()
                        else:
                            base_category = Category.join((base_category, supercategory.base_category()))
            elif isinstance(category, TensorProductsCategory):
                base_category = category.base_category()
            if base_category is None:
                raise TypeError("should be a tensor category of modules")
            R = base_category.base_ring()
            module_tensor_category = ModulesWithBasis(R).TensorProducts()
            codomains = [map.codomain() for map in maps]
            # flag which codomains are tensors
            codomain_is_tensor = tuple(codomain in module_tensor_category for codomain in codomains)
            # find the sizes of the tensors. Size zero means the tensor factor consists of scalars
            codomain_n_tensor = tuple(0 if codomains[i] == tensor_unit else len(codomains[i]._sets) if codomain_is_tensor[i] else 1 for i in range(len(maps)))

            domains = [map.domain() for map in maps]
            domain_is_tensor = tuple(domain in module_tensor_category for domain in domains)
            domain_n_tensor = tuple(0 if domains[i] == tensor_unit else len(domains[i]._sets) if domain_is_tensor[i] else 1 for i in range(len(maps)))
            # the function that splits one tuple into tuples that plug into the maps
            key_splitter = CartesianProductWithUnflattening(domain_is_tensor, domain_n_tensor)
            # make a tuple whose items are (i,f) where i is the index into the tuple and f is the scalar-valued map
            scalar_part = tuple([(i,maps[i]) for i in range(len(maps)) if codomain_n_tensor[i] == 0])
            # make a tuple whose items are (i, b, f) where i is the index, b is boolean
            # where False means that f will be a constant vector and True means that f will be a vector-valued function
            vector_part = tuple((i, domain_n_tensor[i], maps[i] if domain_n_tensor[i] != 0 else maps[i](maps[i].domain().one())) \
              for i in range(len(maps)) if codomain_n_tensor[i] != 0)

            R = self.base_ring()
            def on_basis(long_key):
                keys = key_splitter(long_key)
                monomials = [domains[i].monomial(keys[i]) if domain_n_tensor[i] != 0 else () for i in range(len(maps))]
                return R.prod([f(monomials[i]) for (i,f) in scalar_part]) * tensor([f(monomials[i]) if d!=0 else f for (i,d,f) in vector_part])
            return self.module_morphism(on_basis=on_basis, codomain=tensor(codomains, category=base_category.TensorProducts()))

class CartesianProductWithFlattening(object):
    """
    A class for Cartesian product constructor, with partial flattening
    """
    def __init__(self, flatten):
        """
        INPUT:

         - ``flatten`` -- a tuple of booleans

        This constructs a callable which accepts ``len(flatten)``
        arguments, and builds a tuple out them. When ``flatten[i]``,
        the i-th argument itself should be a tuple which is flattened
        in the result.

            sage: from sage.combinat.free_module import CartesianProductWithFlattening
            sage: CartesianProductWithFlattening([True, False, True, True])
            <sage.combinat.free_module.CartesianProductWithFlattening object at ...>

        """
        self._flatten = flatten

    def __call__(self, *indices):
        """
        EXAMPLES::

            sage: from sage.combinat.free_module import CartesianProductWithFlattening
            sage: cp = CartesianProductWithFlattening([True, False, True, True])
            sage: cp((1,2), (3,4), (5,6), (7,8))
            (1, 2, (3, 4), 5, 6, 7, 8)
            sage: cp((1,2,3), 4, (5,6), (7,8))
            (1, 2, 3, 4, 5, 6, 7, 8)

        """
        return sum( (i if flatten else (i,) for (i,flatten) in zip(indices, self._flatten) ), ())

class CartesianProductWithUnflattening(object):
    """
    A class for cartesian product constructor.
    """
    def __init__(self, unflatten, sizes):
        r"""
        This class computes the inverse of flattening,
        splitting a tuple of length equal to `sum(sizes)`
        into a tuple of tuples or single elements,
        such that the length of the `i`-th tuple is `sizes[i]`.

        INPUT:

         - ``unflatten`` -- a tuple of booleans
         - ``sizes`` -- a tuple of positive integers

        """
        assert len(unflatten) == len(sizes)
        # unflatten[i] must be true except when size[i] == 1.
        assert all(unflatten_this or size == 1 for (unflatten_this, size) in zip(unflatten,sizes))
        def partial_sums(sz):
            if len(sz) == 1:
                return sz
            else:
                ps = partial_sums(sz[:-1])
                return ps + tuple([ps[-1]+sz[-1]])
        if len(sizes) == 0:
            self._bounds = tuple([])
        else:
            upper_bounds = partial_sums(sizes)
            lower_bounds = tuple([0])+upper_bounds[:-1]
            self._bounds = tuple(zip(unflatten, lower_bounds, upper_bounds))

    def __call__(self, tup):
        """
        EXAMPLES::

            sage: from sage.combinat.free_module import CartesianProductWithUnflattening
            sage: un = CartesianProductWithUnflattening((True, False, True, True), (3,1,2,2))
            sage: un((1,2,3,4,5,6,7,8))
            ((1, 2, 3), 4, (5, 6), (7, 8))
            sage: un = CartesianProductWithUnflattening((True, False, True, True, True), (3,1,0,1,3))
            sage: un((1,2,3,4,5,6,7,8))
            ((1, 2, 3), 4, (), (5,), (6, 7, 8))

        """
        return tuple([tup[low:high] if unflatten else tup[low] for (unflatten,low,high) in self._bounds])

# TODO: find a way to avoid this hack to allow for cross references
CombinatorialFreeModule.Tensor = CombinatorialFreeModule_Tensor

class CombinatorialFreeModule_TensorGrouped(CombinatorialFreeModule_Tensor):
    r"""
    Concrete class for tensor products that remembers grouping.

    INPUT:

    - modules -- the modules to be tensored
    - keywords -- optional keyword parameters

    Implementation: This class remembers the tensor factors used in its creation.
    The actual object is the flattened tensor product provided by
    :class:`CombinatorialFreeModule_Tensor`.

    The methods :meth:`.indices_to_index` and :meth:`.index_to_indices` provide bijections between
    the grouped tuples that naturally index the grouped tensor product, and the flattened indices used in the
    implementation.

    """

    def __init__(self, modules, category, **keywords):
        # save the tensor factors
        self._factors = modules
        self._is_tensor = tuple(isinstance(module, CombinatorialFreeModule_Tensor) for module in modules)
        self._n_factors = tuple(len(module.factors()) if isinstance(module, CombinatorialFreeModule_TensorGrouped) else len(module._sets) if isinstance(module, CombinatorialFreeModule_Tensor) else 1 for module in modules)
        self._unflattening_function = CartesianProductWithUnflattening(self._is_tensor, self._n_factors)
        self._flattening_function = CartesianProductWithFlattening(self._is_tensor)
        flattened_modules = sum([module._sets if isinstance(module, CombinatorialFreeModule_Tensor) else (module,) for module in modules],())
        CombinatorialFreeModule_Tensor.__init__(self, flattened_modules, category, **keywords)

    def _repr_(self):
        """
        TESTS::

            sage: W=WeylGroup("A2",prefix="s")
            sage: A=W.algebra(ZZ); A.rename("A")
            sage: A2=tensor([A,A]); A2
            A # A
            sage: tensor([A2,A2])
            (A # A) # (A # A)
            sage: tensor([A, tensor([A,A])])
            A # (A # A)
            sage: tensor([A2,A2], category=ModulesWithBasis(ZZ))
            A # A # A # A

        """
        from sage.categories.tensor import tensor
        if hasattr(self, "_print_options"):
            symb = self._print_options['tensor_symbol']
            if symb is None:
                symb = tensor.symbol
        else:
            symb = tensor.symbol
        return symb.join(["(%s)"%self.factor(i) if self._n_factors[i] > 1 else "%s"%self.factor(i) for i in range(len(self.factors()))])

    def factors(self):
        r"""
        The list of tensor factors of `self`.

        EXAMPLES::

            sage: W = WeylGroup("A2",prefix="s")
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A]) # calls this class 
            sage: A4 = tensor([A2,A2])
            sage: A4.factors()
            (A # A, A # A)

        """
        return self._factors

    def factor(self, i):
        r"""
        The `i`-th factor of ``self``.

        EXAMPLES::

            sage: W = WeylGroup("A2",prefix="s")
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A])
            sage: A4 = tensor([A2,A2])
            sage: A4.factor(1)
            A # A
        """
        return self._factors[i]

    def indices_to_index(self):
        r"""
        The bijection from the tuple of indices of bases of `self.factors()` to the
        index set of `self.basis()`.

        EXAMPLES::

            sage: W = WeylGroup("A2",prefix="s")
            sage: r = W.from_reduced_word
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A])
            sage: A4 = tensor([A2,A2])
            sage: a = (r([1]),r([2]))
            sage: b = (r([2,1]),r([1,2]))
            sage: A4.indices_to_index()(a,b)
            (s1, s2, s2*s1, s1*s2)

        """
        return self._flattening_function

    def index_to_indices(self):
        r"""
        The bijection from the index set of `self.basis()` to the tuples of indices
        of bases of `self.factors()`.

        EXAMPLES::

            sage: W = WeylGroup("A2",prefix="s")
            sage: r = W.from_reduced_word
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A])
            sage: A4 = tensor([A2,A2])
            sage: A4.index_to_indices()((r([1]),r([2]),r([2,1]),r([1,2])))
            ((s1, s2), (s2*s1, s1*s2))
        """
        return self._unflattening_function

    def monomial_grouped(self, tup):
        r"""
        The monomial indexed by a grouped tuple.

        EXAMPLES::

            sage: W = WeylGroup("A2",prefix="s")
            sage: r = W.from_reduced_word
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A])
            sage: A4 = tensor([A2,A2])
            sage: m = A4.monomial_grouped(((r([1]),r([2])),(r([1,2]),r([2,1])))); m
            s1 # s2 # s1*s2 # s2*s1

        """
        return self.monomial(self.indices_to_index()(*tup))

    def tensor_module_morphism(self, on_basis, codomain, category=None, **keywords):
        r"""
        Returns a module morphism whose domain is a tensor product.

        This is analogous to :meth:`.module_morphism` except that only the ``on_basis`` option is
        implemented and the inputs for the ``on_basis`` function are grouped tuples instead of the
        flattened tuples secretly used in the implementation of tensor products.

        EXAMPLES::

            sage: W = WeylGroup(['A',2],prefix="s")
            sage: r = W.from_reduced_word
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A])
            sage: A3 = tensor([A2,A])
            sage: R = lambda (a,b): (b,a)
            sage: RI = A3.tensor_module_morphism(on_basis = lambda (ab, c): A3.monomial_grouped((R(ab),c)), codomain=A3)
            sage: pair = (r([1,2]), r([2]))
            sage: RI(A3.monomial_grouped((pair,r([1]))))
            s2 # s1*s2 # s1
        """
        return self.module_morphism(on_basis = lambda x: on_basis(self.index_to_indices()(x)), category=category, codomain=codomain, **keywords)

    @cached_method
    def _flat_tensor(self):
        r"""
        The flattened tensor product of ``self``.

        EXAMPLES::

            sage: W = WeylGroup("A2",prefix="s")
            sage: r = W.from_reduced_word
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A])
            sage: A4 = tensor([A2,A2])
            sage: AAAA = A4._flat_tensor(); AAAA
            A # A # A # A
            sage: isinstance(AAAA, CombinatorialFreeModule.TensorGrouped)
            False

        """
        return tensor(self.factors(), category=ModulesWithBasis(self.base_ring()).TensorProducts())

    def from_direct_product(self, tup):
        r"""
        Given a tuple of elements of the factors of ``self``, return the corresponding element of ``self``.

        EXAMPLES::

            sage: W = WeylGroup("A2",prefix="s")
            sage: r = W.from_reduced_word
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A])
            sage: A4 = tensor([A2,A2])
            sage: a = A2.monomial((r([1]),r([2])))
            sage: b = A2.monomial((r([2,1]),r([1,2])))
            sage: A4.from_direct_product((a,b))
            B[s1] # B[s2] # B[s2*s1] # B[s1*s2]
        """
        if len(tup) != len(self.factors()):
            raise ValueError("number of components of tuple is incorrect")
        try:
            return self(tensor([the_factor(element)
                                for the_factor, element in zip(self.factors(), tup)],
                               category=ModulesWithBasis(self.base_ring())))
        except Exception:
            raise ValueError("cannot coerce tuple (%s) into tensor product %s"%(tup, self))

    def an_element(self):
        r"""
        An element of ``self``.

        EXAMPLES::

            sage: W = WeylGroup("A1",prefix="s")
            sage: r = W.from_reduced_word
            sage: A = W.algebra(ZZ); A.rename("A")
            sage: A2 = tensor([A,A])
            sage: A4 = tensor([A2,A2])
            sage: A4.an_element()
            81*B[s1] # B[s1] # B[s1] # B[s1] + 27*B[s1] # B[s1] # B[s1] # B[1] + 27*B[s1] # B[s1] # B[1] # B[s1] + 9*B[s1] # B[s1] # B[1] # B[1] + 27*B[s1] # B[1] # B[s1] # B[s1] + 9*B[s1] # B[1] # B[s1] # B[1] + 9*B[s1] # B[1] # B[1] # B[s1] + 3*B[s1] # B[1] # B[1] # B[1] + 27*B[1] # B[s1] # B[s1] # B[s1] + 9*B[1] # B[s1] # B[s1] # B[1] + 9*B[1] # B[s1] # B[1] # B[s1] + 3*B[1] # B[s1] # B[1] # B[1] + 9*B[1] # B[1] # B[s1] # B[s1] + 3*B[1] # B[1] # B[s1] # B[1] + 3*B[1] # B[1] # B[1] # B[s1] + B[1] # B[1] # B[1] # B[1]

        """
        return self.from_direct_product(tuple([the_factor.an_element() for the_factor in self.factors()]))

CombinatorialFreeModule.TensorGrouped = CombinatorialFreeModule_TensorGrouped

class CombinatorialFreeModule_CartesianProduct(CombinatorialFreeModule):
    """
    An implementation of Cartesian products of modules with basis

    EXAMPLES:

    We construct two free modules, assign them short names, and construct their Cartesian product::

        sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = "F"
        sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = "G"
        sage: H = CombinatorialFreeModule(ZZ, [4,7]); H.__custom_name = "H"
        sage: S = cartesian_product([F, G])
        sage: S
        F (+) G
        sage: S.basis()
        Lazy family (Term map from Disjoint union of Family ({4, 5}, {4, 6}) to F (+) G(i))_{i in Disjoint union of Family ({4, 5}, {4, 6})}

    Note that the indices of the basis elements of F and G intersect non
    trivially. This is handled by forcing the union to be disjoint::

        sage: list(S.basis())
        [B[(0, 4)], B[(0, 5)], B[(1, 4)], B[(1, 6)]]

    We now compute the Cartesian product of elements of free modules::

        sage: f =   F.monomial(4) + 2 * F.monomial(5)
        sage: g = 2*G.monomial(4) +     G.monomial(6)
        sage: h =   H.monomial(4) +     H.monomial(7)
        sage: cartesian_product([f,g])
        B[(0, 4)] + 2*B[(0, 5)] + 2*B[(1, 4)] + B[(1, 6)]
        sage: cartesian_product([f,g,h])
        B[(0, 4)] + 2*B[(0, 5)] + 2*B[(1, 4)] + B[(1, 6)] + B[(2, 4)] + B[(2, 7)]
        sage: cartesian_product([f,g,h]).parent()
        F (+) G (+) H

    TODO: choose an appropriate semantic for Cartesian products of Cartesian products (associativity?)::

        sage: S = cartesian_product([cartesian_product([F, G]), H]) # todo: not implemented
        F (+) G (+) H
    """

    def __init__(self, modules, **options):
        r"""
        TESTS::

            sage: F = CombinatorialFreeModule(ZZ, [2,4,5])
            sage: G = CombinatorialFreeModule(ZZ, [2,4,7])
            sage: C = cartesian_product([F, G]) ; C
            Free module generated by {2, 4, 5} over Integer Ring (+) Free module generated by {2, 4, 7} over Integer Ring
            sage: TestSuite(C).run()
        """
        assert(len(modules) > 0) # TODO: generalize to a family or tuple
        R = modules[0].base_ring()
        assert(all(module in ModulesWithBasis(R)) for module in modules)
        # should check the base ring
        self._sets = modules
        CombinatorialFreeModule.__init__(self, R,
            DisjointUnionEnumeratedSets(
                [module.basis().keys() for module in modules], keepkey=True),
            **options)

    def _sets_keys(self):
        """
        In waiting for self._sets.keys()

        TESTS::

            sage: F = CombinatorialFreeModule(ZZ, [2,4,5])
            sage: G = CombinatorialFreeModule(ZZ, [2,4,7])
            sage: CP = cartesian_product([F, G])
            sage: CP._sets_keys()
            [0, 1]
        """
        return list(range(len(self._sets)))

    def _repr_(self):
        """
        TESTS::

            sage: F = CombinatorialFreeModule(ZZ, [2,4,5])
            sage: CP = cartesian_product([F, F]); CP  # indirect doctest
            Free module generated by {2, 4, 5} over Integer Ring (+) Free module generated by {2, 4, 5} over Integer Ring
            sage: F.__custom_name = "F"; CP
            F (+) F
        """
        from sage.categories.cartesian_product import cartesian_product
        return cartesian_product.symbol.join(["%s"%module for module in self._sets])
        # TODO: make this overridable by setting _name

    @cached_method
    def cartesian_embedding(self, i):
        """
        Return the natural embedding morphism of the ``i``-th
        Cartesian factor (summand) of ``self`` into ``self``.

        INPUT:

         - ``i`` -- an integer

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = "F"
            sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = "G"
            sage: S = cartesian_product([F, G])
            sage: phi = S.cartesian_embedding(0)
            sage: phi(F.monomial(4) + 2 * F.monomial(5))
            B[(0, 4)] + 2*B[(0, 5)]
            sage: phi(F.monomial(4) + 2 * F.monomial(6)).parent() == S
            True

        TESTS::

            sage: phi(G.monomial(4))
            Traceback (most recent call last):
            ...
            AssertionError
        """
        assert i in self._sets_keys()
        return self._sets[i]._module_morphism(lambda t: self.monomial((i, t)),
                                              codomain = self)

    summand_embedding = cartesian_embedding

    @cached_method
    def cartesian_projection(self, i):
        """
        Return the natural projection onto the `i`-th Cartesian factor
        (summand) of ``self``.

        INPUT:

         - ``i`` -- an integer

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = "F"
            sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = "G"
            sage: S = cartesian_product([F, G])
            sage: x = S.monomial((0,4)) + 2 * S.monomial((0,5)) + 3 * S.monomial((1,6))
            sage: S.cartesian_projection(0)(x)
            B[4] + 2*B[5]
            sage: S.cartesian_projection(1)(x)
            3*B[6]
            sage: S.cartesian_projection(0)(x).parent() == F
            True
            sage: S.cartesian_projection(1)(x).parent() == G
            True
        """
        assert i in self._sets_keys()
        module = self._sets[i]
        return self._module_morphism(lambda j_t: module.monomial(j_t[1]) if i == j_t[0] else module.zero(), codomain = module)

    summand_projection = cartesian_projection

    def _cartesian_product_of_elements(self, elements):
        """
        Return the Cartesian product of the elements.

        INPUT:

        - ``elements`` -- a tuple with one element of each Cartesian
          factor of ``self``

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = "F"
            sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = "G"
            sage: S = cartesian_product([F, G])
            sage: f =   F.monomial(4) + 2 * F.monomial(5)
            sage: g = 2*G.monomial(4) +     G.monomial(6)
            sage: S._cartesian_product_of_elements([f, g])
            B[(0, 4)] + 2*B[(0, 5)] + 2*B[(1, 4)] + B[(1, 6)]
            sage: S._cartesian_product_of_elements([f, g]).parent() == S
            True

        """
        return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())

    def cartesian_factors(self):
        """
        Return the factors of the Cartesian product.

        EXAMPLES::

            sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = "F"
            sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = "G"
            sage: S = cartesian_product([F, G])
            sage: S.cartesian_factors()
            (F, G)

        """
        return self._sets

    class Element(CombinatorialFreeModule.Element): # TODO: get rid of this inheritance
        pass

CombinatorialFreeModule.CartesianProduct = CombinatorialFreeModule_CartesianProduct

class TensorUnitElement(CombinatorialFreeModule.Element):
    def coefficient(self, m):
        r"""
        Return the coefficient of `m` in ``self``.

        EXAMPLES::

            sage: M=CombinatorialFreeModule(ZZ,[1,2])
            sage: U=M.tensor_unit()
            sage: u=U.an_element(); u
            2*B[()]
            sage: u.coefficient(())
            2

        """
        #assert m == tuple([])
        return self[m]

    def the_coefficient(self):
        r"""
        Return the sole coefficient of ``self``.

        Note that ``self`` is a free module with only one basis element whose index is the 0-tuple.
        """
        return self[()]

class TensorUnit(CombinatorialFreeModule.Tensor):
    r"""
    The unit in the tensor category of ModulesWithBasis over a base ring,
    realized by a zerofold `class`:CombinatorialFreeModule_Tensor`.

    This is just the base ring itself, constructed as a free module of rank 1.
    Optionally, by specifying a category, it can be viewed as an algebra,
    coalgebra, hopf algebra, etc. All the structure maps are trivial.

    This class is implemented by a direct call to
    :class:`CombinatorialFreeModule_Tensor`.
    """
    def __init__(self, category=None, **keywords):
        """
        INPUT:

        - ``category`` -- tensor category of result
        - ``keywords`` -- optional keyword arguments

        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1,2])
            sage: M.tensor_unit() # indirect doctest
            The unit object in Category of tensor products of modules with basis
             over Integer Ring
        """
        self._one_key = tuple([])
        CombinatorialFreeModule_Tensor.__init__(self, tuple([]), category, **keywords)
        assert self._one_key == self.basis().keys().an_element()

    def _repr_(self):
        """
        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1,2])
            sage: M.tensor_unit()
            The unit object in Category of tensor products of modules with basis
             over Integer Ring

        .. TODO::

            Should this also describe the implementation class?
        """
        return "The unit object in %s"%self.category()

    def _repr_term(self, term):
        return CombinatorialFreeModule._repr_term(self, term)

    def one_basis(self):
        """
        Returns the one of the group, which index the one of this algebra,
        as per :meth:`AlgebrasWithBasis.ParentMethods.one_basis`.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1])
            sage: A = M.tensor_unit(category=AlgebrasWithBasis(ZZ))
            sage: A.one_basis()
            ()
            sage: A.one()
            B[()]
        """
        return self._one_key

    def one(self):
        """
        Returns the unit element in ``self`` viewed as an algebra.

            sage: M = CombinatorialFreeModule(ZZ,[1])
            sage: A = M.tensor_unit(category=AlgebrasWithBasis(ZZ))
            sage: A.one()
            B[()]
        """
        return self.monomial(self._one_key)

    def an_element(self):
        r"""
        An element of ``self``.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1])
            sage: A = M.tensor_unit()
            sage: A.an_element()
            2*B[()]
        """
        return 2 * self.one()

    def product_on_basis(self, g1, g2):
        r"""
        Product, on basis elements, as per
        :meth:`AlgebrasWithBasis.ParentMethods.product_on_basis`.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1])
            sage: A = M.tensor_unit(category=AlgebrasWithBasis(ZZ))
            sage: A.one_basis()
            ()
            sage: a = A.one_basis()
            sage: A.product_on_basis(a, a)
            B[()]
            sage: ma = A.monomial(a); ma
            B[()]
            sage: ma*ma
            B[()]

        """
        return self.one()

    def algebra_generators(self):
        r"""
        The generators of this algebra, as per
        :meth:`Algebras.ParentMethods.algebra_generators`.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1])
            sage: A = M.tensor_unit(category=AlgebrasWithBasis(ZZ))
            sage: A.algebra_generators()
            Finite family {(): B[()]}
        """
        from sage.sets.family import Family
        return Family(tuple([self._one_key]), self.monomial)

    def coproduct_on_basis(self, g):
        r"""
        Coproduct, on basis elements, as per :meth:`HopfAlgebrasWithBasis.ParentMethods.coproduct_on_basis`.

        Since we are taking the coproduct of the base ring and compressing tensor products, the
        codomain is automatically isomorphed to a single copy of the base ring and the
        coproduct is the identity map.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1])
            sage: A = M.tensor_unit(category=HopfAlgebrasWithBasis(ZZ))
            sage: A.coproduct_on_basis(A.one_basis()) == A.one()
            True

        """
        return self.one()

    def counit_on_basis(self, g):
        r"""
        Counit, on basis elements, as per :meth:`HopfAlgebrasWithBasis.ParentMethods.counit_on_basis`.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1])
            sage: A = M.tensor_unit(category=HopfAlgebrasWithBasis(ZZ))
            sage: A.counit_on_basis(A.one_basis()) == A.base_ring().one()
            True

        """
        return self.base_ring().one()

    def antipode_on_basis(self, g):
        r"""
        Antipode, on basis elements, as per :meth:`HopfAlgebrasWithBasis.ParentMethods.antipode_on_basis`.

        EXAMPLES::

            sage: M = CombinatorialFreeModule(ZZ,[1])
            sage: A = M.tensor_unit(category=HopfAlgebrasWithBasis(ZZ))
            sage: A.antipode_on_basis(A.one_basis()) == A.one()
            True

        """
        return self.one()

    Element = TensorUnitElement

