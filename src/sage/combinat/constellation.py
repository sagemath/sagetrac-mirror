r"""
Constellations

A constellation is a tuple `(g_0, g_1, \dots, g_k)` of permutations
such that the product `g_0 g_1 ... g_k` is the identity. One often
assumes that the group generated by `g_0, g_1, \dots, g_k` acts
transitively ([LaZv04]_ definition 1). Geometrically, it corresponds
to a covering of the 2-sphere ramified over `k` points (the transitivity
condition corresponds to the connectivity of the covering).

.. NOTE::

    The permutations are on `[0, n-1]` and not on `[1, n]` for
    algorithmic and practical reasons.

EXAMPLES::

    sage: c = Constellation(['(0,1)', '(0,2)', None])
    sage: c
    Constellation of length 3 and degree 3
    g0 (0,1)(2)
    g1 (0,2)(1)
    g2 (0,2,1)
    sage: C = Constellations(3,4); C
    Connected constellations of length 3 and degree 4
    sage: C.cardinality()
    426

TESTS::

    sage: S = SymmetricGroup(['a','b','c','d'])
    sage: C = Constellation([S((('a','b'),),),S((('a','d'),('b','c'))),S(('a','d','b','c'),)])
    sage: C.is_connected()
    True
    sage: C.euler_characteristic()
    2

REFERENCES:

.. [LaZv04] S. Lando and A. Zvonkine, "Graphs on surfaces and their
            applications", Springer-Verlag, 2004.
"""
# *************************************************************************
# Copyright (C) 2015-2016 Vincent Delecroix <20100.delecroix@gmail.com>
#                         Frederic Chapoton <fchapoton2@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#
#  The full text of the GPL is available at http://www.gnu.org/licenses/
# *************************************************************************

from sage.structure.parent import Parent
from sage.structure.element import Element
from sage.structure.unique_representation import UniqueRepresentation
from sage.groups.perm_gps.permgroup_named import SymmetricGroup
from sage.arith.srange import srange
from sage.rings.integer import Integer
from sage.combinat.partition import Partition
from sage.graphs.graph import Graph
from sage.misc.misc_c import prod
from sage.categories.groups import Groups


# constructors


def Constellations(*data, **options):
    r"""
    Build a set of constellations.

    INPUT:

    - ``profile`` -- an optional profile

    - ``length`` -- an optional length

    - ``degree`` -- an optional degree

    - ``connected`` -- an optional boolean

    EXAMPLES:

    The set of all constellations::

        sage: Constellations()
        Connected constellations

    Constellations with constrained length and degree::

        sage: Constellations(4,2)
        Connected constellations of length 4 and degree 2
    """
    profile = options.get('profile', None)
    length = options.get('length', None)
    degree = options.get('degree', None)
    connected = options.get('connected', True)

    if data:
        if len(data) == 1:
            if isinstance(data[0], (tuple, list)):
                profile = data[0]
            else:
                length = Integer(data[0])
        elif len(data) == 2:
            length = Integer(data[0])
            degree = Integer(data[1])

    if profile:
        profile = tuple(map(Partition, profile))
        return Constellations_p(profile, bool(connected))
    if degree is None and length is None:
        return Constellations_all(bool(connected))
    elif degree is not None and length is not None:
        return Constellations_ld(Integer(length), Integer(degree),
                                 bool(connected))
    else:
        raise NotImplementedError("one cannot give just degree or just length")


def Constellation(g=None, mutable=False, connected=True, check=True):
    r"""
    Constellation

    INPUT:

    - ``g`` -- a list of permutations

    - ``mutable`` -- whether the result is mutable or not. Default is ``False``.

    - ``connected`` -- whether the result should be connected. Default is
      ``True``.

    - ``check`` -- whether or not to check. If it is ``True``, then the
      list ``g`` must contains no ``None``.

    EXAMPLES:

    Simple initialization::

        sage: Constellation(['(0,1)','(0,3)(1,2)','(0,3,1,2)'])
        Constellation of length 3 and degree 4
        g0 (0,1)(2)(3)
        g1 (0,3)(1,2)
        g2 (0,3,1,2)

    One of the permutation can be omitted::

        sage: Constellation(['(0,1)', None, '(0,4)(1,2,3)'])
        Constellation of length 3 and degree 5
        g0 (0,1)(2)(3)(4)
        g1 (0,3,2,1,4)
        g2 (0,4)(1,2,3)

    One can define mutable constellations::

        sage: Constellation(([0,2,1], [2,1,0], [1,2,0]), mutable=True)
        Constellation of length 3 and degree 3
        g0 (0)(1,2)
        g1 (0,2)(1)
        g2 (0,1,2)
    """
    return Constellations(connected=connected)(g, check=check, mutable=mutable)

# classes


class Constellation_class(Element):
    r"""
    Constellation

    A constellation or a tuple of permutations `(g_0,g_1,...,g_k)`
    such that the product `g_0 g_1 ... g_k` is the identity.
    """
    def __init__(self, parent, g, check=True, connected=True, mutable=False):
        r"""
        TESTS::

            sage: c = Constellation([[1,2,0],[0,2,1],[1,0,2],None])
            sage: c == loads(dumps(c))
            True
            sage: g0 = '(0,1)(2,4)'
            sage: g1 = '(0,3)(1,4)'
            sage: g2 = '(2,4,3)'
            sage: g3 = '(0,3)(1,2)'
            sage: c0 = Constellation([g0,g1,g2,g3])
            sage: c0 == Constellation([None,g1,g2,g3])
            True
            sage: c0 == Constellation([g0,None,g2,g3])
            True
            sage: c0 == Constellation([g0,g1,None,g3])
            True
            sage: c0 == Constellation([g0,g1,g2,None])
            True
        """
        Element.__init__(self, parent)
        self._connected = connected
        self._mutable = mutable
        self._g = g
        d = Integer(0) if len(self._g) == 0 else len(self._g[0].domain())
        self._degree = d
        if check:
            self._check()

    def __hash__(self):
        r"""
        Return a hash for ``self``.

        EXAMPLES::

            sage: c = Constellation(([0,2,1],[2,1,0],[1,2,0]), mutable=False)
            sage: c.__hash__()
            5481133608926415725
        """
        if self._mutable:
            raise ValueError("can not hash mutable constellation")
        return hash(tuple(self._g))

    def set_immutable(self):
        r"""
        Do nothing, as ``self`` is already immutable.

        EXAMPLES::

            sage: c = Constellation(([0,2,1],[2,1,0],[1,2,0]), mutable=False)
            sage: c.set_immutable()
            sage: c.is_mutable()
            False
        """
        self._mutable = False

    def is_mutable(self):
        r"""
        Return ``False`` as ``self`` is immutable.

        EXAMPLES::

            sage: c = Constellation(([0,2,1],[2,1,0],[1,2,0]), mutable=False)
            sage: c.is_mutable()
            False
        """
        return self._mutable

    def switch(self, i, j0, j1):
        r"""
        Switch the vertices and edges at `i` and `i + 1`.

        The modification is local in the sense that it modifies `g_i`
        and `g_{i+1}` but does not modify the product `g_i g_{i+1}`.

        |  j0 -- g_i   --> k0 -- g_i0  --> l0
        |  j1 -- g_i+1 --> k1 -- g_i+1 --> l1

        becomes

        |  j0 -- g_i   --> k1 -- g_i   --> l0
        |  j1 -- g_i+1 --> k1 -- g_i+1 --> l1

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None], mutable=True); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2)(3)
            g2 (0,1,3,2,4)
            sage: c.switch(1,2,3); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2,3)
            g2 (0,1,3,4)(2)
        """
        if not self._mutable:
            raise ValueError("this constellation is immutable."
                             " Take a mutable copy first.")
        S = SymmetricGroup(range(self.degree()))
        tr = S((j0, j1))
        self._g[i] = tr * self._g[i]
        self._g[i + 1] = tr * self._g[i + 1]

    def euler_characteristic(self):
        r"""
        Return the Euler characteristic of the surface.

        ALGORITHM:

        Hurwitz formula

        EXAMPLES::

            sage: c = Constellation(['(0,1)', '(0,2)', None])
            sage: c.euler_characteristic()
            2
        """
        return Integer(self.degree() * 2 -
                       sum(sum(i - 1 for i in self.profile(i))
                           for i in xrange(self.length())))

    def genus(self):
        r"""
        Return the genus of the surface.

        EXAMPLES::

            sage: c = Constellation(['(0,1)', '(0,2)', None])
            sage: c.genus()
            0
        """
        return 1 - self.euler_characteristic() / 2

    def _check(self):
        r"""
        Check that the constellation is valid and if not raise ValueError.

        TESTS::

            sage: c = Constellation([[0,1],[1,0]], mutable=True, check=False)
            sage: c._check()
            Traceback (most recent call last):
            ...
            ValueError: The product is not identity

            sage: c = Constellation([[0,1],[0,1]], mutable=True, check=False)
            sage: c._check()
            Traceback (most recent call last):
            ...
            ValueError: not connected
        """
        d = self.degree()
        Sd = SymmetricGroup(range(d))

        if prod(self._g, Sd.one()) != Sd.one():
            raise ValueError("The product is not identity")

        if self._connected and not perms_are_connected(self._g, d):
            raise ValueError("not connected")

    def __copy__(self):
        r"""
        Return a copy of ``self``.

        TESTS::

            sage: c = Constellation([[0,2,1],[1,0,2],[2,1,0],None])
            sage: c == copy(c)
            True
            sage: c is copy(c)
            False
            sage: c = Constellation([[0,2,1],[1,0,2],[2,1,0],None],mutable=True)
            sage: c == copy(c)
            True
            sage: c is copy(c)
            False
        """
        return self.parent()([gg for gg in self._g],
                             check=False,
                             mutable=self._mutable)

    copy = __copy__

    def mutable_copy(self):
        r"""
        Return a mutable copy of ``self``.

        EXAMPLES::

            sage: c = Constellation(([0,2,1],[2,1,0],[1,2,0]), mutable=False)
            sage: d = c.mutable_copy()
            sage: d.is_mutable()
            True
        """
        return self.parent()([gg for gg in self._g],
                             check=False,
                             mutable=True)

    # GENERAL PROPERTIES

    def is_connected(self):
        r"""
        Test of connectedness.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2)', None, '(0,1)(2)'], connected=False)
            sage: c.is_connected()
            False
            sage: c = Constellation(['(0,1,2)', None], connected=False)
            sage: c.is_connected()
            True
        """
        if self._connected:
            return True
        else:
            return perms_are_connected(self._g, self.degree())

    def connected_components(self):
        """
        Return the connected components.

        OUTPUT:

        A list of connected constellations.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2)', None, '(0,1)(2)'], connected=False)
            sage: cc = c.connected_components(); cc
            [Constellation of length 3 and degree 2
            g0 (0,1)
            g1 (0)(1)
            g2 (0,1),
            Constellation of length 3 and degree 1
            g0 (0)
            g1 (0)
            g2 (0)]
            sage: all(c2.is_connected() for c2 in cc)
            True

            sage: c = Constellation(['(0,1,2)', None], connected=False)
            sage: c.connected_components()
            [Constellation of length 2 and degree 3
            g0 (0,1,2)
            g1 (0,2,1)]
        """
        if self._connected:
            return [self]
        G = Graph()
        G.add_vertices(range(self.degree()))
        for p in self._g:
            G.add_edges(enumerate(p.domain()))
        m = G.connected_components()
        if len(m) == 1:
            return [self]
        for mm in m:
            mm.sort()
        m.sort()
        g = [[] for _ in xrange(len(m))]
        m_inv = [None] * self.degree()
        for t, mt in enumerate(m):
            for i, mti in enumerate(mt):
                m_inv[mti] = i
            for k in xrange(self.length()):
                tmp = [None] * len(mt)
                for i, mti in enumerate(mt):
                    tmp[i] = m_inv[self._g[k](mti)]
                g[t].append(tmp)
        return [Constellation(g=g[i], check=False) for i in xrange(len(m))]

    def __eq__(self, other):
        r"""
        Test of equality.

        TESTS::

            sage: Constellation(['(0,1,2)', None]) == Constellation(['(0,1,2)', None])
            True
            sage: Constellation(['(0,1)','(0,2)',None]) == Constellation(['(0,1)',None,'(0,2)'])
            False
        """
        if not isinstance(other, Constellation_class):
            return False
        return (self._g == other._g)

    def __ne__(self, other):
        r"""
        Test of inequality.

        TESTS::

            sage: Constellation(['(0,1,2)', None]) != Constellation(['(0,1,2)', None])
            False
            sage: Constellation(['(0,1)','(0,2)',None]) != Constellation(['(0,1)',None,'(0,2)'])
            True
        """
        if not isinstance(other, Constellation_class):
            return True
        return (self._g != other._g)

    def is_isomorphic(self, other, return_map=False):
        r"""
        Test of isomorphism.

        Return ``True`` if the constellations are isomorphic
        (*i.e.* related by a common conjugacy) and return the permutation that
        conjugate the two permutations if ``return_map`` is ``True`` in
        such a way that ``self.relabel(m) == other``.

        ALGORITHM:

        uses canonical labels obtained from the method :meth:`relabel`.

        EXAMPLES::

            sage: c = Constellation([[1,0,2],[2,1,0],[0,2,1],None])
            sage: d = Constellation([[2,1,0],[0,2,1],[1,0,2],None])
            sage: answer, mapping = c.is_isomorphic(d,return_map=True)
            sage: print(answer)
            True
            sage: c.relabel(mapping) == d
            True
        """
        if return_map:
            if not(self.degree() == other.degree() and
                   self.length() == other.length()):
                return False, None
            sn, sn_map = self.relabel(return_map=True)
            on, on_map = other.relabel(return_map=True)
            if sn != on:
                return False, None
            return True, sn_map * ~on_map

        return (self.degree() == other.degree() and
                self.length() == other.length() and
                self.relabel() == other.relabel())

    def __cmp__(self, other):
        r"""
        TESTS::

            sage: c1 = Constellation([[1,2,0],None])
            sage: c2 = Constellation([[2,0,1],None])
            sage: c1 < c2
            True
            sage: c2 > c1
            True
        """
        if self.length() != other.length():
            return self.length().__cmp__(other.length())
        if self.degree() != other.degree():
            return self.degree().__cmp__(other.degree())
        for i in xrange(self.length() - 1):
            if self._g[i] != other._g[i]:
                return self._g[i].__cmp__(other._g[i])
        return 0

    def _repr_(self):
        r"""
        Return a string representation.

        EXAMPLES::

            sage: c = Constellation([[1,0,2],[2,1,0],[0,2,1],None])
            sage: c._repr_()
            'Constellation of length 4 and degree 3\ng0 (0,1)(2)\ng1 (0,2)(1)\ng2 (0)(1,2)\ng3 (0,2)(1)'
        """
        s = "Constellation of length {} and degree {}".format(self.length(),
                                                              self.degree())
        for i in xrange(self.length()):
            s += "\ng{} {}".format(i, self._g[i].cycle_string(True))
        return s

    def degree(self):
        r"""
        Return the degree of the constellation.

        The degree of a constellation is the number `n` that
        corresponds to the symmetric group `S(n)` in which the
        permutations of the constellation are defined.

        EXAMPLES::

            sage: c = Constellation([])
            sage: c.degree()
            0
            sage: c = Constellation(['(0,1)',None])
            sage: c.degree()
            2
            sage: c = Constellation(['(0,1)','(0,3,2)(1,5)',None,'(4,3,2,1)'])
            sage: c.degree()
            6
        """
        return self._degree

    def length(self):
        r"""
        Return the number of permutations.

        EXAMPLES::

            sage: c = Constellation(['(0,1)','(0,2)','(0,3)',None])
            sage: c.length()
            4
            sage: c = Constellation(['(0,1,3)',None,'(1,2)'])
            sage: c.length()
            3
        """
        return len(self._g)

    def profile(self, i=None):
        r"""
        Return the profile of ``self``.

        The profile of a constellation is the tuple of partitions
        associated to the conjugacy classes of the permutations of the
        constellation.

        This is also called the passport.

        EXAMPLES::

            sage: c = Constellation(['(0,1,2)(3,4)','(0,3)',None])
            sage: c.profile()
            ([3, 2], [2, 1, 1, 1], [5])
        """
        if i is None:
            return tuple(self.profile(j) for j in xrange(self.length()))
        else:
            parts = [len(cy) for cy in self._g[i].cycle_tuples(True)]
            return Partition(sorted(parts, reverse=True))

    passport = profile

    # ACCESS TO INDIVIDUAL PERMUTATION

    def g(self, i=None):
        r"""
        Return the permutation `g_i` of the constellation.

        INPUT:

        - i -- integer or ``None`` (default)

        If ``None`` , return instead the list of all `g_i`.

        EXAMPLES::

            sage: c = Constellation(['(0,1,2)(3,4)','(0,3)',None])
            sage: c.g(0)
            (0,1,2)(3,4)
            sage: c.g(1)
            (0,3)
            sage: c.g(2)
            (0,4,3,2,1)
            sage: c.g()
            [(0,1,2)(3,4), (0,3), (0,4,3,2,1)]
        """
        from copy import copy
        if i is None:
            return copy(self._g)
        else:
            gi = self._g[i]
            return gi.parent()(gi)

    def g_cycle_tuples(self, i, singletons=False):
        r"""
        Return the tuples associated to the cycles of the permutations
        of ``self``.

        INPUT:

        - `i` -- integer or ``None``
        - singletons -- boolean (default ``False``) whether to include
          fixed points

        If `i` is ``None``, return all of the permutations. Otherwise,
        return just the permutation `g_i`.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(0,4)(1,3)',None])
            sage: c.g_cycle_tuples(0)
            [(0, 1), (2, 3, 4)]
            sage: c.g_cycle_tuples(1)
            [(0, 4), (1, 3)]
            sage: c.g_cycle_tuples(None)
            [[(0, 1), (2, 3, 4)], [(0, 4), (1, 3)], [(0, 3), (1, 2, 4)]]
        """
        if i is None:
            return [s.cycle_tuples(singletons) for s in self._g]
        else:
            return self._g[i].cycle_tuples(singletons)

    def g_cycle_string(self, i, singletons=False):
        r"""
        Return the permutations of a constellation, as cycle strings.

        INPUT:

        - `i` -- integer or ``None``
        - singletons -- boolean (default ``False``) whether to include
          fixed points

        If `i` is ``None``, return all of the permutations. Otherwise,
        return just the permutation `g_i`.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(0,4)(1,3)',None])
            sage: c.g_cycle_string(None)
            ['(0,1)(2,3,4)', '(0,4)(1,3)', '(0,3)(1,2,4)']
            sage: c.g_cycle_string(2)
            '(0,3)(1,2,4)'
        """
        if i is None:
            return [s.cycle_string(singletons) for s in self._g]
        else:
            return self._g[i].cycle_string(singletons)

    def g_next(self, i, j):
        r"""
        Return the image of `j` for the permutation `g_i` in constant time.

        EXAMPLES::

            sage: c = Constellation(['(1,2,0,5)','(2,3,4)(5,1)',None])
            sage: c.g_next(0,0)
            5
            sage: all(c.g(i)(j) == c.g_next(i,j) for i in xrange(3) for j in xrange(6))
            True
        """
        if i is None:
            return [u(j) for u in self._g]
        else:
            return self._g[i](j)

    def g_prev(self, i, j):
        r"""
        Return the image of `j` for the permutation `g_i` in constant time.

        EXAMPLES::

            sage: c = Constellation(['(0,1,2)(3,4)','(0,4,2)',None])
            sage: c.g_prev(0,0)
            2
            sage: all(c.g(i)(c.g_prev(i,j)) == j for i in xrange(3) for j in xrange(5))
            True
        """
        if i is None:
            return [self.g_prev(k, j) for k in xrange(self.length())]
        else:
            for k in xrange(i + 1, self.length()):
                j = self._g[k](j)
            for k in xrange(0, i):
                j = self._g[k](j)
            return j

    def g_orbit(self, i, j):
        r"""
        Return the orbit of `j` under `g_i`.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None])
            sage: c.g_orbit(0,3)
            [2, 3, 4]
            sage: c.g_orbit(1,0)
            [0]
        """
        if i is None:
            return [self.g_orbit(k, j) for k in xrange(self.length())]
        else:
            return self._g[i].orbit(j)

    def relabel(self, perm=None, return_map=False):
        r"""
        Relabel ``self``.

        If ``perm`` is provided then relabel with respect to ``perm``. Otherwise
        use canonical labels. In that case, if ``return_map`` is provided, the
        return also the map used for canonical labels.

        Algorithm:

        the cycle for g(0) are adjacent and the cycle are joined with
        respect to the other permutations. The minimum is taken for
        all possible renumerotations.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None]); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2)(3)
            g2 (0,1,3,2,4)
            sage: c2 = c.relabel(); c2
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,2)(3)(4)
            g2 (0,1,4,3,2)

        The map returned when the option ``return_map`` is set to
        ``True`` can be used to set the relabelling::

            sage: c3, perm = c.relabel(return_map=True)
            sage: c3 == c2 and c3 == c.relabel(perm=perm)
            True

            sage: S5 = SymmetricGroup(range(5))
            sage: d = c.relabel(S5([4,3,1,0,2])); d
            Constellation of length 3 and degree 5
            g0 (0,2,1)(3,4)
            g1 (0)(1)(2,3)(4)
            g2 (0,1,2,4,3)
            sage: d.is_isomorphic(c)
            True

        We check that after a random relabelling the new constellation is
        isomorphic to the initial one::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None])
            sage: p = S5.random_element()
            sage: cc = c.relabel(perm=p)
            sage: cc.is_isomorphic(c)
            True
        """
        if perm is not None:
            g = [[None] * self.degree() for _ in xrange(self.length())]
            for i in xrange(len(perm.domain())):
                for k in xrange(self.length()):
                    g[k][perm(i)] = perm(self._g[k](i))
            return Constellation(g=g, check=False, mutable=self.is_mutable())

        if return_map:
            try:
                return self._normal_form, self._normal_form_map
            except AttributeError:
                pass
        else:
            try:
                return self._normal_form
            except AttributeError:
                pass

        # compute canonical labels
        if not self.is_connected():
            raise ValueError("No canonical labels implemented for"
                             " non connected constellation")

        c_win, m_win = perms_canonical_labels(self._g)
        c_win = self.parent()(c_win, mutable=False, check=False)

        if not self.is_mutable():
            self._normal_form = c_win
            self._normal_form_map = m_win

        c_win._normal_form = c_win
        c_win._normal_form_map = m_win

        if return_map:
            return c_win, m_win
        else:
            return c_win

    # BRAID GROUP ACTION

    def braid_group_action(self, i):
        r"""
        Act on ``self`` as the braid group generator that exchanges
        position `i` and `i+1`.

        INPUT:

        - ``i`` -- integer in `[0, n-1]` where `n` is the length of ``self``

        EXAMPLES::

            sage: sigma = lambda c, i: c.braid_group_action(i)

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None]); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2)(3)
            g2 (0,1,3,2,4)
            sage: sigma(c, 1)
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0,1,3,2,4)
            g2 (0,3)(1)(2)(4)

        Check the commutation relation::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)','(2,5)(0,4)',None])
            sage: d = Constellation(['(0,1,3,5)','(2,3,4)','(0,3,5)',None])
            sage: c13 = sigma(sigma(c, 0), 2)
            sage: c31 = sigma(sigma(c, 2), 0)
            sage: c13 == c31
            True
            sage: d13 = sigma(sigma(d, 0), 2)
            sage: d31 = sigma(sigma(d, 2), 0)
            sage: d13 == d31
            True

        Check the braid relation::

            sage: c121 = sigma(sigma(sigma(c, 1), 2), 1)
            sage: c212 = sigma(sigma(sigma(c, 2), 1), 2)
            sage: c121 == c212
            True
            sage: d121 = sigma(sigma(sigma(d, 1), 2), 1)
            sage: d212 = sigma(sigma(sigma(d, 2), 1), 2)
            sage: d121 == d212
            True
        """
        if i < 0 or i >= self.length():
            txt = "i should be between 0 and {}"
            raise ValueError(txt.format(self.length() - 1))
        j = i + 1
        if j == self.length():   # wrap around the cylinder
            j = 0
        h = self.copy()
        si = self._g[i]
        sj = self._g[j]
        h._g[i] = sj
        h._g[j] = (~sj * si) * sj
        return h

    def braid_group_orbit(self):
        r"""
        Return the graph of the action of the braid group.

        The action is considered up to isomorphism of constellation.

        EXAMPLES::

            sage: c = Constellation(['(0,1)(2,3,4)','(1,4)',None]); c
            Constellation of length 3 and degree 5
            g0 (0,1)(2,3,4)
            g1 (0)(1,4)(2)(3)
            g2 (0,1,3,2,4)
            sage: G = c.braid_group_orbit()
            sage: G.num_verts()
            4
            sage: G.num_edges()
            12
        """
        from sage.graphs.digraph import DiGraph

        G = DiGraph(multiedges=True, loops=True)
        waiting = [self.relabel()]

        while waiting:
            c = waiting.pop()
            G.add_vertex(c)
            for i in xrange(self.length()):
                cc = self.braid_group_action(i).relabel()
                if cc not in G:
                    waiting.append(cc)
                G.add_edge(c, cc, i)
        return G


class Constellations_all(UniqueRepresentation, Parent):
    Element = Constellation_class

    def __init__(self, connected=True):
        r"""
        TESTS::

            sage: TestSuite(Constellations()).run()
        """
        from sage.categories.infinite_enumerated_sets import InfiniteEnumeratedSets
        Parent.__init__(self, category=InfiniteEnumeratedSets())
        self._connected = connected

    def __contains__(self, elt):
        r"""
        TESTS::

            sage: C = Constellations(connected=True)
            sage: D = Constellations(connected=False)
            sage: C([[1,0],None]) in C
            True
            sage: C([[1,0],None]) in D
            True
            sage: D([[1,0],None]) in C
            True
            sage: D([[1,0],None]) in D
            True
            sage: D([[0,1],None]) in C
            False
            sage: D([[0,1],None]) in D
            True
        """
        return isinstance(elt, Constellation_class) and (not self._connected or elt.is_connected())

    def _repr_(self):
        r"""
        Return a string representation.

        TESTS::

            sage: Constellations()    # indirect doctest
            Connected constellations
        """
        if self._connected:
            return "Connected constellations"
        else:
            return "Constellations"

    def _element_constructor_(self, g, check=True, mutable=False):
        r"""
        Return a constellation.

        INPUT:

        - ``g`` -- a list of permutations

        - ``check`` -- boolean (default ``True``) whether to check the input

        - ``mutable`` -- boolean (default ``False``) mutability of the output

        In the given list of permutations, all permutations must be given
        in the same format, which can be:

        - elements of a SymmetricGroup (the same group for all)
        - a list of values
        - a tuple of cycle tuples
        - a string describing the cycles (useful as short notation)

        At most one permutation can be replaced by ``None``,
        in which case it will be computed from the other ones.

        EXAMPLES::

            sage: Constellation([[1,0],[1,0]])  # indirect doctest
            Constellation of length 2 and degree 2
            g0 (0,1)
            g1 (0,1)

        One can use strings to describe the permutations::

            sage: c = Constellation(['(1,2,3)','(0,1,2)','(0,1)(2,3)']); c
            Constellation of length 3 and degree 4
            g0 (0)(1,2,3)
            g1 (0,1,2)(3)
            g2 (0,1)(2,3)
        """
        if g is None or len(g) == 0:
            return self.element_class(self, [], check,
                                      self._connected, mutable)

        if g.count(None) == 0:
            i = None
        elif g.count(None) == 1:
            i = g.index(None)
            del g[i]
        else:
            raise ValueError("only one permutation must be None")

        gg = list(g)
        in_sym_group = False
        if isinstance(gg[0], list):  # perms given as lists of values
            d = max(map(len, gg))
            for p in gg:
                p.extend(xrange(len(p), d))
        elif isinstance(gg[0], tuple):
            # perms given as tuples of cycles
            d = 1 + max(i for p in gg for cyc in p for i in cyc)
        elif isinstance(gg[0], str):  # perms given as strings of cycles
            numbers = [Integer(n) for s in gg for c_str in s[1:-1].split(')(')
                       for n in c_str.replace(' ', '').split(',')]
            d = 1 + max(numbers)

        elif gg[0].parent() in Groups:
            d = len(gg[0].domain())
            in_sym_group = True

        # now perms can be handled by SymmetricGroup if needed

        Sd = SymmetricGroup(range(d))
        if not in_sym_group:
            gg = [Sd(u) for u in gg]

        if i is not None:
            h = Sd.one()
            for p in gg[i:]:
                h *= p
            for p in gg[:i]:
                h *= p
            gg.insert(i, ~h)

        return self.element_class(self, gg, check, self._connected, mutable)

    def an_element(self):
        r"""
        Return a constellation.

        EXAMPLES::

            sage: Constellations().an_element()
            Constellation of length 2 and degree 2
            g0 (0,1)
            g1 (0,1)
        """
        return Constellations(2, 2).an_element()

    def __iter__(self):
        r"""
        TESTS::

            sage: I = iter(Constellations())
            sage: for _ in xrange(100): print(I.next())
            Constellation of length 1 and degree 1
            g0 (0)
            Constellation of length 2 and degree 1
            g0 (0)
            g1 (0)
            Constellation of length 3 and degree 1
            g0 (0)
            g1 (0)
            g2 (0)
            Constellation of length 2 and degree 2
            g0 (0,1)
            g1 (0,1)
            ...
            Constellation of length 4 and degree 3
            g0 (0,1)(2)
            g1 (0,1)(2)
            g2 (0)(1,2)
            g3 (0)(1,2)
            Constellation of length 4 and degree 3
            g0 (0,1)(2)
            g1 (0,1)(2)
            g2 (0,2)(1)
            g3 (0,2)(1)
        """
        n = 2
        while True:
            for d in xrange(1, n):
                l = n - d
                for c in Constellations(l, d, connected=self._connected):
                    yield c
            n += 1


class Constellations_ld(UniqueRepresentation, Parent):
    r"""
    Constellations of given length and degree.

    EXAMPLES::

        sage: C = Constellations(2,3); C
        Connected constellations of length 2 and degree 3
        sage: C([[1,2,0],[2,0,1]])
        Constellation of length 2 and degree 3
        g0 (0,1,2)
        g1 (0,2,1)
        sage: C.cardinality()
        2
        sage: Constellations(2,3,connected=False).cardinality()
        6
    """
    def __init__(self, length, degree, connected=True):
        """
        TESTS::

            sage: TestSuite(Constellations(length=6,degree=4)).run(skip='_test_cardinality')
        """
        from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets
        Parent.__init__(self, facade=Constellations_all(),
                        category=FiniteEnumeratedSets())
        self._length = Integer(length)
        self._degree = Integer(degree)
        if self._length <= 0:
            raise ValueError("length should be a positive integer")
        if self._degree <= 0:
            raise ValueError("degree should be a positive integer")
        self._connected = bool(connected)

    def __contains__(self, elt):
        r"""
        TESTS::

            sage: C = Constellations(2,3,connected=True)
            sage: D = Constellations(2,3,connected=False)
            sage: C([[2,0,1],None]) in C
            True
            sage: D([[2,0,1],None]) in C
            True
            sage: D([[2,0,1],None]) in D
            True
            sage: D([[0,1,2],None]) in C
            False
            sage: D([[0,1,2],None]) in D
            True
        """
        if elt not in Constellations(connected=self._connected):
            return False
        return elt.length() == self._length and elt.degree() == self._degree

    def first(self):
        r"""
        Return the first element in lexicographic order.

        EXAMPLES::

            sage: const = Constellations(3,3); const
            Connected constellations of length 3 and degree 3
            sage: const.first()
            Constellation of length 3 and degree 3
            g0 (0,1,2)
            g1 (0,1,2)
            g2 (0,1,2)
        """
        if self._connected:
            g = [(tuple(range(self._degree)),)] * self._length
        else:
            g = [range(self._degree)] * self._length
        return self(g, check=False)

    def last(self):
        r"""
        Return the last element in lexicographic order.

        EXAMPLES::

            sage: const=Constellations(3,3);const
            Connected constellations of length 3 and degree 3
            sage: const.last()
            Constellation of length 3 and degree 3
            g0 (0,2,1)
            g1 (0,2,1)
            g2 (0,2,1)
        """
        if self._connected:
            g = [(tuple(range(self._degree - 1, -1, -1)),)] * self._length
        else:
            g = [range(self._degree - 1, -1, -1)] * self._length
        return Constellation(g, check=False, mutable=False)

    def _repr_(self):
        """
        TESTS::

            sage: Constellations(3,3)._repr_()
            'Connected constellations of length 3 and degree 3'
            sage: Constellations(3,3,connected=False)._repr_()
            'Constellations of length 3 and degree 3'
        """
        s = "of length {} and degree {}".format(self._length, self._degree)
        if self._connected:
            return "Connected constellations " + s
        return "Constellations " + s

    def __iter__(self):
        """
        Iterator over all constellations of given degree and length.

        EXAMPLES::

            sage: const = Constellations(3,3); const
            Connected constellations of length 3 and degree 3
            sage: len([v for v in const])
            26

        One can check the first few terms of sequence :oeis:`220754`::

            sage: Constellations(4,1).cardinality()
            1
            sage: Constellations(4,2).cardinality()
            7
            sage: Constellations(4,3).cardinality()
            194
            sage: Constellations(4,4).cardinality()  # long time
            12858
        """
        from itertools import product

        if self._length == 1:
            if self._degree == 1:
                yield self([[0]])
            return

        S = SymmetricGroup(range(self._degree))
        for p in product(S, repeat=self._length - 1):
            if self._connected and not perms_are_connected(p, self._degree):
                continue
            yield self(list(p) + [None], check=False)

    def random_element(self, mutable=False):
        r"""
        Return a random element.

        This is found by trial and rejection, starting from
        a random list of permutations.

        EXAMPLES::

            sage: const = Constellations(3,3)
            sage: const.random_element()
            Constellation of length 3 and degree 3
            ...
            ...
            ...
            sage: c = const.random_element()
            sage: c.degree() == 3 and c.length() == 3
            True
        """
        from sage.groups.perm_gps.permgroup import PermutationGroup

        l = self._length
        d = self._degree
        Sd = SymmetricGroup(range(d))

        g = [Sd.random_element() for _ in xrange(l - 1)]
        G = PermutationGroup(g)
        while not G.degree() == d or (self._connected and
                                      not G.is_transitive()):
            g = [Sd.random_element() for _ in xrange(l - 1)]
            G = PermutationGroup(g)

        return self([sigma.domain() for sigma in g] + [None], mutable=mutable)

    def _element_constructor_(self, *data, **options):
        r"""
        Build an element of ``self``.

        EXAMPLES::

            sage: C = Constellations(2,3)
            sage: C([[1,2,0],[2,0,1]])
            Constellation of length 2 and degree 3
            g0 (0,1,2)
            g1 (0,2,1)
            sage: C([[2,1,0],[2,1,0]])
            Traceback (most recent call last):
            ...
            ValueError: not connected
        """
        c = Constellations(connected=self._connected)(*data, **options)
        txt = "unable to build a constellation of {} {} from the given data"
        if c.degree() != self._degree:
            raise ValueError("degree", txt.format(self._degree))
        if c.length() != self._length:
            raise ValueError("length", txt.format(self._length))
        return c

    def an_element(self):
        r"""
        Return a constellation in ``self``.

        EXAMPLES::

            sage: Constellations(2,3).an_element()
            Constellation of length 2 and degree 3
            g0 (0,2,1)
            g1 (0,1,2)
            sage: Constellations(7,3).an_element()
            Constellation of length 7 and degree 3
            g0 (0,2,1)
            g1 (0,1,2)
            g2 (0)(1)(2)
            g3 (0)(1)(2)
            g4 (0)(1)(2)
            g5 (0)(1)(2)
            g6 (0)(1)(2)
        """
        if self._degree == 0 and self._length == 0:
            return self()([])
        elif self._length == 1:
            if self._degree > 1:
                from sage.categories.sets_cat import EmptySetError
                raise EmptySetError
            return self()([[0]])

        d = self._degree
        if self._connected:
            g = [[d - 1] + range(d - 1), range(1, d) + [0]]
            g += [range(d)] * (self._length - 2)
        else:
            g = [range(d)] * self._length
        return self(g)

    def braid_group_action(self):
        r"""
        Return a list of graphs that corresponds to the braid group action on
        ``self`` up to isomorphism.

        OUTPUT:

        - list of graphs

        EXAMPLES::

            sage: C = Constellations(3,3)
            sage: C.braid_group_action()
            [Looped multi-digraph on 3 vertices,
             Looped multi-digraph on 3 vertices,
             Looped multi-digraph on 1 vertex]
        """
        G = []
        for c in self:
            c = c.relabel()
            if any(c in g for g in G):
                continue
            G.append(c.braid_group_orbit())
        return G

    def braid_group_orbits(self):
        r"""
        Return the orbits under the action of braid group.

        EXAMPLES::

            sage: C = Constellations(3,3)
            sage: O = C.braid_group_orbits()
            sage: len(O)
            3
            sage: [x.profile() for x in O[0]]
            [([1, 1, 1], [3], [3]), ([3], [1, 1, 1], [3]), ([3], [3], [1, 1, 1])]
            sage: [x.profile() for x in O[1]]
            [([2, 1], [2, 1], [3]), ([2, 1], [3], [2, 1]), ([3], [2, 1], [2, 1])]
            sage: [x.profile() for x in O[2]]
            [([3], [3], [3])]
        """
        return [g.vertices() for g in self.braid_group_action()]


class Constellations_p(UniqueRepresentation, Parent):
    r"""
    Constellations with fixed profile.

    EXAMPLES::

        sage: C = Constellations([[3,1],[3,1],[2,2]]); C
        Constellations with profile ([3, 1], [3, 1], [2, 2])
        sage: C.cardinality()
        24
        sage: C.first()
        Constellation of length 3 and degree 4
        g0 (0)(1,2,3)
        g1 (0,2,3)(1)
        g2 (0,2)(1,3)
        sage: C.last()
        Constellation of length 3 and degree 4
        g0 (0,2,1)(3)
        g1 (0,3,1)(2)
        g2 (0,2)(1,3)

    Note that the cardinality can also be computed using characters of the
    symmetric group (Frobenius formula)::

        sage: P = Partitions(4)
        sage: p1 = Partition([3,1])
        sage: p2 = Partition([3,1])
        sage: p3 = Partition([2,2])
        sage: i1 = P.cardinality() - P.rank(p1) - 1
        sage: i2 = P.cardinality() - P.rank(p2) - 1
        sage: i3 = P.cardinality() - P.rank(p3) - 1
        sage: s = 0
        sage: for c in SymmetricGroup(4).irreducible_characters():
        ....:     v = c.values()
        ....:     s += v[i1] * v[i2] * v[i3] / v[0]
        sage: c1 = p1.conjugacy_class_size()
        sage: c2 = p2.conjugacy_class_size()
        sage: c3 = p3.conjugacy_class_size()
        sage: print(c1 * c2 * c3 / factorial(4)**2 * s)
        1

    The number obtained above is up to isomorphism. And we can check::

        sage: len(C.isomorphism_representatives())
        1
    """
    def __init__(self, profile, connected=True):
        r"""
        OPTIONS:

        - ``profile`` -- a list of integer partitions of the same integer

        - ``connected`` -- a boolean (default: ``True``) that specify
          if we consider only connected constellations.

        TESTS::

            sage: C = Constellations([(3,1),(3,1),(2,2)])
            sage: TestSuite(C).run()
        """
        l = Integer(len(profile))
        d = Integer(sum(profile[0]))
        for p in profile[1:]:
            if sum(p) != d:
                raise ValueError("all partition in the passport should "
                                 "have the same sum.")

        from sage.categories.finite_enumerated_sets import FiniteEnumeratedSets
        Parent.__init__(self, facade=Constellations_all(), category=FiniteEnumeratedSets())
        self._profile = profile
        self._degree = d
        self._length = l
        self._connected = connected

    def _repr_(self):
        r"""
        TESTS::

            sage: Constellations(([3,2],[2,2,1]))
            Constellations with profile ([3, 2], [2, 2, 1])
        """
        return "Constellations with profile %s" % (self._profile,)

    def isomorphism_representatives(self):
        r"""
        Return a set of isomorphism representative of ``self``.

        EXAMPLES::

            sage: C = Constellations([[5], [4,1], [3,2]])
            sage: C.cardinality()
            240
            sage: ir = sorted(C.isomorphism_representatives())
            sage: len(ir)
            2
            sage: ir[0]
            Constellation of length 3 and degree 5
            g0 (0,1,2,3,4)
            g1 (0)(1,2,3,4)
            g2 (0,4,2)(1,3)
            sage: ir[1]
            Constellation of length 3 and degree 5
            g0 (0,1,2,3,4)
            g1 (0)(1,4,2,3)
            g2 (0,4)(1,2,3)
        """
        result = set()
        for c in self:
            cc = c.relabel()
            if cc not in result:
                result.add(cc)
        return result

    def _element_constructor_(self, *data, **options):
        r"""
        Build an element of ``self``.

        TESTS::

            sage: C = Constellations([(3,1),(3,1),(2,2)])
            sage: c = C(['(1,2,3)','(0,1,2)','(0,1)(2,3)']); c
            Constellation of length 3 and degree 4
            g0 (0)(1,2,3)
            g1 (0,1,2)(3)
            g2 (0,1)(2,3)
            sage: C(['(1,2,3)','(0,1,3)',None])
            Traceback (most recent call last):
            ...
            ValueError: unable to build a constellation
            with profile ([3, 1], [3, 1], [2, 2]) from the given data
        """
        c = Constellations(connected=self._connected)(*data, **options)
        if options.get('check', True):
            if c.profile() != self._profile:
                txt = "unable to build a constellation with profile {} from the given data"
                raise ValueError(txt.format(self._profile))
        return c

    def __iter__(self):
        r"""
        Iterator of the elements in ``self``.

        TESTS::

            sage: C = Constellations([(3,1),(3,1),(2,2)])
            sage: for c in C: print(c)
            Constellation of length 3 and degree 4
            g0 (0)(1,2,3)
            g1 (0,2,3)(1)
            g2 (0,2)(1,3)
            Constellation of length 3 and degree 4
            g0 (0)(1,2,3)
            g1 (0,3,1)(2)
            g2 (0,3)(1,2)
            ...
            Constellation of length 3 and degree 4
            g0 (0,2,1)(3)
            g1 (0,2,3)(1)
            g2 (0,3)(1,2)
            Constellation of length 3 and degree 4
            g0 (0,2,1)(3)
            g1 (0,3,1)(2)
            g2 (0,2)(1,3)
        """
        from sage.misc.mrange import cartesian_product_iterator

        if self._length == 1:
            if self._degree == 1:
                yield self([[0]])
            return

        S = SymmetricGroup(srange(self._degree))
        profile = list(self._profile)[:-1]
        for p in cartesian_product_iterator([S.conjugacy_class(pi)
                                             for pi in profile]):
            if self._connected and not perms_are_connected(p, self._degree):
                continue
            c = Constellations(connected=self._connected)(list(p) + [None],
                                                          check=False)
            if c.profile() == self._profile:
                yield c

    def braid_group_action(self):
        r"""
        List of graphs that corresponds to the braid group action on
        ``self`` up to isomorphism.

        OUTPUT:

        - list of graphs

        EXAMPLES::

            sage: C = Constellations(3,3)
            sage: C.braid_group_action()
            [Looped multi-digraph on 3 vertices,
             Looped multi-digraph on 3 vertices,
             Looped multi-digraph on 1 vertex]
        """
        G = []
        for c in self:
            c = c.relabel()
            if any(c in g for g in G):
                continue
            G.append(c.braid_group_orbit())
        return G

    def braid_group_orbits(self):
        r"""
        Return the orbits under the action of braid group.

        EXAMPLES::

            sage: C = Constellations(3,3)
            sage: O = C.braid_group_orbits()
            sage: len(O)
            3
            sage: [x.profile() for x in O[0]]
            [([1, 1, 1], [3], [3]), ([3], [1, 1, 1], [3]),
            ([3], [3], [1, 1, 1])]
            sage: [x.profile() for x in O[1]]
            [([2, 1], [2, 1], [3]), ([2, 1], [3], [2, 1]),
            ([3], [2, 1], [2, 1])]
            sage: [x.profile() for x in O[2]]
            [([3], [3], [3])]
        """
        return [g.vertices() for g in self.braid_group_action()]

# *************************************************************************
#                          auxiliary functions
# *************************************************************************


def perms_are_connected(g, n):
    """
    Checks that the action of the generated group is transitive

    INPUT:

    - a list of permutations of `[0, n-1]` (in a SymmetricGroup)

    - an integer `n`

    EXAMPLES::

        sage: from sage.combinat.constellation import perms_are_connected
        sage: S = SymmetricGroup(range(3))
        sage: perms_are_connected([S([0,1,2]),S([0,2,1])],3)
        False
        sage: perms_are_connected([S([0,1,2]),S([1,2,0])],3)
        True
    """
    from sage.graphs.graph import Graph
    G = Graph()
    if g:
        G.add_vertices(g[0].domain())
    for p in g:
        G.add_edges(p.dict().items())
    return G.is_connected()


def perms_canonical_labels_from(x, y, j0, verbose=False):
    r"""
    Return canonical labels for ``x``, ``y`` that starts at ``j0``

    .. WARNING:

        The group generated by ``x`` and the elements of ``y`` should be
        transitive.

    INPUT:

    - ``x`` -- list - a permutation of `[0, ..., n]` as a list

    - ``y`` -- list of permutations of `[0, ..., n]` as a list of lists

    - ``j0`` -- an index in [0, ..., n]

    OUTPUT:

    mapping: a permutation that specify the new labels

    EXAMPLES::

        sage: from sage.combinat.constellation import perms_canonical_labels_from
        sage: S = SymmetricGroup(range(3))
        sage: perms_canonical_labels_from(S([0,1,2]),[S([1,2,0])],0)
        ()
        sage: perms_canonical_labels_from(S([1,0,2]),[S([2,0,1])],0)
        ()
        sage: perms_canonical_labels_from(S([1,0,2]),[S([2,0,1])],1)
        (0,1)
        sage: perms_canonical_labels_from(S([1,0,2]),[S([2,0,1])],2)
        (0,2)
    """
    n = len(x.domain())
    S = x.parent()

    k = 0
    mapping = [None] * n
    waiting = [[] for i in xrange(len(y))]

    while k < n:
        if verbose:
            print "complete from", j0
        # initialize at j0
        mapping[j0] = k
        waiting[0].append(j0)
        k += 1
        # complete x cycle from j0
        j = x(j0)
        while j != j0:
            mapping[j] = k
            waiting[0].append(j)
            k += 1
            j = x(j)
        if verbose:
            print "completed cycle mapping=", mapping

        # find another guy
        if verbose:
            print "try to find somebody in", waiting
        l = 0
        while l < len(waiting):
            i = 0
            while i < len(waiting[l]):
                j1 = waiting[l][i]
                if mapping[y[l](j1)] is None:
                    break
                i += 1

            if i == len(waiting[l]):  # not found: go further in waiting
                if l < len(waiting) - 1:
                    waiting[l + 1].extend(waiting[l])
                waiting[l] = []
                l += 1
                i = 0

            else:  # found: complete cycle from new guy
                j0 = y[l](j1)
                if l < len(waiting) - 1:
                    waiting[l + 1].extend(waiting[l][:i + 1])
                del waiting[l][:i + 1]
                break

    return S(mapping)


def perms_canonical_labels(p, e=None):
    """
    Relabel a list with a common conjugation such that two conjugated
    lists are relabeled the same way.

    INPUT:

    - ``p`` is a list of at least 2 permutations

    - ``e`` is None or a list of integer in the domain of the
      permutations. If provided, then the renumbering algorithm is
      only performed from the elements of ``e``.

    OUTPUT:

    - a pair made of a list of permutations (as a list of lists) and a
      list that corresponds to the conjugacy used.

    EXAMPLES::

        sage: from sage.combinat.constellation import perms_canonical_labels
        sage: S = SymmetricGroup(range(4))
        sage: l0 = [S([2,0,3,1]),S([3,1,2,0]),S([0,2,1,3])]
        sage: l, m = perms_canonical_labels(l0); l
        [(0,1,2,3), (1,3), (0,2)]

        sage: [~m * u * m for u in l0] == l
        True

        sage: perms_canonical_labels([])
        Traceback (most recent call last):
        ...
        ValueError: input must have length >= 2
    """
    if not len(p) > 1:
        raise ValueError('input must have length >= 2')
    n = len(p[0].domain())

    c_win = None
    m_win = range(n)

    x = p[0]
    y = p[1:]

    if e is None:
        e = range(n)

    # get canonical label from i in to_test and compare
    while e:
        i = e.pop()
        m_test = perms_canonical_labels_from(x, y, i)
        inv_m_test = ~m_test
        c_test = [inv_m_test * u * m_test for u in p]
        if c_win is None or c_test < c_win:
            c_win = c_test
            m_win = m_test

    return c_win, m_win
