r"""
Tutorial: Using Free Modules and Vector Spaces

.. MODULEAUTHOR:: Jason Bandlow

In this tutorial, we show how to construct and manipulate free modules
and vector spaces and their elements.

Sage currently provides two implementations of free modules:
:class:`FreeModule` and :class:`CombinatorialFreeModule`. The
distinction between the two is mostly an accident in history. The
later allows for the basis to be indexed by any kind of objects,
instead of just `0,1,2,...`. They also differ by feature set and
efficiency. Eventually, both implementations will be merged under the
name :class:`FreeModule`. In the mean time, we focus here on
:class:`CombinatorialFreeModule`. We recommend to start by browsing
the documentation.

::

    sage: CombinatorialFreeModule?

We begin with a minimal example. What does this give us?

::

    sage: G = Zmod(5)
    sage: A = CombinatorialFreeModule(ZZ, G)
    sage: A.an_element()
    2*B[0] + 2*B[1] + 3*B[2]

We can use any set whose elements are immutable to index the
basis. Here are some `\ZZ`-free modules; what is the indexing set for
the basis in each case?

    sage: A = CombinatorialFreeModule(ZZ, CC); A.an_element()
    B[1.00000000000000*I]
    sage: A = CombinatorialFreeModule(ZZ, Partitions(NonNegativeIntegers(), max_part=3)); A.an_element()
    B[[]] + 2*B[[1]] + 3*B[[2]]
    sage: A = CombinatorialFreeModule(ZZ, ['spam', 'eggs', 42]); A.an_element()
    2*B['eggs'] + 2*B['spam'] + 3*B[42]

::

    sage: A = CombinatorialFreeModule(ZZ, ([1],[2],[3])); A.an_element()
    Traceback (most recent call last):
    ...
    TypeError: unhashable type: 'list'

We can customize the name of the basis however we want::

    sage: A = CombinatorialFreeModule(ZZ, Zmod(5), prefix='a'); A.an_element()
    a[0] + 3*a[1] + 3*a[2]

Let us do some arithmetic with elements of `A`::

    sage: f = A.an_element(); f
    a[0] + 3*a[1] + 3*a[2]

    sage: 2*f
    2*a[0] + 6*a[1] + 6*a[2]

    sage: 2*f - f
    a[0] + 3*a[1] + 3*a[2]

This does not work yet::

    sage: a[0] + 3*a[1]
    Traceback (most recent call last):
    ...
    NameError: name 'a' is not defined

To construct elements directly, we must first get the basis for the
module::

    sage: a = A.basis()
    sage: a[0] + 3*a[1]
    a[0] + 3*a[1]

Copy-pasting works if the prefix matches the name of the basis::

    sage: a[0] + 3*a[1] + 3*a[2] == f
    True

Be careful, that the input is currently *not* checked::

    sage: a['is'] + a['this'] + a['a'] + a['bug']
    a['a'] + a['bug'] + a['is'] + a['this']

    sage: a
    Lazy family (Term map from Ring of integers modulo 5 to Free module generated by Ring of integers modulo 5 over Integer Ring(i))_{i in Ring of integers modulo 5}

``A.basis()`` models the family `(B_i)_{i \in \ZZ_5}`.  See the
documentation for :class:`Family` for more information::

    sage: Family?

The elements of our module come with many methods for
exploring and manipulating them:

.. skip:

::

    sage: f.

Some notation:

 * *term*: ``coefficient * basis_element``
 * *monomial*: ``basis_element`` *without* a coefficient
 * *support*: the index of a ``basis_element``
 * *item* : a :class:`tuple` ``(index, coefficient)``

Note that elements are printed starting with the *least* index (for
lexicographic order by default). Leading/trailing refers to the
greatest/least index, respectively::

    sage: f
    a[0] + 3*a[1] + 3*a[2]
    sage: "Leading term: ",f.leading_term()
    Leading term:  3*a[2]
    sage: print "Leading monomial: ",f.leading_monomial()
    Leading monomial:  a[2]
    sage: print "Leading support: ",f.leading_support()
    Leading support:  2
    sage: print "Leading coefficient: ",f.leading_coefficient()
    Leading coefficient:  3
    sage: print "Leading item: ",f.leading_item()
    Leading item:  (2, 3)

    sage: f.leading_term
    sage: print "Support: ",f.support()
    Support:  [0, 1, 2]
    sage: print "Monomials: ",f.monomials()
    Monomials:  [a[0], a[1], a[2]]
    sage: print "Coefficients: ",f.coefficients()
    Coefficients:  [1, 3, 3]

We can iterate through the items in an element::

    sage: for index, coeff in f:
    ....:     print "The coefficient of a_{%s} is %s"%(index, coeff)
    The coefficient of a_{0} is 1
    The coefficient of a_{1} is 3
    The coefficient of a_{2} is 3
    sage: # This uses the fact that f can be thought of as a dictionary  index-->coefficient
    sage: print f[0], f[1], f[2]
    1 3 3
    sage: # This dictionary can be accessed explicitly with the monomial_coefficients method
    sage: f.monomial_coefficients()
    {0: 1, 1: 3, 2: 3}

The parent (`A` in our example) has several utility methods for
constructing elements::

    sage: A.
    sage: A.zero()
    0
    sage: A.sum_of_monomials(i for i in Zmod(5) if i > 2)
    a[3] + a[4]
    sage: A.sum_of_terms((i+1,i) for i in Zmod(5) if i > 2)
    4*a[0] + 3*a[4]
    sage: A.sum(ZZ(i)*a[i+1] for i in Zmod(5) if i > 2)  # Note coeff is not (currently) implicitly coerced
    4*a[0] + 3*a[4]

Note that it is safer to use ``A.sum()`` than to use ``sum()``, in
case the input is an empty iterable::

    sage: print A.sum([]),':', parent(A.sum([]))
    0 : Free module generated by Ring of integers modulo 5 over Integer Ring
    sage: print sum([]),':', parent(sum([]))
    0 : <type 'int'>

The ``map`` methods are useful to transform elements::

    sage: f.map_
    sage: print f,"-->", f.map_support     (lambda i  : i+3)
    a[0] + 3*a[1] + 3*a[2] --> 3*a[0] + a[3] + 3*a[4]
    sage: print f,"-->", f.map_coefficients(lambda c  : c-1)
    a[0] + 3*a[1] + 3*a[2] --> 2*a[1] + 2*a[2]
    sage: print f,"-->", f.map_term        (lambda i,c: (i+3,c-1))
    a[0] + 3*a[1] + 3*a[2] --> 2*a[0] + 2*a[4]


``f.map_mc`` is a deprecated synonym for ``f.map_term``.

Note that ``term`` and ``item`` are not yet used completely consistently.

"""
