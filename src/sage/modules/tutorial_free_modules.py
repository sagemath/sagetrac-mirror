r"""
Tutorial: Using Free Modules and Vector Spaces

.. MODULEAUTHOR:: Jason Bandlow

In this tutorial, we show how to construct and manipulate free modules
and vector spaces and their elements.

Sage currently provides two implementations of free modules:
:class:`FreeModule` and :class:`CombinatorialFreeModule`. The
distinction between the two is mostly an accident in history. The
later allows for the basis to be indexed by any kind of objects,
instead of just `0,1,2,...`. They also differ by feature set and
efficiency. Eventually, both implementations will be merged under the
name :class:`FreeModule`. In the mean time, we focus here on
:class:`CombinatorialFreeModule`. We recommend to start by browsing
the documentation.

::

    sage: CombinatorialFreeModule?

We begin with a minimal example. What does this give us?

::

    sage: G = Zmod(5)
    sage: A = CombinatorialFreeModule(ZZ, G)
    sage: A.an_element()
    2*B[0] + 2*B[1] + 3*B[2]

We can use any set whose elements are immutable to index the
basis. Here are some `\ZZ`-free modules; what is the indexing set for
the basis in each case?

    sage: A = CombinatorialFreeModule(ZZ, CC); A.an_element()
    B[1.00000000000000*I]
    sage: A = CombinatorialFreeModule(ZZ, Partitions(NonNegativeIntegers(), max_part=3)); A.an_element()
    B[[]] + 2*B[[1]] + 3*B[[2]]
    sage: A = CombinatorialFreeModule(ZZ, ['spam', 'eggs', 42]); A.an_element()
    2*B['eggs'] + 2*B['spam'] + 3*B[42]

::

    sage: A = CombinatorialFreeModule(ZZ, ([1],[2],[3])); A.an_element()
    Traceback (most recent call last):
    ...
    TypeError: unhashable type: 'list'

We can customize the name of the basis however we want::

    sage: A = CombinatorialFreeModule(ZZ, Zmod(5), prefix='a'); A.an_element()
    a[0] + 3*a[1] + 3*a[2]

Let us do some arithmetic with elements of `A`::

    sage: f = A.an_element(); f
    a[0] + 3*a[1] + 3*a[2]

    sage: 2*f
    2*a[0] + 6*a[1] + 6*a[2]

    sage: 2*f - f
    a[0] + 3*a[1] + 3*a[2]

This does not work by default::

    sage: a[0] + 3*a[1]
    Traceback (most recent call last):
    ...
    NameError: name 'a' is not defined

To construct elements directly, we must first get the basis for the
module::

    sage: a = A.basis()
    sage: a[0] + 3*a[1]
    a[0] + 3*a[1]

Copy-pasting works if the prefix matches the name of the basis::

    sage: a[0] + 3*a[1] + 3*a[2] == f
    True

Be careful that the input is currently *not* checked::

    sage: a['is'] + a['this'] + a['a'] + a['bug']
    a['a'] + a['bug'] + a['is'] + a['this']

    sage: a
    Lazy family (Term map from Ring of integers modulo 5 to Free module generated by Ring of integers modulo 5 over Integer Ring(i))_{i in Ring of integers modulo 5}

``A.basis()`` models the family `(B_i)_{i \in \ZZ_5}`.  See the
documentation for :class:`Family` for more information::

    sage: Family?

The elements of our module come with many methods for exploring and
manipulating them:

.. skip:

::

    sage: f.

Some definitions:

 * A *monomial* is an element of the basis `B_i`;
 * A *term* is an element of the basis multiplied by a non zero
   *coefficient*: `c B_i`;
 * The support of that term is `i`.
 * The corresponding *item* is the :class:`tuple` ``(i, c)``.
 * The *support* of an element `f` is the collection of indices `i`
   such that `B_i` appears in `f` with non zero coefficient.
 * The *monomials*, *terms*, *items*, and *coefficients* of an element
   `f` are defined accordingly.
 * *Leading*/*trailing* refers to the *greatest*/*least* index.
   Elements are printed starting with the *least* index (for
   lexicographic order by default).

Let us investigate those notations on our example::

    sage: f
    a[0] + 3*a[1] + 3*a[2]
    sage: f.leading_term()
    3*a[2]
    sage: f.leading_monomial()
    a[2]
    sage: f.leading_support()
    2
    sage: f.leading_coefficient()
    3
    sage: f.leading_item()
    (2, 3)

    sage: f.support()
    [0, 1, 2]
    sage: f.monomials()
    [a[0], a[1], a[2]
    sage: f.coefficients()
    [1, 3, 3]

We can iterate through the items of an element::

    sage: for index, coeff in f:
    ....:     print("The coefficient of a_{%s} is %s"%(index, coeff))
    The coefficient of a_{0} is 1
    The coefficient of a_{1} is 3
    The coefficient of a_{2} is 3

This element can be thought of as a dictionary index-->coefficient::

    sage: f[0], f[1], f[2]
    1, 3, 3

This dictionary can be accessed explicitly with the monomial_coefficients method::

    sage: f.monomial_coefficients()
    {0: 1, 1: 3, 2: 3}

The parent (`A` in our example) has several utility methods for
constructing elements::

    sage: A.
    sage: A.zero()
    0
    sage: A.sum_of_monomials(i for i in Zmod(5) if i > 2)
    a[3] + a[4]
    sage: A.sum_of_terms((i+1,i) for i in Zmod(5) if i > 2)
    4*a[0] + 3*a[4]
    sage: A.sum(ZZ(i)*a[i+1] for i in Zmod(5) if i > 2)  # Note coeff is not (currently) implicitly coerced
    4*a[0] + 3*a[4]

Is safer to use ``A.sum()`` than to use ``sum()``: in case the input
is an empty iterable, it makes sure the zero of `A` is returned, and
not a plain `0`:

    sage: A.sum([]), parent(A.sum([]))
    0, Free module generated by Ring of integers modulo 5 over Integer Ring
    sage: sum([]),   parent(sum([]))
    0 : <type 'int'>

The ``map`` methods are useful to transform elements::

    sage: f
    a[0] + 3*a[1] + 3*a[2]
    sage: f.map_support(lambda i: i+3)
    3*a[0] + a[3] + 3*a[4]
    sage: f.map_coefficients(lambda c: c-1)
    2*a[1] + 2*a[2]
    sage: f.map_term(lambda i,c: (i+3,c-1))
    a[0] + 3*a[1] + 3*a[2] --> 2*a[0] + 2*a[4]

Note: the later function would be more consistently named ``map_item``.

"""
