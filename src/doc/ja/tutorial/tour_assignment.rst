
代入，等式と算術演算
====================================

一部に些細な例外はあるが，Sageはプログラミング言語Pythonに拠っているので，Pythonの入門書があればSageを学ぶ助けになるはずだ．

Sageでは代入に記号 ``=`` ，比較演算には ``==`` ， ``<=`` ， ``>=`` ， ``<`` と ``>`` を用いる．

::

    sage: a = 5
    sage: a
    5
    sage: 2 == 2
    True
    sage: 2 == 3
    False
    sage: 2 < 3
    True
    sage: a == 5
    True

基本的な演算操作は全て可能だ:

::

    sage: 2**3    #  ** は「べき乗」の意味
    8
    sage: 2^3     #  ^ は**と同じ「べき乗」の意味 (Pythonでは通用しない)
    8
    sage: 10 % 3 #  整数については % はmod, つまり余りを与える
    1
    sage: 10/4
    5/2
    sage: 10//4   # 整数に対して // は商を返す
    2
    sage: 4 * (10 // 4) + 10 % 4 == 10
    True
    sage: 3^2*4 + 2%5
    38

``3^2*4 + 2%5`` のような式の値は，演算子が適用される順序に依存する． 
付録にある :ref:`section-precedence` の表を見ると演算子の適用順序が判る．

Sageでは，一般によく使われる数学関数も豊富に用意されている．
ここでは，ほんの一部しか例を示すことができないが:

::

    sage: sqrt(3.4)
    1.84390889145858
    sage: sin(5.135)
    -0.912021158525540
    sage: sin(pi/3)
    1/2*sqrt(3)

いちばん最後の例のように，数式の中には近似値ではなく「厳密」な値を返してくるものもある．
近似値が欲しいときは関数 ``n`` あるいはメソッド ``n`` を使う(両者とも同じ説明的な名称 ``numerical_approx`` を持つが，関数 ``N`` は ``n`` と同じものだ)．
双方の精度ビット数を指定する引数 ``prec`` と有効十進桁数を指定する引数 ``digits`` はオプションで，精度53ビットがデフォルト値になる．
::

    sage: exp(2)
    e^2
    sage: n(exp(2))
    7.38905609893065
    sage: sqrt(pi).numerical_approx()
    1.77245385090552
    sage: sin(10).n(digits=5)
    -0.54402
    sage: N(sin(10),digits=10)
    -0.5440211109
    sage: numerical_approx(pi, prec=200)
    3.1415926535897932384626433832795028841971693993751058209749

Pythonのデータはダイナミックに型付けされ，変数を通して参照される値にはデータの型情報が付随している．
いずれにせよ、Pythonの変数はそのスコープ内ではいかなる型の変数でも保持することができる:

::

    sage: a = 5   # aは整数
    sage: type(a)
    <type 'sage.rings.integer.Integer'>
    sage: a = 5/3  # aは有理数になった
    sage: type(a)
    <type 'sage.rings.rational.Rational'>
    sage: a = 'hello'  # ここでaは文字列
    sage: type(a)
    <... 'str'>


プログラミング言語Cでは変数がスタティックに型付けされるから振舞いはかなり異なっていて，整数(int)型として宣言された変数は同じスコープ内では整数しか保持できない．
