.. _sec-modsym:

Modular Symbols
===============

Modular symbols are a beautiful piece of mathematics that was
developed since the 1960s by Birch, Manin, Shokorov, Mazur, Merel,
Cremona, and others. Not only are modular symbols a powerful
computational tool as we will see, they have also been used to
prove rationality results for special values of :math:`L`-series,
to construct :math:`p`-adic :math:`L`-series, and they play a
key role in Merel's proof of the uniform boundedness theorem for
torsion points on elliptic curves over number fields.

We view modular symbols as a remarkably flexible computational tool
that provides a single uniform algorithm for computing
:math:`M_k(N,\varepsilon)` for any :math:`N, \varepsilon` and
:math:`k\geq 2`. There are ways to use computation of those
spaces to obtain explicit basis for spaces of weight :math:`1`
and half-integral weight, so in a sense modular symbols yield
everything. There are also generalizations of modular symbols to
higher rank groups, though Sage currently has no code for modular
symbols on higher rank groups.

Definition
----------

A modular symbol of weight
:math:`k`, and level :math:`N`, with character :math:`\varepsilon`
is a sum of terms :math:`X^i Y^{k-2-i} \{\alpha, \beta\}`, where
:math:`0\leq i \leq k-2` and
:math:`\alpha, \beta \in \mathbb{P}^1(\QQ) = \QQ \cup \{\infty\}`.
Modular symbols satisfy the relations

.. math::

   X^i Y^{k-2-i} \{\alpha, \beta\} + X^i Y^{k-2-i} \{\beta, \gamma\}
   + X^i Y^{k-2-i} \{\gamma, \alpha\} = 0

.. math::

    X^i Y^{k-2-i} \{\alpha, \beta\} = -X^i Y^{k-2-i} \{\beta, \alpha\},


and for every :math:`\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right)\in\Gamma_0(N)`, we
have

.. math::

   (dX - bY)^i (-cX + aY)^{k-2-i} \{\gamma(\alpha),\gamma(\beta)\}
   = \varepsilon(d) X^i Y^{k-2-i} \{\alpha, \beta\}.

The modular symbols space :math:`\mathcal{M}_k(N,\varepsilon)`
is the torsion free :math:`\QQ[\varepsilon]`-module generated by
all sums of modular symbols, modulo the relations listed above.
Here :math:`\QQ[\varepsilon]` is the ring generated by the values
of the character :math:`\varepsilon`, so it is of the form
:math:`\QQ[\zeta_m]` for some integer :math:`m`.

The amazing theorem that makes modular symbols useful is that there
is an explicit description of an action of a Hecke algebra
:math:`\mathbb{T}` on :math:`\mathcal{M}_k(N,\varepsilon)`, and there is an
isomorphism

.. math::

   \mathcal{M}_k(N,\varepsilon;\CC) \xrightarrow{\approx} M_k(N,\varepsilon) \oplus S_k(N,\varepsilon).

This means that if modular symbols are
computable (they are!), then they can be used to compute a lot
about the :math:`\mathbb{T}`-module :math:`M_k(N,\varepsilon)`.

Manin Symbols
-------------

Definition
~~~~~~~~~~

Though :math:`\mathcal{M}_k(N,\varepsilon)` as described above is not explicitly
generated by finitely many elements, it is finitely generated. Manin,
Shokoruv, and Merel give an explicit description of finitely many
generators (Manin symbols) for this space, along with all explicit
relations that these generators satisfy (see my book). In particular,
if we let

.. math::

   (i,c,d) = [X^i Y^{2-k-i}, (c,d)] =
   (dX - bY)^i (-cX + aY)^{k-2-i} \{\gamma(0),\gamma(\infty)\},

where
:math:`\gamma=\left(\begin{smallmatrix}a&b\\c&d\end{smallmatrix}\right)`, then the Manin symbols
:math:`(i,c,d)` with :math:`0\leq i \leq k-2` and
:math:`(c,d)\in\mathbb{P}^1(N)` generate :math:`\mathcal{M}_k(N,\varepsilon)`.

Computing in Sage
~~~~~~~~~~~~~~~~~

We compute a basis for the space
of weight :math:`4` modular symbols for :math:`\Gamma_0(11)`,
then coerce in :math:`(2,0,1)` and :math:`(1,1,3)`.

::

    sage: M = ModularSymbols(11,4)
    sage: M.basis()
    ([X^2,(0,1)], [X^2,(1,6)], [X^2,(1,7)], [X^2,(1,8)],
     [X^2,(1,9)], [X^2,(1,10)])
    sage: M( (2,0,1) )
    [X^2,(0,1)]
    sage: M( (1,1,3) )
    2/7*[X^2,(1,6)] + 1/14*[X^2,(1,7)] - 4/7*[X^2,(1,8)]
                    + 3/14*[X^2,(1,10)]

We compute a modular symbols representation for the Manin symbol
:math:`(2,1,6)`, and verify this by converting back.

.. link

::

    sage: a = M.1; a
    [X^2,(1,6)]
    sage: a.modular_symbol_rep()
    36*X^2*{-1/6, 0} + 12*X*Y*{-1/6, 0} + Y^2*{-1/6, 0}
    sage: 36*M([2,-1/6,0]) + 12*M([1,-1/6,0]) + M([0,-1/6,0])
    [X^2,(1,6)]
