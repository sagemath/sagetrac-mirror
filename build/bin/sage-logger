#!/usr/bin/env bash
#
# sage-logger [-p] COMMAND LOGFILE
#
# Evaluate shell command COMMAND while logging stdout and stderr to
# LOGFILE. If either the command or the logging failed, return a
# non-zero exit status.
#
# If the -p argument is given, each line printed to stdout is prefixed
# with the name of the log file.
#
# AUTHOR:
#
# - Jeroen Demeyer (2015-07-26): initial version based on old pipestatus
#   script (#18953)
#
#*****************************************************************************
#       Copyright (C) 2015 Jeroen Demeyer <jdemeyer@cage.ugent.be>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

use_prefix=false

if [[ "$1" = -p ]]; then
    use_prefix=true
    shift
fi

cmd="$1"
logfile="$2"
logname="$(basename $logfile .log)"
logdir=`dirname "$logfile"`

if [[ $use_prefix = true ]]; then
    prefix="[${logname}] "
else
    prefix=""
fi

# Use sed option to reduce buffering, to make the output appear more
# smoothly. For GNU sed, this is the --unbuffered option.
# For BSD sed (which is also on OS X), this is the -l option.
if [ -n "$prefix" ]; then
    if sed </dev/null 2>/dev/null --unbuffered ""; then
        SED="sed --unbuffered"
    elif sed </dev/null 2>/dev/null -l ""; then
        SED="sed -l"
    else
        SED="sed"
    fi

    # eval needed to get the quoting around the regexp right
    SED="eval $SED 's/^/$prefix/'"
else
    # Make SED a useless use of cat
    SED=cat
fi

# Store the current value of V, but do all logging of child processes
# with V=1 to ensure that no information is lost.
currentV=$V
export V=1

mkdir -p "$logdir"

if [[ "$currentV" = 0 && $use_prefix = true ]]; then
    # Silent build.
    # Similar to https://www.gnu.org/software/automake/manual/html_node/Automake-Silent-Rules.html#Automake-Silent-Rules
    echo "[$logname] installing. Log file: $logfile"
    ( exec>> $logfile 2>&1 ; eval "$cmd" )
    status=$?
    if [[ $status != 0 ]]; then
        echo "  [$logname] error installing, exit status $status. Log file: $logfile"
    else
        echo "  [$logname] successfully installed."
    fi
    exit $status
else
    # Redirect stdout and stderr to a subprocess running tee.
    # We trap SIGINT such that SIGINT interrupts the main process being
    # run, not the logging.
    ( exec 2>&1; eval "$cmd" ) | \
        ( trap '' SIGINT; tee -a "$logfile" | $SED )

    pipestatus=(${PIPESTATUS[*]})

    if [ ${pipestatus[1]} -ne 0 ]; then
        exit ${pipestatus[1]}
    else
        exit ${pipestatus[0]}
    fi
fi
