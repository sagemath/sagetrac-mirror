Trac #17382: upgrade the whole file ultratb.py to latest git master

--- a/IPython/core/ultratb.py	2014-10-02 01:55:50.000000000 +0200
+++ b/IPython/core/ultratb.py	2014-12-06 10:59:11.228558666 +0100
@@ -39,7 +39,7 @@
   Verbose).
 
 
-Installation instructions for ColorTB::
+Installation instructions for VerboseTB::
 
     import sys,ultratb
     sys.excepthook = ultratb.VerboseTB()
@@ -73,11 +73,11 @@
 """
 
 #*****************************************************************************
-#       Copyright (C) 2001 Nathaniel Gray <n8gray@caltech.edu>
-#       Copyright (C) 2001-2004 Fernando Perez <fperez@colorado.edu>
+# Copyright (C) 2001 Nathaniel Gray <n8gray@caltech.edu>
+# Copyright (C) 2001-2004 Fernando Perez <fperez@colorado.edu>
 #
-#  Distributed under the terms of the BSD License.  The full license is in
-#  the file COPYING, distributed as part of this software.
+# Distributed under the terms of the BSD License.  The full license is in
+# the file COPYING, distributed as part of this software.
 #*****************************************************************************
 
 from __future__ import unicode_literals
@@ -95,14 +95,14 @@
 import traceback
 import types
 
-try:                           # Python 2
+try:  # Python 2
     generate_tokens = tokenize.generate_tokens
-except AttributeError:         # Python 3
+except AttributeError:  # Python 3
     generate_tokens = tokenize.tokenize
 
 # For purposes of monkeypatching inspect to fix a bug in it.
-from inspect import getsourcefile, getfile, getmodule,\
-     ismodule, isclass, ismethod, isfunction, istraceback, isframe, iscode
+from inspect import getsourcefile, getfile, getmodule, \
+    ismodule, isclass, ismethod, isfunction, istraceback, isframe, iscode
 
 # IPython's own modules
 # Modified pdb which doesn't damage IPython's readline handling
@@ -125,11 +125,11 @@
 
 # Default color scheme.  This is used, for example, by the traceback
 # formatter.  When running in an actual IPython instance, the user's rc.colors
-# value is used, but havinga module global makes this functionality available
+# value is used, but having a module global makes this functionality available
 # to users of ultratb who are NOT running inside ipython.
 DEFAULT_SCHEME = 'NoColor'
 
-#---------------------------------------------------------------------------
+# ---------------------------------------------------------------------------
 # Code begins
 
 # Utility functions
@@ -141,6 +141,7 @@
     error('Internal Python error in the inspect module.\n'
           'Below is the traceback from this internal error.\n')
 
+
 # This function is a monkeypatch we apply to the Python inspect module. We have
 # now found when it's needed (see discussion on issue gh-1456), and we have a
 # test case (IPython.core.tests.test_ultratb.ChangedPyFileTest) that fails if
@@ -212,7 +213,7 @@
         pmatch = pat.match
         # fperez - fix: sometimes, co_firstlineno can give a number larger than
         # the length of lines, which causes an error.  Safeguard against that.
-        lnum = min(object.co_firstlineno,len(lines))-1
+        lnum = min(object.co_firstlineno, len(lines)) - 1
         while lnum > 0:
             if pmatch(lines[lnum]): break
             lnum -= 1
@@ -220,9 +221,11 @@
         return lines, lnum
     raise IOError('could not find code object')
 
+
 # Monkeypatch inspect to apply our bugfix.
 def with_patch_inspect(f):
     """decorator for monkeypatching inspect.findsource"""
+
     def wrapped(*args, **kwargs):
         save_findsource = inspect.findsource
         inspect.findsource = findsource
@@ -230,8 +233,10 @@
             return f(*args, **kwargs)
         finally:
             inspect.findsource = save_findsource
+
     return wrapped
 
+
 def fix_frame_records_filenames(records):
     """Try to fix the filenames in each record from inspect.getinnerframes().
 
@@ -240,24 +245,25 @@
     """
     fixed_records = []
     for frame, filename, line_no, func_name, lines, index in records:
-        # Look inside the frame's globals dictionary for __file__, which should
-        # be better.
-        better_fn = frame.f_globals.get('__file__', None)
-        if isinstance(better_fn, str):
-            # Check the type just in case someone did something weird with
-            # __file__. It might also be None if the error occurred during
-            # import.
-            filename = better_fn
+        # Look inside the frame's globals dictionary for __file__,
+        # which should be better. However, keep Cython filenames since
+        # we prefer the source filenames over the compiled .so file.
+        if not filename.endswith(('.pyx', '.pxd', '.pxi')):
+            better_fn = frame.f_globals.get('__file__', None)
+            if isinstance(better_fn, str):
+                # Check the type just in case someone did something weird with
+                # __file__. It might also be None if the error occurred during
+                # import.
+                filename = better_fn
         fixed_records.append((frame, filename, line_no, func_name, lines, index))
     return fixed_records
 
 
 @with_patch_inspect
-def _fixed_getinnerframes(etb, context=1,tb_offset=0):
-    LNUM_POS, LINES_POS, INDEX_POS =  2, 4, 5
-
-    records  = fix_frame_records_filenames(inspect.getinnerframes(etb, context))
+def _fixed_getinnerframes(etb, context=1, tb_offset=0):
+    LNUM_POS, LINES_POS, INDEX_POS = 2, 4, 5
 
+    records = fix_frame_records_filenames(inspect.getinnerframes(etb, context))
     # If the error is at the console, don't build any context, since it would
     # otherwise produce 5 blank lines printed out (there is no file at the
     # console)
@@ -272,9 +278,9 @@
     aux = traceback.extract_tb(etb)
     assert len(records) == len(aux)
     for i, (file, lnum, _, _) in zip(range(len(records)), aux):
-        maybeStart = lnum-1 - context//2
-        start =  max(maybeStart, 0)
-        end   = start + context
+        maybeStart = lnum - 1 - context // 2
+        start = max(maybeStart, 0)
+        end = start + context
         lines = ulinecache.getlines(file)[start:end]
         buf = list(records[i])
         buf[LNUM_POS] = lnum
@@ -290,7 +296,8 @@
 
 _parser = PyColorize.Parser()
 
-def _format_traceback_lines(lnum, index, lines, Colors, lvals=None,scheme=None):
+
+def _format_traceback_lines(lnum, index, lines, Colors, lvals=None, scheme=None):
     numbers_width = INDENT_SIZE - 1
     res = []
     i = lnum - index
@@ -315,7 +322,7 @@
             # This is the line with the error
             pad = numbers_width - len(str(i))
             if pad >= 3:
-                marker = '-'*(pad-3) + '-> '
+                marker = '-' * (pad - 3) + '-> '
             elif pad == 2:
                 marker = '> '
             elif pad == 1:
@@ -323,12 +330,12 @@
             else:
                 marker = ''
             num = marker + str(i)
-            line = '%s%s%s %s%s' %(Colors.linenoEm, num,
-                                   Colors.line, line, Colors.Normal)
+            line = '%s%s%s %s%s' % (Colors.linenoEm, num,
+                                    Colors.line, line, Colors.Normal)
         else:
-            num = '%*s' % (numbers_width,i)
-            line = '%s%s%s %s' %(Colors.lineno, num,
-                                 Colors.Normal, line)
+            num = '%*s' % (numbers_width, i)
+            line = '%s%s%s %s' % (Colors.lineno, num,
+                                  Colors.Normal, line)
 
         res.append(line)
         if lvals and i == lnum:
@@ -389,16 +396,16 @@
 
     ostream = property(_get_ostream, _set_ostream)
 
-    def set_colors(self,*args,**kw):
+    def set_colors(self, *args, **kw):
         """Shorthand access to the color table scheme selector method."""
 
         # Set own color table
-        self.color_scheme_table.set_active_scheme(*args,**kw)
+        self.color_scheme_table.set_active_scheme(*args, **kw)
         # for convenience, set Colors to the active scheme
         self.Colors = self.color_scheme_table.active_colors
         # Also set colors of debugger
-        if hasattr(self,'pdb') and self.pdb is not None:
-            self.pdb.set_colors(*args,**kw)
+        if hasattr(self, 'pdb') and self.pdb is not None:
+            self.pdb.set_colors(*args, **kw)
 
     def color_toggle(self):
         """Toggle between the currently active color scheme and NoColor."""
@@ -453,7 +460,7 @@
     Because they are meant to be called without a full traceback (only a
     list), instances of this class can't call the interactive pdb debugger."""
 
-    def __init__(self,color_scheme = 'NoColor', call_pdb=False, ostream=None):
+    def __init__(self, color_scheme='NoColor', call_pdb=False, ostream=None):
         TBTools.__init__(self, color_scheme=color_scheme, call_pdb=call_pdb,
                          ostream=ostream)
 
@@ -497,7 +504,7 @@
                 elist = elist[tb_offset:]
 
             out_list.append('Traceback %s(most recent call last)%s:' %
-                                (Colors.normalEm, Colors.Normal) + '\n')
+                            (Colors.normalEm, Colors.Normal) + '\n')
             out_list.extend(self._format_list(elist))
         # The exception info should be a single entry in the list.
         lines = ''.join(self._format_exception_only(etype, value))
@@ -510,7 +517,7 @@
         ## out_list.append(lines[-1])
 
         # This means it was indenting everything but the last line by a little
-        # bit.  I've disabled this for now, but if we see ugliness somewhre we
+        # bit.  I've disabled this for now, but if we see ugliness somewhere we
         # can restore it.
 
         return out_list
@@ -532,25 +539,24 @@
         list = []
         for filename, lineno, name, line in extracted_list[:-1]:
             item = '  File %s"%s"%s, line %s%d%s, in %s%s%s\n' % \
-                    (Colors.filename, filename, Colors.Normal,
-                     Colors.lineno, lineno, Colors.Normal,
-                     Colors.name, name, Colors.Normal)
+                   (Colors.filename, filename, Colors.Normal,
+                    Colors.lineno, lineno, Colors.Normal,
+                    Colors.name, name, Colors.Normal)
             if line:
                 item += '    %s\n' % line.strip()
             list.append(item)
         # Emphasize the last entry
         filename, lineno, name, line = extracted_list[-1]
         item = '%s  File %s"%s"%s, line %s%d%s, in %s%s%s%s\n' % \
-                (Colors.normalEm,
-                 Colors.filenameEm, filename, Colors.normalEm,
-                 Colors.linenoEm, lineno, Colors.normalEm,
-                 Colors.nameEm, name, Colors.normalEm,
-                 Colors.Normal)
+               (Colors.normalEm,
+                Colors.filenameEm, filename, Colors.normalEm,
+                Colors.linenoEm, lineno, Colors.normalEm,
+                Colors.nameEm, name, Colors.normalEm,
+                Colors.Normal)
         if line:
             item += '%s    %s%s\n' % (Colors.line, line.strip(),
-                                            Colors.Normal)
+                                      Colors.Normal)
         list.append(item)
-        #from pprint import pformat; print 'LISTTB', pformat(list) # dbg
         return list
 
     def _format_exception_only(self, etype, value):
@@ -572,11 +578,10 @@
         stype = Colors.excName + etype.__name__ + Colors.Normal
         if value is None:
             # Not sure if this can still happen in Python 2.6 and above
-            list.append( py3compat.cast_unicode(stype) + '\n')
+            list.append(py3compat.cast_unicode(stype) + '\n')
         else:
             if issubclass(etype, SyntaxError):
                 have_filedata = True
-                #print 'filename is',filename  # dbg
                 if not value.filename: value.filename = "<string>"
                 if value.lineno:
                     lineno = value.lineno
@@ -585,9 +590,9 @@
                     lineno = 'unknown'
                     textline = ''
                 list.append('%s  File %s"%s"%s, line %s%s%s\n' % \
-                        (Colors.normalEm,
-                         Colors.filenameEm, py3compat.cast_unicode(value.filename), Colors.normalEm,
-                         Colors.linenoEm, lineno, Colors.Normal  ))
+                            (Colors.normalEm,
+                             Colors.filenameEm, py3compat.cast_unicode(value.filename), Colors.normalEm,
+                             Colors.linenoEm, lineno, Colors.Normal  ))
                 if textline == '':
                     textline = py3compat.cast_unicode(value.text, "utf-8")
 
@@ -600,13 +605,13 @@
                                                   Colors.Normal))
                     if value.offset is not None:
                         s = '    '
-                        for c in textline[i:value.offset-1]:
+                        for c in textline[i:value.offset - 1]:
                             if c.isspace():
                                 s += c
                             else:
                                 s += ' '
                         list.append('%s%s^%s\n' % (Colors.caret, s,
-                                                   Colors.Normal) )
+                                                   Colors.Normal))
 
             try:
                 s = value.msg
@@ -636,7 +641,6 @@
         """
         return ListTB.structured_traceback(self, etype, value, [])
 
-
     def show_exception_only(self, etype, evalue):
         """Only print the exception type and message, without a traceback.
 
@@ -659,6 +663,7 @@
         except:
             return '<unprintable %s object>' % type(value).__name__
 
+
 #----------------------------------------------------------------------------
 class VerboseTB(TBTools):
     """A port of Ka-Ping Yee's cgitb.py module that outputs color text instead
@@ -668,7 +673,7 @@
     traceback, to be used with alternate interpreters (because their own code
     would appear in the traceback)."""
 
-    def __init__(self,color_scheme = 'Linux', call_pdb=False, ostream=None,
+    def __init__(self, color_scheme='Linux', call_pdb=False, ostream=None,
                  tb_offset=0, long_header=False, include_vars=True,
                  check_cache=None):
         """Specify traceback offset, headers and color scheme.
@@ -691,132 +696,51 @@
             check_cache = linecache.checkcache
         self.check_cache = check_cache
 
-    def structured_traceback(self, etype, evalue, etb, tb_offset=None,
-                             context=5):
-        """Return a nice text document describing the traceback."""
-
-        tb_offset = self.tb_offset if tb_offset is None else tb_offset
-
-        # some locals
-        try:
-            etype = etype.__name__
-        except AttributeError:
-            pass
-        Colors        = self.Colors   # just a shorthand + quicker name lookup
-        ColorsNormal  = Colors.Normal  # used a lot
-        col_scheme    = self.color_scheme_table.active_scheme_name
-        indent        = ' '*INDENT_SIZE
-        em_normal     = '%s\n%s%s' % (Colors.valEm, indent,ColorsNormal)
-        undefined     = '%sundefined%s' % (Colors.em, ColorsNormal)
-        exc = '%s%s%s' % (Colors.excName,etype,ColorsNormal)
-
-        # some internal-use functions
-        def text_repr(value):
-            """Hopefully pretty robust repr equivalent."""
-            # this is pretty horrible but should always return *something*
-            try:
-                return pydoc.text.repr(value)
-            except KeyboardInterrupt:
-                raise
-            except:
-                try:
-                    return repr(value)
-                except KeyboardInterrupt:
-                    raise
-                except:
-                    try:
-                        # all still in an except block so we catch
-                        # getattr raising
-                        name = getattr(value, '__name__', None)
-                        if name:
-                            # ick, recursion
-                            return text_repr(name)
-                        klass = getattr(value, '__class__', None)
-                        if klass:
-                            return '%s instance' % text_repr(klass)
-                    except KeyboardInterrupt:
-                        raise
-                    except:
-                        return 'UNRECOVERABLE REPR FAILURE'
-        def eqrepr(value, repr=text_repr): return '=%s' % repr(value)
-        def nullrepr(value, repr=text_repr): return ''
-
-        # meat of the code begins
-        try:
-            etype = etype.__name__
-        except AttributeError:
-            pass
-
-        if self.long_header:
-            # Header with the exception type, python version, and date
-            pyver = 'Python ' + sys.version.split()[0] + ': ' + sys.executable
-            date = time.ctime(time.time())
-
-            head = '%s%s%s\n%s%s%s\n%s' % (Colors.topline, '-'*75, ColorsNormal,
-                                           exc, ' '*(75-len(str(etype))-len(pyver)),
-                                           pyver, date.rjust(75) )
-            head += "\nA problem occured executing Python code.  Here is the sequence of function"\
-                    "\ncalls leading up to the error, with the most recent (innermost) call last."
-        else:
-            # Simplified header
-            head = '%s%s%s\n%s%s' % (Colors.topline, '-'*75, ColorsNormal,exc,
-                                     'Traceback (most recent call last)'.\
-                                                  rjust(75 - len(str(etype)) ) )
+    def format_records(self, records):
+        Colors = self.Colors  # just a shorthand + quicker name lookup
+        ColorsNormal = Colors.Normal  # used a lot
+        col_scheme = self.color_scheme_table.active_scheme_name
+        indent = ' ' * INDENT_SIZE
+        em_normal = '%s\n%s%s' % (Colors.valEm, indent, ColorsNormal)
+        undefined = '%sundefined%s' % (Colors.em, ColorsNormal)
         frames = []
-        # Flush cache before calling inspect.  This helps alleviate some of the
-        # problems with python 2.3's inspect.py.
-        ##self.check_cache()
-        # Drop topmost frames if requested
-        try:
-            # Try the default getinnerframes and Alex's: Alex's fixes some
-            # problems, but it generates empty tracebacks for console errors
-            # (5 blanks lines) where none should be returned.
-            #records = inspect.getinnerframes(etb, context)[tb_offset:]
-            #print 'python records:', records # dbg
-            records = _fixed_getinnerframes(etb, context, tb_offset)
-            #print 'alex   records:', records # dbg
-        except:
-
-            # FIXME: I've been getting many crash reports from python 2.3
-            # users, traceable to inspect.py.  If I can find a small test-case
-            # to reproduce this, I should either write a better workaround or
-            # file a bug report against inspect (if that's the real problem).
-            # So far, I haven't been able to find an isolated example to
-            # reproduce the problem.
-            inspect_error()
-            traceback.print_exc(file=self.ostream)
-            info('\nUnfortunately, your original traceback can not be constructed.\n')
-            return ''
-
         # build some color string templates outside these nested loops
-        tpl_link       = '%s%%s%s' % (Colors.filenameEm,ColorsNormal)
-        tpl_call       = 'in %s%%s%s%%s%s' % (Colors.vName, Colors.valEm,
-                                              ColorsNormal)
-        tpl_call_fail  = 'in %s%%s%s(***failed resolving arguments***)%s' % \
-                         (Colors.vName, Colors.valEm, ColorsNormal)
-        tpl_local_var  = '%s%%s%s' % (Colors.vName, ColorsNormal)
+        tpl_link = '%s%%s%s' % (Colors.filenameEm, ColorsNormal)
+        tpl_call = 'in %s%%s%s%%s%s' % (Colors.vName, Colors.valEm,
+                                        ColorsNormal)
+        tpl_call_fail = 'in %s%%s%s(***failed resolving arguments***)%s' % \
+                        (Colors.vName, Colors.valEm, ColorsNormal)
+        tpl_local_var = '%s%%s%s' % (Colors.vName, ColorsNormal)
         tpl_global_var = '%sglobal%s %s%%s%s' % (Colors.em, ColorsNormal,
                                                  Colors.vName, ColorsNormal)
-        tpl_name_val   = '%%s %s= %%s%s' % (Colors.valEm, ColorsNormal)
-        tpl_line       = '%s%%s%s %%s' % (Colors.lineno, ColorsNormal)
-        tpl_line_em    = '%s%%s%s %%s%s' % (Colors.linenoEm,Colors.line,
-                                            ColorsNormal)
+        tpl_name_val = '%%s %s= %%s%s' % (Colors.valEm, ColorsNormal)
+
+        tpl_line = '%s%%s%s %%s' % (Colors.lineno, ColorsNormal)
+        tpl_line_em = '%s%%s%s %%s%s' % (Colors.linenoEm, Colors.line,
+                                         ColorsNormal)
 
-        # now, loop over all records printing context and info
         abspath = os.path.abspath
         for frame, file, lnum, func, lines, index in records:
             #print '*** record:',file,lnum,func,lines,index  # dbg
             if not file:
                 file = '?'
-            elif not(file.startswith(str("<")) and file.endswith(str(">"))):
-                # Guess that filenames like <string> aren't real filenames, so
-                # don't call abspath on them.                    
-                try:
-                    file = abspath(file)
-                except OSError:
-                    # Not sure if this can still happen: abspath now works with
-                    # file names like <string>
-                    pass
+            elif file.startswith(str("<")) and file.endswith(str(">")):
+                # Not a real filename, no problem...
+                pass
+            elif not os.path.isabs(file):
+                # Try to make the filename absolute by trying all
+                # sys.path entries (which is also what linecache does)
+                for dirname in sys.path:
+                    try:
+                        fullname = os.path.join(dirname, file)
+                        if os.path.isfile(fullname):
+                            file = os.path.abspath(fullname)
+                            break
+                    except Exception:
+                        # Just in case that sys.path contains very
+                        # strange entries...
+                        pass
+
             file = py3compat.cast_unicode(file, util_path.fs_encoding)
             link = tpl_link % file
             args, varargs, varkw, locals = inspect.getargvalues(frame)
@@ -827,9 +751,9 @@
                 # Decide whether to include variable details or not
                 var_repr = self.include_vars and eqrepr or nullrepr
                 try:
-                    call = tpl_call % (func,inspect.formatargvalues(args,
-                                                varargs, varkw,
-                                                locals,formatvalue=var_repr))
+                    call = tpl_call % (func, inspect.formatargvalues(args,
+                                                                     varargs, varkw,
+                                                                     locals, formatvalue=var_repr))
                 except KeyError:
                     # This happens in situations like errors inside generator
                     # expressions, where local variables are listed in the
@@ -848,12 +772,12 @@
                     # will illustrate the error, if this exception catch is
                     # disabled.
                     call = tpl_call_fail % func
-            
+
             # Don't attempt to tokenize binary files.
             if file.endswith(('.so', '.pyd', '.dll')):
-                frames.append('%s %s\n' % (link,call))
+                frames.append('%s %s\n' % (link, call))
                 continue
-            elif file.endswith(('.pyc','.pyo')):
+            elif file.endswith(('.pyc', '.pyo')):
                 # Look up the corresponding source file.
                 file = openpy.source_from_cache(file)
 
@@ -867,7 +791,7 @@
             try:
                 names = []
                 name_cont = False
-                
+
                 for token_type, token, start, end, line in generate_tokens(linereader):
                     # build composite names
                     if token_type == tokenize.NAME and token not in keyword.kwlist:
@@ -890,9 +814,11 @@
                         name_cont = True
                     elif token_type == tokenize.NEWLINE:
                         break
-                        
-            except (IndexError, UnicodeDecodeError):
+
+            except (IndexError, UnicodeDecodeError, SyntaxError):
                 # signals exit of tokenizer
+                # SyntaxError can occur if the file is not actually Python
+                #  - see gh-6300
                 pass
             except tokenize.TokenError as msg:
                 _m = ("An unexpected error occurred while tokenizing input\n"
@@ -909,11 +835,11 @@
             lvals = []
             if self.include_vars:
                 for name_full in unique_names:
-                    name_base = name_full.split('.',1)[0]
+                    name_base = name_full.split('.', 1)[0]
                     if name_base in frame.f_code.co_varnames:
                         if name_base in locals:
                             try:
-                                value = repr(eval(name_full,locals))
+                                value = repr(eval(name_full, locals))
                             except:
                                 value = undefined
                         else:
@@ -922,69 +848,191 @@
                     else:
                         if name_base in frame.f_globals:
                             try:
-                                value = repr(eval(name_full,frame.f_globals))
+                                value = repr(eval(name_full, frame.f_globals))
                             except:
                                 value = undefined
                         else:
                             value = undefined
                         name = tpl_global_var % name_full
-                    lvals.append(tpl_name_val % (name,value))
+                    lvals.append(tpl_name_val % (name, value))
             if lvals:
-                lvals = '%s%s' % (indent,em_normal.join(lvals))
+                lvals = '%s%s' % (indent, em_normal.join(lvals))
             else:
                 lvals = ''
 
-            level = '%s %s\n' % (link,call)
+            level = '%s %s\n' % (link, call)
 
             if index is None:
                 frames.append(level)
             else:
-                frames.append('%s%s' % (level,''.join(
-                    _format_traceback_lines(lnum,index,lines,Colors,lvals,
+                frames.append('%s%s' % (level, ''.join(
+                    _format_traceback_lines(lnum, index, lines, Colors, lvals,
                                             col_scheme))))
 
+        return frames
+
+    def prepare_chained_exception_message(self, cause):
+        direct_cause = "\nThe above exception was the direct cause of the following exception:\n"
+        exception_during_handling = "\nDuring handling of the above exception, another exception occurred:\n"
+
+        if cause:
+            message = [[direct_cause]]
+        else:
+            message = [[exception_during_handling]]
+        return message
+
+    def prepare_header(self, etype, long_version=False):
+        colors = self.Colors  # just a shorthand + quicker name lookup
+        colorsnormal = colors.Normal  # used a lot
+        exc = '%s%s%s' % (colors.excName, etype, colorsnormal)
+        if long_version:
+            # Header with the exception type, python version, and date
+            pyver = 'Python ' + sys.version.split()[0] + ': ' + sys.executable
+            date = time.ctime(time.time())
+
+            head = '%s%s%s\n%s%s%s\n%s' % (colors.topline, '-' * 75, colorsnormal,
+                                           exc, ' ' * (75 - len(str(etype)) - len(pyver)),
+                                           pyver, date.rjust(75) )
+            head += "\nA problem occurred executing Python code.  Here is the sequence of function" \
+                    "\ncalls leading up to the error, with the most recent (innermost) call last."
+        else:
+            # Simplified header
+            head = '%s%s' % (exc, 'Traceback (most recent call last)'. \
+                             rjust(75 - len(str(etype))) )
+
+        return head
+
+    def format_exception(self, etype, evalue):
+        colors = self.Colors  # just a shorthand + quicker name lookup
+        colorsnormal = colors.Normal  # used a lot
+        indent = ' ' * INDENT_SIZE
         # Get (safely) a string form of the exception info
         try:
-            etype_str,evalue_str = map(str,(etype,evalue))
+            etype_str, evalue_str = map(str, (etype, evalue))
         except:
             # User exception is improperly defined.
-            etype,evalue = str,sys.exc_info()[:2]
-            etype_str,evalue_str = map(str,(etype,evalue))
+            etype, evalue = str, sys.exc_info()[:2]
+            etype_str, evalue_str = map(str, (etype, evalue))
         # ... and format it
-        exception = ['%s%s%s: %s' % (Colors.excName, etype_str,
-                                     ColorsNormal, py3compat.cast_unicode(evalue_str))]
+        exception = ['%s%s%s: %s' % (colors.excName, etype_str,
+                                     colorsnormal, py3compat.cast_unicode(evalue_str))]
+
         if (not py3compat.PY3) and type(evalue) is types.InstanceType:
             try:
                 names = [w for w in dir(evalue) if isinstance(w, py3compat.string_types)]
             except:
-                # Every now and then, an object with funny inernals blows up
+                # Every now and then, an object with funny internals blows up
                 # when dir() is called on it.  We do the best we can to report
                 # the problem and continue
                 _m = '%sException reporting error (object with broken dir())%s:'
-                exception.append(_m % (Colors.excName,ColorsNormal))
-                etype_str,evalue_str = map(str,sys.exc_info()[:2])
-                exception.append('%s%s%s: %s' % (Colors.excName,etype_str,
-                                     ColorsNormal, py3compat.cast_unicode(evalue_str)))
+                exception.append(_m % (colors.excName, colorsnormal))
+                etype_str, evalue_str = map(str, sys.exc_info()[:2])
+                exception.append('%s%s%s: %s' % (colors.excName, etype_str,
+                                                 colorsnormal, py3compat.cast_unicode(evalue_str)))
                 names = []
             for name in names:
                 value = text_repr(getattr(evalue, name))
                 exception.append('\n%s%s = %s' % (indent, name, value))
 
-        # vds: >>
+        return exception
+
+    def format_exception_as_a_whole(self, etype, evalue, etb, number_of_lines_of_context, tb_offset):
+        # some locals
+        try:
+            etype = etype.__name__
+        except AttributeError:
+            pass
+
+        tb_offset = self.tb_offset if tb_offset is None else tb_offset
+        head = self.prepare_header(etype, self.long_header)
+        records = self.get_records(etb, number_of_lines_of_context, tb_offset)
+
+        frames = self.format_records(records)
+        if records is None:
+            return ""
+
+        formatted_exception = self.format_exception(etype, evalue)
         if records:
-             filepath, lnum = records[-1][1:3]
-             #print "file:", str(file), "linenb", str(lnum) # dbg
-             filepath = os.path.abspath(filepath)
-             ipinst = get_ipython()
-             if ipinst is not None:
-                 ipinst.hooks.synchronize_with_editor(filepath, lnum, 0)
-        # vds: <<
-
-        # return all our info assembled as a single string
-        # return '%s\n\n%s\n%s' % (head,'\n'.join(frames),''.join(exception[0]) )
-        return [head] + frames + [''.join(exception[0])]
+            filepath, lnum = records[-1][1:3]
+            filepath = os.path.abspath(filepath)
+            ipinst = get_ipython()
+            if ipinst is not None:
+                ipinst.hooks.synchronize_with_editor(filepath, lnum, 0)
+
+        return [[head] + frames + [''.join(formatted_exception[0])]]
+
+    def get_records(self, etb, number_of_lines_of_context, tb_offset):
+        try:
+            # Try the default getinnerframes and Alex's: Alex's fixes some
+            # problems, but it generates empty tracebacks for console errors
+            # (5 blanks lines) where none should be returned.
+            return _fixed_getinnerframes(etb, number_of_lines_of_context, tb_offset)
+        except:
+            # FIXME: I've been getting many crash reports from python 2.3
+            # users, traceable to inspect.py.  If I can find a small test-case
+            # to reproduce this, I should either write a better workaround or
+            # file a bug report against inspect (if that's the real problem).
+            # So far, I haven't been able to find an isolated example to
+            # reproduce the problem.
+            inspect_error()
+            traceback.print_exc(file=self.ostream)
+            info('\nUnfortunately, your original traceback can not be constructed.\n')
+            return None
+
+    def get_parts_of_chained_exception(self, evalue):
+        def get_chained_exception(exception_value):
+            cause = getattr(exception_value, '__cause__', None)
+            if cause:
+                return cause
+            return getattr(exception_value, '__context__', None)
+
+        chained_evalue = get_chained_exception(evalue)
+
+        if chained_evalue:
+            return chained_evalue.__class__, chained_evalue, chained_evalue.__traceback__
+
+    def structured_traceback(self, etype, evalue, etb, tb_offset=None,
+                             number_of_lines_of_context=5):
+        """Return a nice text document describing the traceback."""
+
+        formatted_exception = self.format_exception_as_a_whole(etype, evalue, etb, number_of_lines_of_context,
+                                                               tb_offset)
 
-    def debugger(self,force=False):
+        colors = self.Colors  # just a shorthand + quicker name lookup
+        colorsnormal = colors.Normal  # used a lot
+        head = '%s%s%s' % (colors.topline, '-' * 75, colorsnormal)
+        structured_traceback_parts = [head]
+        if py3compat.PY3:
+            chained_exceptions_tb_offset = 0
+            lines_of_context = 3
+            formatted_exceptions = formatted_exception
+            exception = self.get_parts_of_chained_exception(evalue)
+            if exception:
+                formatted_exceptions += self.prepare_chained_exception_message(evalue.__cause__)
+                etype, evalue, etb = exception
+            else:
+                evalue = None
+            while evalue:
+                formatted_exceptions += self.format_exception_as_a_whole(etype, evalue, etb, lines_of_context,
+                                                                         chained_exceptions_tb_offset)
+                exception = self.get_parts_of_chained_exception(evalue)
+
+                if exception:
+                    formatted_exceptions += self.prepare_chained_exception_message(evalue.__cause__)
+                    etype, evalue, etb = exception
+                else:
+                    evalue = None
+
+            # we want to see exceptions in a reversed order:
+            # the first exception should be on top
+            for formatted_exception in reversed(formatted_exceptions):
+                structured_traceback_parts += formatted_exception
+        else:
+            structured_traceback_parts += formatted_exception[0]
+
+        return structured_traceback_parts
+
+    def debugger(self, force=False):
         """Call up the pdb debugger if desired, always clean up the tb
         reference.
 
@@ -1014,7 +1062,7 @@
             with display_trap:
                 self.pdb.reset()
                 # Find the right frame so we don't pop up inside ipython itself
-                if hasattr(self,'tb') and self.tb is not None:
+                if hasattr(self, 'tb') and self.tb is not None:
                     etb = self.tb
                 else:
                     etb = self.tb = sys.last_traceback
@@ -1025,7 +1073,7 @@
                 self.pdb.botframe = etb.tb_frame
                 self.pdb.interaction(self.tb.tb_frame, self.tb)
 
-        if hasattr(self,'tb'):
+        if hasattr(self, 'tb'):
             del self.tb
 
     def handler(self, info=None):
@@ -1050,6 +1098,7 @@
         except KeyboardInterrupt:
             print("\nKeyboardInterrupt")
 
+
 #----------------------------------------------------------------------------
 class FormattedTB(VerboseTB, ListTB):
     """Subclass ListTB but allow calling with a traceback.
@@ -1069,7 +1118,7 @@
                  check_cache=None):
 
         # NEVER change the order of this list. Put new modes at the end:
-        self.valid_modes = ['Plain','Context','Verbose']
+        self.valid_modes = ['Plain', 'Context', 'Verbose']
         self.verbose_modes = self.valid_modes[1:3]
 
         VerboseTB.__init__(self, color_scheme=color_scheme, call_pdb=call_pdb,
@@ -1083,19 +1132,19 @@
         # set_mode also sets the tb_join_char attribute
         self.set_mode(mode)
 
-    def _extract_tb(self,tb):
+    def _extract_tb(self, tb):
         if tb:
             return traceback.extract_tb(tb)
         else:
             return None
 
-    def structured_traceback(self, etype, value, tb, tb_offset=None, context=5):
+    def structured_traceback(self, etype, value, tb, tb_offset=None, number_of_lines_of_context=5):
         tb_offset = self.tb_offset if tb_offset is None else tb_offset
         mode = self.mode
         if mode in self.verbose_modes:
             # Verbose modes need a full traceback
             return VerboseTB.structured_traceback(
-                self, etype, value, tb, tb_offset, context
+                self, etype, value, tb, tb_offset, number_of_lines_of_context
             )
         else:
             # We must check the source cache because otherwise we can print
@@ -1104,7 +1153,7 @@
             # Now we can extract and format the exception
             elist = self._extract_tb(tb)
             return ListTB.structured_traceback(
-                self, etype, value, elist, tb_offset, context
+                self, etype, value, elist, tb_offset, number_of_lines_of_context
             )
 
     def stb2text(self, stb):
@@ -1112,18 +1161,18 @@
         return self.tb_join_char.join(stb)
 
 
-    def set_mode(self,mode=None):
+    def set_mode(self, mode=None):
         """Switch to the desired mode.
 
         If mode is not specified, cycles through the available modes."""
 
         if not mode:
-            new_idx = ( self.valid_modes.index(self.mode) + 1 ) % \
+            new_idx = (self.valid_modes.index(self.mode) + 1 ) % \
                       len(self.valid_modes)
             self.mode = self.valid_modes[new_idx]
         elif mode not in self.valid_modes:
-            raise ValueError('Unrecognized mode in FormattedTB: <'+mode+'>\n'
-                             'Valid modes: '+str(self.valid_modes))
+            raise ValueError('Unrecognized mode in FormattedTB: <' + mode + '>\n'
+                                                                            'Valid modes: ' + str(self.valid_modes))
         else:
             self.mode = mode
         # include variable details only in 'Verbose' mode
@@ -1131,7 +1180,7 @@
         # Set the join character for generating text tracebacks
         self.tb_join_char = self._join_chars[self.mode]
 
-    # some convenient shorcuts
+    # some convenient shortcuts
     def plain(self):
         self.set_mode(self.valid_modes[0])
 
@@ -1141,6 +1190,7 @@
     def verbose(self):
         self.set_mode(self.valid_modes[2])
 
+
 #----------------------------------------------------------------------------
 class AutoFormattedTB(FormattedTB):
     """A traceback printer which can be called on the fly.
@@ -1156,8 +1206,8 @@
           AutoTB()  # or AutoTB(out=logfile) where logfile is an open file object
     """
 
-    def __call__(self,etype=None,evalue=None,etb=None,
-                 out=None,tb_offset=None):
+    def __call__(self, etype=None, evalue=None, etb=None,
+                 out=None, tb_offset=None):
         """Print out a formatted exception traceback.
 
         Optional arguments:
@@ -1167,7 +1217,6 @@
           per-call basis (this overrides temporarily the instance's tb_offset
           given at initialization time.  """
 
-
         if out is None:
             out = self.ostream
         out.flush()
@@ -1182,33 +1231,36 @@
             print("\nKeyboardInterrupt")
 
     def structured_traceback(self, etype=None, value=None, tb=None,
-                             tb_offset=None, context=5):
+                             tb_offset=None, number_of_lines_of_context=5):
         if etype is None:
-            etype,value,tb = sys.exc_info()
+            etype, value, tb = sys.exc_info()
         self.tb = tb
         return FormattedTB.structured_traceback(
-            self, etype, value, tb, tb_offset, context)
+            self, etype, value, tb, tb_offset, number_of_lines_of_context)
+
 
 #---------------------------------------------------------------------------
 
 # A simple class to preserve Nathan's original functionality.
 class ColorTB(FormattedTB):
     """Shorthand to initialize a FormattedTB in Linux colors mode."""
-    def __init__(self,color_scheme='Linux',call_pdb=0):
-        FormattedTB.__init__(self,color_scheme=color_scheme,
+
+    def __init__(self, color_scheme='Linux', call_pdb=0):
+        FormattedTB.__init__(self, color_scheme=color_scheme,
                              call_pdb=call_pdb)
 
 
 class SyntaxTB(ListTB):
     """Extension which holds some state: the last exception value"""
 
-    def __init__(self,color_scheme = 'NoColor'):
-        ListTB.__init__(self,color_scheme)
+    def __init__(self, color_scheme='NoColor'):
+        ListTB.__init__(self, color_scheme)
         self.last_syntax_error = None
 
     def __call__(self, etype, value, elist):
         self.last_syntax_error = value
-        ListTB.__call__(self,etype,value,elist)
+
+        ListTB.__call__(self, etype, value, elist)
 
     def structured_traceback(self, etype, value, elist, tb_offset=None,
                              context=5):
@@ -1223,7 +1275,7 @@
             if newtext:
                 value.text = newtext
         return super(SyntaxTB, self).structured_traceback(etype, value, elist,
-                             tb_offset=tb_offset, context=context)
+                                                          tb_offset=tb_offset, context=context)
 
     def clear_err_state(self):
         """Return the current error state and clear it"""
@@ -1236,7 +1288,46 @@
         return ''.join(stb)
 
 
+# some internal-use functions
+def text_repr(value):
+    """Hopefully pretty robust repr equivalent."""
+    # this is pretty horrible but should always return *something*
+    try:
+        return pydoc.text.repr(value)
+    except KeyboardInterrupt:
+        raise
+    except:
+        try:
+            return repr(value)
+        except KeyboardInterrupt:
+            raise
+        except:
+            try:
+                # all still in an except block so we catch
+                # getattr raising
+                name = getattr(value, '__name__', None)
+                if name:
+                    # ick, recursion
+                    return text_repr(name)
+                klass = getattr(value, '__class__', None)
+                if klass:
+                    return '%s instance' % text_repr(klass)
+            except KeyboardInterrupt:
+                raise
+            except:
+                return 'UNRECOVERABLE REPR FAILURE'
+
+
+def eqrepr(value, repr=text_repr):
+    return '=%s' % repr(value)
+
+
+def nullrepr(value, repr=text_repr):
+    return ''
+
+
 #----------------------------------------------------------------------------
+
 # module testing (minimal)
 if __name__ == "__main__":
     def spam(c, d_e):
