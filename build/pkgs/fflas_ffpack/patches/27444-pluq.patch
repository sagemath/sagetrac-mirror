diff --git a/fflas-ffpack/checkers/checker_charpoly.inl b/fflas-ffpack/checkers/checker_charpoly.inl
index ede5349..6f43599 100644
--- a/fflas-ffpack/checkers/checker_charpoly.inl
+++ b/fflas-ffpack/checkers/checker_charpoly.inl
@@ -116,10 +116,13 @@ namespace FFPACK {
                 inittime.stop(); _time = inittime;
                 Givaro::Timer pluqtime; pluqtime.start();
 #endif
+FFLAS::ParSeqHelper::Sequential PSHelper;
 #ifndef ENABLE_CHECKER_PLUQ
                 size_t R = 
 #endif
-                    FFPACK::PLUQ(F, FFLAS::FflasNonUnit, n, n, Ac, n, P, Q);
+                    //FFPACK::PLUQ(F, FFLAS::FflasNonUnit, n, n, Ac, n, P, Q);
+
+                    FFPACK::PLUQ(F, FFLAS::FflasNonUnit, n, n, Ac, n, P, Q, PSHelper);
 #ifdef TIME_CHECKER_CHARPOLY
                 pluqtime.stop(); 
                 std::cerr << "CHARPol server PLUQ : " << pluqtime << std::endl;
diff --git a/fflas-ffpack/ffpack/ffpack.h b/fflas-ffpack/ffpack/ffpack.h
index ee37a60..a9b87b2 100755
--- a/fflas-ffpack/ffpack/ffpack.h
+++ b/fflas-ffpack/ffpack/ffpack.h
@@ -277,7 +277,7 @@ namespace FFPACK { /* Permutations */
 						const size_t width, const size_t M2,
 						const size_t R1, const size_t R2,
 						const size_t R3, const size_t R4) ;
-
+#if 0
 	template<class Field>
 	size_t
 	pPLUQ(const Field& Fi, const FFLAS::FFLAS_DIAG Diag,
@@ -285,6 +285,14 @@ namespace FFPACK { /* Permutations */
 	      typename Field::Element_ptr A, const size_t lda,
 	      size_t* P, size_t* Q, int nt);
 	/* \endcond */
+#endif
+	template<class Field, class Cut, class Param>
+	size_t
+	PLUQ (const Field& F, const FFLAS::FFLAS_DIAG Diag,
+	      const size_t M, const size_t N,
+	      typename Field::Element_ptr A, const size_t lda,
+	      size_t*P, size_t *Q,
+	      FFLAS::ParSeqHelper::Parallel<Cut,Param>& PSHelper);
 
 //#endif
 
@@ -541,12 +549,22 @@ namespace FFPACK {
 	 * - Dumas J-G.,  Pernet C., and Sultan Z. <i>\c Simultaneous computation of the row and column rank profiles </i>, ISSAC'13, 2013
 	 * .
 	 */
+#if 0
 	template<class Field>
 	size_t
 	PLUQ (const Field& F, const FFLAS::FFLAS_DIAG Diag,
 	      const size_t M, const size_t N,
 	      typename Field::Element_ptr A, const size_t lda,
 	      size_t*P, size_t *Q, size_t BCThreshold = __FFLASFFPACK_PLUQ_THRESHOLD);
+#endif
+
+	template<class Field>
+	size_t
+	PLUQ (const Field& F, const FFLAS::FFLAS_DIAG Diag,
+	      const size_t M, const size_t N,
+	      typename Field::Element_ptr A, const size_t lda,
+	      size_t*P, size_t *Q,
+	      FFLAS::ParSeqHelper::Sequential& PSHelper);
 
 } // FFPACK PLUQ
 // #include "ffpack_pluq.inl"
diff --git a/fflas-ffpack/ffpack/ffpack.inl b/fflas-ffpack/ffpack/ffpack.inl
index 141c273..a28820a 100755
--- a/fflas-ffpack/ffpack/ffpack.inl
+++ b/fflas-ffpack/ffpack/ffpack.inl
@@ -85,7 +85,9 @@ Det( typename Field::Element& det,
 	
 
 	size_t R(0);
-	R = PLUQ(F,Diag,M,N,A,lda,P,Q);
+	//R = PLUQ(F,Diag,M,N,A,lda,P,Q);
+	FFLAS::ParSeqHelper::Sequential PSHelper;
+	R = PLUQ(F,Diag,M,N,A,lda,P,Q,PSHelper);
 	if (R<M) return F.assign(det,F.zero);
 
 	F.assign(det,F.one);
diff --git a/fflas-ffpack/ffpack/ffpack_echelonforms.inl b/fflas-ffpack/ffpack/ffpack_echelonforms.inl
index 4d2ce02..85284cd 100644
--- a/fflas-ffpack/ffpack/ffpack_echelonforms.inl
+++ b/fflas-ffpack/ffpack/ffpack_echelonforms.inl
@@ -43,9 +43,10 @@ inline size_t FFPACK::ColumnEchelonForm (const Field& F, const size_t M, const s
 	size_t r;
 	if (LuTag == FFPACK::FfpackSlabRecursive)
 		r = LUdivine (F, FFLAS::FflasNonUnit, FFLAS::FflasNoTrans, M, N, A, lda, P, Qt);
-	else
-		r = PLUQ (F, FFLAS::FflasNonUnit, M, N, A, lda, Qt, P);
-
+	else{
+		FFLAS::ParSeqHelper::Sequential PSHelper;
+		r = PLUQ (F, FFLAS::FflasNonUnit, M, N, A, lda, Qt, P, PSHelper);
+	}
 	if (transform){
 		ftrtri (F, FFLAS::FflasUpper, FFLAS::FflasNonUnit, r, A, lda);
 		ftrmm (F, FFLAS::FflasLeft, FFLAS::FflasUpper, FFLAS::FflasNoTrans, FFLAS::FflasNonUnit, r, N-r, F.mOne, A, lda, A+r, lda);
@@ -63,9 +64,10 @@ inline size_t FFPACK::RowEchelonForm (const Field& F, const size_t M, const size
 	size_t r;
 	if (LuTag == FFPACK::FfpackSlabRecursive)
 		r = LUdivine (F, FFLAS::FflasNonUnit, FFLAS::FflasTrans,  M, N, A, lda, P, Qt);
-	else
-		r = PLUQ (F, FFLAS::FflasUnit, M, N, A, lda, P, Qt);
-
+	else{
+		FFLAS::ParSeqHelper::Sequential PSHelper;
+		r = PLUQ (F, FFLAS::FflasUnit, M, N, A, lda, P, Qt, PSHelper);
+	}
 	if (transform){
 		ftrtri (F, FFLAS::FflasLower, FFLAS::FflasNonUnit, r, A, lda);
 		ftrmm (F, FFLAS::FflasRight, FFLAS::FflasLower, FFLAS::FflasNoTrans, FFLAS::FflasNonUnit, M-r, r, F.mOne, A, lda, A+r*lda, lda);
diff --git a/fflas-ffpack/ffpack/ffpack_pluq.inl b/fflas-ffpack/ffpack/ffpack_pluq.inl
index 47dfd22..269ee7e 100644
--- a/fflas-ffpack/ffpack/ffpack_pluq.inl
+++ b/fflas-ffpack/ffpack/ffpack_pluq.inl
@@ -428,6 +428,8 @@ namespace FFPACK {
 	}
 
 
+
+#if 0
 	template<class Field>
 	inline size_t
 	_PLUQ (const Field& Fi, const FFLAS::FFLAS_DIAG Diag,
@@ -649,7 +651,6 @@ namespace FFPACK {
 
 		return R1+R2+R3+R4;
 	}
-
 	template<class Field>
 	inline size_t
 	PLUQ (const Field& Fi, const FFLAS::FFLAS_DIAG Diag,
@@ -662,7 +663,240 @@ namespace FFPACK {
 		checker.check(A,lda,Diag,R,P,Q);
 		return R;
 	}
+#endif /////////////////////////////////////
+	template<class Field>
+	inline size_t
+	_PLUQ (const Field& Fi, const FFLAS::FFLAS_DIAG Diag,
+	       const size_t M, const size_t N,
+	       typename Field::Element_ptr A, const size_t lda, size_t*P, size_t *Q,
+	       size_t BCThreshold)
+	{
+		for (size_t i=0; i<M; ++i) P[i] = i;
+		for (size_t i=0; i<N; ++i) Q[i] = i;
+		if (std::min (M,N) == 0) return 0;
+		if (std::max (M,N) == 1) return (Fi.isZero(*A))? 0 : 1;
+#ifdef NOBASECASE
+		if (M == 1){
+			size_t piv = 0;
+			while ((piv < N) && Fi.isZero (A[piv])) piv++;
+			if (piv == N)
+				return 0;
+			if (piv){
+				Q[0] = piv;
+				Fi.assign (*A, A[piv]);
+				Fi.assign (A[piv], Fi.zero);
+			}
+			if (Diag== FFLAS::FflasUnit){
+				typename Field::Element invpivot;
+				Fi.inv(invpivot, *A);
+				// for (size_t i=piv+1; i<N; ++i)
+					// Fi.mulin (A[i], invpivot);
+				FFLAS::fscalin(Fi,N-piv-1,invpivot,A+piv+1,1);
+			}
+			return 1;
+		}
+		if (N == 1){
+			size_t piv = 0;
+			while ((piv < M) && Fi.isZero (A[piv*lda])) piv++;
+			if (piv == M)
+				return 0;
+			if (piv){
+				P[0] = piv;
+				Fi.assign (*A, *(A+piv*lda));
+				Fi.assign (*(A+piv*lda), Fi.zero);
+			}
+			if (Diag== FFLAS::FflasNonUnit){
+				typename Field::Element invpivot;
+				Fi.inv(invpivot, *A);
+				// for (size_t i=piv+1; i<M; ++i)
+					// Fi.mulin (*(A+i*lda), invpivot);
+				FFLAS::fscalin(Fi,M-piv-1,invpivot,A+(piv+1)*lda,lda);
+			}
+			return 1;
+		}
+#else
+		if (std::min(M,N) < BCThreshold){
+#  ifdef CROUT
+			return PLUQ_basecaseCrout(Fi,Diag,M,N,A,lda,P,Q);
+#  elif defined BCV2
+			return PLUQ_basecaseV2(Fi,Diag,M,N,A,lda,P,Q);
+#  elif defined BCV3
+			return PLUQ_basecaseV3(Fi,Diag,M,N,A,lda,P,Q);
+#  else
+			return PLUQ_basecase(Fi,Diag,M,N,A,lda,P,Q);
+#  endif
+		}
+#endif
+
+		FFLAS::FFLAS_DIAG OppDiag = (Diag == FFLAS::FflasUnit)? FFLAS::FflasNonUnit : FFLAS::FflasUnit;
+		size_t M2 = M >> 1;
+		size_t N2 = N >> 1;
+		size_t * P1 = FFLAS::fflas_new<size_t >(M2);
+		size_t * Q1 = FFLAS::fflas_new<size_t >(N2);
+		size_t R1,R2,R3,R4;
+
+		    // A1 = P1 [ L1 ] [ U1 V1 ] Q1
+		    //         [ M1 ]
+		R1 = _PLUQ (Fi, Diag, M2, N2, A, lda, P1, Q1, BCThreshold);
+		typename Field::Element_ptr A2 = A + N2;
+		typename Field::Element_ptr A3 = A + M2*lda;
+		typename Field::Element_ptr A4 = A3 + N2;
+		typename Field::Element_ptr F = A2 + R1*lda;
+		typename Field::Element_ptr G = A3 + R1;
+		    // [ B1 ] <- P1^T A2
+		    // [ B2 ]
+#ifdef MONOTONIC_APPLYP
+		MonotonicApplyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, N-N2, size_t(0), M2, A2, lda, P1, R1);
+		MonotonicApplyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, M-M2, size_t(0), N2, A3, lda, Q1, R1);
+#else
+		applyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, N-N2, size_t(0), M2, A2, lda, P1);
+		    // [ C1 C2 ] <- A3 Q1^T
+		applyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, M-M2, size_t(0), N2, A3, lda, Q1);
+#endif
+		    // D <- L1^-1 B1
+		ftrsm (Fi, FFLAS::FflasLeft, FFLAS::FflasLower, FFLAS::FflasNoTrans, OppDiag, R1, N-N2, Fi.one, A, lda, A2, lda);
+		    // E <- C1 U1^-1
+		ftrsm (Fi, FFLAS::FflasRight, FFLAS::FflasUpper, FFLAS::FflasNoTrans, Diag, M-M2, R1, Fi.one, A, lda, A3, lda);
+		    // F <- B2 - M1 D
+		fgemm (Fi, FFLAS::FflasNoTrans, FFLAS::FflasNoTrans, M2-R1, N-N2, R1, Fi.mOne, A + R1*lda, lda, A2, lda, Fi.one, A2+R1*lda, lda);
+		    // G <- C2 - E V1
+		fgemm (Fi, FFLAS::FflasNoTrans, FFLAS::FflasNoTrans, M-M2, N2-R1, R1, Fi.mOne, A3, lda, A+R1, lda, Fi.one, A3+R1, lda);
+		    // H <- A4 - ED
+		fgemm (Fi, FFLAS::FflasNoTrans, FFLAS::FflasNoTrans, M-M2, N-N2, R1, Fi.mOne, A3, lda, A2, lda, Fi.one, A4, lda);
+                    // F = P2 [ L2 ] [ U2 V2 ] Q2
+		    //        [ M2 ]
+		size_t * P2 = FFLAS::fflas_new<size_t >(M2-R1);
+		size_t * Q2 = FFLAS::fflas_new<size_t >(N-N2);
+		R2 = _PLUQ (Fi, Diag, M2-R1, N-N2, F, lda, P2, Q2, BCThreshold);
+		    // G = P3 [ L3 ] [ U3 V3 ] Q3
+		    //        [ M3 ]
+		size_t * P3 = FFLAS::fflas_new<size_t >(M-M2);
+		size_t * Q3 = FFLAS::fflas_new<size_t >(N2-R1);
+		R3 = _PLUQ (Fi, Diag, M-M2, N2-R1, G, lda, P3, Q3, BCThreshold);
+		    // [ H1 H2 ] <- P3^T H Q2^T
+		    // [ H3 H4 ]
+#ifdef MONOTONIC_APPLYP
+		MonotonicApplyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, M-M2, size_t(0), N-N2, A4, lda, Q2, R2);
+		MonotonicApplyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, N-N2, size_t(0), M-M2, A4, lda, P3, R3);
+#else
+		applyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, M-M2, size_t(0), N-N2, A4, lda, Q2);
+		applyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, N-N2, size_t(0), M-M2, A4, lda, P3);
+#endif
+		    // [ E1 ] <- P3^T E
+		    // [ E2 ]
+#ifdef MONOTONIC_APPLYP
+		MonotonicApplyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, R1, size_t(0), M-M2, A3, lda, P3, R3);
+#else
+		applyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, R1, size_t(0), M-M2, A3, lda, P3);
+#endif
+		    // [ M11 ] <- P2^T M1
+		    // [ M12 ]
+#ifdef MONOTONIC_APPLYP
+		MonotonicApplyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, R1, size_t(0), M2-R1, A+R1*lda, lda, P2, R2);
+		    // [ D1 D2 ] <- D Q2^T
+		MonotonicApplyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, R1, size_t(0), N-N2, A2, lda, Q2, R2);
+		    // [ V1 V2 ] <- V1 Q3^T
+		MonotonicApplyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, R1, size_t(0), N2-R1, A+R1, lda, Q3, R3);
+#else
+		applyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, R1, size_t(0), M2-R1, A+R1*lda, lda, P2);
+		    // [ D1 D2 ] <- D Q2^T
+		applyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, R1, size_t(0), N-N2, A2, lda, Q2);
+		    // [ V1 V2 ] <- V1 Q3^T
+		applyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, R1, size_t(0), N2-R1, A+R1, lda, Q3);
+#endif
+		    // I <- H U2^-1
+		    // K <- H3 U2^-1
+		ftrsm (Fi, FFLAS::FflasRight, FFLAS::FflasUpper, FFLAS::FflasNoTrans, Diag, M-M2, R2, Fi.one, F, lda, A4, lda);
+		    // J <- L3^-1 I (in a temp)
+		typename Field::Element_ptr temp = FFLAS::fflas_new (Fi, R3, R2);
+		FFLAS::fassign (Fi, R3, R2, A4 , lda, temp , R2);
+		ftrsm (Fi, FFLAS::FflasLeft, FFLAS::FflasLower, FFLAS::FflasNoTrans, OppDiag, R3, R2, Fi.one, G, lda, temp, R2);
+		    // N <- L3^-1 H2
+		ftrsm (Fi, FFLAS::FflasLeft, FFLAS::FflasLower, FFLAS::FflasNoTrans, OppDiag, R3, N-N2-R2, Fi.one, G, lda, A4+R2, lda);
+		    // O <- N - J V2
+		fgemm (Fi, FFLAS::FflasNoTrans, FFLAS::FflasNoTrans, R3, N-N2-R2, R2, Fi.mOne, temp, R2, F+R2, lda, Fi.one, A4+R2, lda);
+		FFLAS::fflas_delete (temp);
+		    // R <- H4 - K V2 - M3 O
+		typename Field::Element_ptr R = A4 + R2 + R3*lda;
+		fgemm (Fi, FFLAS::FflasNoTrans, FFLAS::FflasNoTrans, M-M2-R3, N-N2-R2, R2, Fi.mOne, A4+R3*lda, lda, F+R2, lda, Fi.one, R, lda);
+		fgemm (Fi, FFLAS::FflasNoTrans, FFLAS::FflasNoTrans, M-M2-R3, N-N2-R2, R3, Fi.mOne, G+R3*lda, lda, A4+R2, lda, Fi.one, R, lda);
+		    // H4 = P4 [ L4 ] [ U4 V4 ] Q4
+		    //         [ M4 ]
+		size_t * P4 = FFLAS::fflas_new<size_t >(M-M2-R3);
+		size_t * Q4 = FFLAS::fflas_new<size_t >(N-N2-R2);
+		R4 = _PLUQ (Fi, Diag, M-M2-R3, N-N2-R2, R, lda, P4, Q4, BCThreshold);
+		    // [ E21 M31 0 K1 ] <- P4^T [ E2 M3 0 K ]
+		    // [ E22 M32 0 K2 ]
+#ifdef MONOTONIC_APPLYP
+		MonotonicApplyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, N2+R2, size_t(0), M-M2-R3, A3+R3*lda, lda, P4, R4);
+		    // [ D21 D22 ]     [ D2 ]
+		    // [ V21 V22 ]  <- [ V2 ] Q4^T
+		    // [  0   0  ]     [  0 ]
+		    // [ O1   O2 ]     [  O ]
+		MonotonicApplyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, M2+R3, size_t(0), N-N2-R2, A2+R2, lda, Q4, R4);
+#else
+		applyP (Fi, FFLAS::FflasLeft, FFLAS::FflasNoTrans, N2+R2, size_t(0), M-M2-R3, A3+R3*lda, lda, P4);
+		    // [ D21 D22 ]     [ D2 ]
+		    // [ V21 V22 ]  <- [ V2 ] Q4^T
+		    // [  0   0  ]     [  0 ]
+		    // [ O1   O2 ]     [  O ]
+		applyP (Fi, FFLAS::FflasRight, FFLAS::FflasTrans, M2+R3, size_t(0), N-N2-R2, A2+R2, lda, Q4);
+#endif
+		    // P <- Diag (P1 [ I_R1    ] , P3 [ I_R3    ])
+		    //               [      P2 ]      [      P4 ]
+		size_t* MathP = FFLAS::fflas_new<size_t>(M);
+		composePermutationsLLM (MathP, P1, P2, R1, M2);
+		composePermutationsLLM (MathP+M2, P3, P4, R3, M-M2);
+		FFLAS::fflas_delete( P1);
+		FFLAS::fflas_delete( P2);
+		FFLAS::fflas_delete( P3);
+		FFLAS::fflas_delete( P4);
+		for (size_t i=M2; i<M; ++i)
+			MathP[i] += M2;
+		if (R1+R2 < M2){
+			    // P <- P S
+			PermApplyS (MathP, 1,1,M2, R1, R2, R3, R4);
+			    // A <-  S^T A
+			MatrixApplyS (Fi, A, lda, N, M2, R1, R2, R3, R4);
+		}
+		MathPerm2LAPACKPerm (P, MathP, M);
+		FFLAS::fflas_delete( MathP);
 
+		    // Q<- Diag ( [ I_R1    ] Q1,  [ I_R2    ] Q2 )
+		    //            [      Q3 ]      [      P4 ]
+		size_t * MathQ = FFLAS::fflas_new<size_t >(N);
+		composePermutationsLLM (MathQ, Q1, Q3, R1, N2);
+		composePermutationsLLM (MathQ+N2, Q2, Q4, R2, N-N2);
+		FFLAS::fflas_delete( Q1);
+		FFLAS::fflas_delete( Q2);
+		FFLAS::fflas_delete( Q3);
+		FFLAS::fflas_delete( Q4);
+		for (size_t i=N2; i<N; ++i)
+			MathQ[i] += N2;
+
+		if (R1 < N2){
+			    // Q <- T Q
+			PermApplyT (MathQ, 1,1,N2, R1, R2, R3, R4);
+			    // A <-   A T^T
+			MatrixApplyT (Fi, A, lda, M, N2, R1, R2, R3, R4);
+		}
+		MathPerm2LAPACKPerm (Q, MathQ, N);
+		FFLAS::fflas_delete( MathQ);
+
+		return R1+R2+R3+R4;
+	}
+	template<class Field>
+	inline size_t
+	PLUQ (const Field& Fi, const FFLAS::FFLAS_DIAG Diag,
+	      size_t M, size_t N,
+	      typename Field::Element_ptr A, size_t lda, size_t*P, size_t *Q,
+	      FFLAS::ParSeqHelper::Sequential& PSHelper)
+	{
+		Checker_PLUQ<Field> checker (Fi,M,N,A,lda);
+		size_t R = FFPACK::_PLUQ(Fi,Diag,M,N,A,lda,P,Q,__FFLASFFPACK_PLUQ_THRESHOLD);
+		checker.check(A,lda,Diag,R,P,Q);
+		return R;
+	}
 
 } // namespace FFPACK
 #endif // __FFLASFFPACK_ffpack_pluq_INL
diff --git a/fflas-ffpack/ffpack/ffpack_pluq_mp.inl b/fflas-ffpack/ffpack/ffpack_pluq_mp.inl
index d7531cd..5d052a5 100644
--- a/fflas-ffpack/ffpack/ffpack_pluq_mp.inl
+++ b/fflas-ffpack/ffpack/ffpack_pluq_mp.inl
@@ -39,7 +39,7 @@
 #include "givaro/givinteger.h"
 #include "givaro/modular-integer.h"
 namespace FFPACK {
-
+#if 0
 	template <>
 	inline size_t
 	PLUQ (const Givaro::Modular<Givaro::Integer>& F,
@@ -123,6 +123,90 @@ namespace FFPACK {
 		return R;
 
 	}
+#endif //////////////////////////////////////////
+	template <>
+	inline size_t
+	PLUQ (const Givaro::Modular<Givaro::Integer>& F,
+	      const FFLAS::FFLAS_DIAG Diag,
+	      const size_t M, const size_t N,
+	      typename Givaro::Integer* A, const size_t lda,
+	      size_t*P, size_t *Q, FFLAS::ParSeqHelper::Sequential& PSHelper)
+	{
+
+#ifdef BENCH_PERF_LQUP_MP
+		double t_init=0, t_lqup=0, t_mod=0, t_rec=0;
+		FFLAS::Timer chrono;
+		chrono.start();
+#endif
+		Givaro::Integer p;
+		F.cardinality(p);
+		size_t logp=p.bitsize();
+		size_t K = std::max(M,N);
+
+		// compute bit size of feasible prime
+		size_t _k=std::max(K,logp/20), lk=0;
+		while ( _k ) {_k>>=1; ++lk;}
+		size_t prime_bitsize= (53-lk)>>1;
+
+		// construct rns basis
+		Givaro::Integer maxC= (p-1)*(p-1)*(p-1)*uint64_t(K);
+		uint64_t n_pr =uint64_t(ceil(double(maxC.bitsize())/double(prime_bitsize)));
+		maxC=(p-1)*(p-1)*uint64_t(K)*(1<<prime_bitsize)*n_pr;
+
+		FFPACK::rns_double RNS(maxC, prime_bitsize, true);
+		FFPACK::RNSIntegerMod<FFPACK::rns_double> Zp(p, RNS);
+#ifdef BENCH_PERF_LQUP_MP
+		chrono.stop();
+		t_init+=chrono.usertime();
+		chrono.clear();chrono.start();
+#endif
+		// compute A in RNS
+		FFPACK::rns_double::Element_ptr Ap;
+		Ap = FFLAS::fflas_new(Zp,M,N);
+		FFLAS::finit_rns(Zp,M,N,(logp/16)+(logp%16?1:0),A,lda,Ap);
+
+
+#ifdef BENCH_PERF_LQUP_MP
+		chrono.stop();
+		t_mod+=chrono.usertime();
+		chrono.clear();chrono.start();
+#endif
+		// call lqup in rns
+		size_t R=FFPACK::PLUQ(Zp, Diag, M, N, Ap, N, P, Q, PSHelper);
+#ifdef BENCH_PERF_LQUP_MP
+		chrono.stop();
+		t_lqup+=chrono.usertime();
+		chrono.clear();chrono.start();
+#endif
+		//Zp.write(std::cout,*Ap);
+		// reconstruct the result
+		FFLAS::fconvert_rns(Zp,M,N,F.zero,A,lda,Ap);
+#ifdef BENCH_PERF_LQUP_MP
+		chrono.stop();
+		t_rec+=chrono.usertime();
+		chrono.clear();chrono.start();
+#endif
+		// reduce it modulo p
+		FFLAS::freduce (F,M,N,A,lda);
+		//F.write(std::cout,*A);
+
+#ifdef BENCH_PERF_LQUP_MP
+		chrono.stop();
+		//t_rec+=chrono.usertime();
+		cout<<"PLUQ RNS PERF:"<<endl;
+		cout<<"  ---  RNS basis size: "<<Zp.size() <<endl;
+		cout<<"  ***      init  : "<<t_init<<endl;
+		cout<<"  ***  rns  mod  : "<<t_mod<<endl;
+		cout<<"  ***  rns lqup  : "<<t_lqup<<" ( igemm="<<Zp.t_igemm<<" ftrsm="<<Zp.t_trsm<<" scal="<<Zp.t_scal
+		    <<" modp="<<Zp.t_modp<<endl;
+		cout<<"  ***  rns  rec  : "<<t_rec<<endl;
+		cout<<"  ***       mod  : "<<chrono.usertime()<<endl;
+
+#endif
+		FFLAS::fflas_delete(Ap);
+		return R;
+
+	}
 
 } // namespace FFPACK
 
diff --git a/fflas-ffpack/ffpack/ffpack_ppluq.inl b/fflas-ffpack/ffpack/ffpack_ppluq.inl
index f99e61b..dfd2ee1 100644
--- a/fflas-ffpack/ffpack/ffpack_ppluq.inl
+++ b/fflas-ffpack/ffpack/ffpack_ppluq.inl
@@ -79,12 +79,12 @@ namespace FFPACK {
 
 
 	    // TODO: replace pPLUQ and "int nt", by PLUQ and a Parallel Helper ...
-	template<class Field>
+	template<class Field, class Cut, class Param>
 	inline size_t
-	pPLUQ(const Field& Fi, const FFLAS::FFLAS_DIAG Diag,
+	PLUQ(const Field& Fi, const FFLAS::FFLAS_DIAG Diag,
 	      const size_t M, const size_t N,
 	      typename Field::Element_ptr A, const size_t lda,
-	      size_t* P, size_t* Q, int nt)
+	      size_t* P, size_t* Q, FFLAS::ParSeqHelper::Parallel<Cut,Param>& PSHelper)
 	{
 			  
 		for (size_t i=0; i<M; ++i) P[i] = i;
@@ -147,7 +147,7 @@ namespace FFPACK {
 
 			// A1 = P1 [ L1 ] [ U1 V1 ] Q1
 			//        [ M1 ]
-		R1 = pPLUQ (Fi, Diag, M2, N2, A, lda, P1, Q1,nt);
+		R1 = PLUQ (Fi, Diag, M2, N2, A, lda, P1, Q1,PSHelper);
 
 		typename Field::Element * A2 = A + N2;
 		typename Field::Element * A3 = A + M2*lda;
@@ -158,8 +158,8 @@ namespace FFPACK {
 			// const FFLAS::CuttingStrategy meth = FFLAS::RECURSIVE;
 			// const FFLAS::StrategyParameter strat = FFLAS::TWO_D_ADAPT;
     
-        typename FFLAS::ParSeqHelper::Parallel<FFLAS::CuttingStrategy::Recursive,FFLAS::StrategyParameter::TwoDAdaptive> pWH (std::max(nt,1));
-        typename FFLAS::ParSeqHelper::Parallel<FFLAS::CuttingStrategy::Block,FFLAS::StrategyParameter::Threads> PH (std::max(nt,1));
+        typename FFLAS::ParSeqHelper::Parallel<FFLAS::CuttingStrategy::Recursive,FFLAS::StrategyParameter::TwoDAdaptive> pWH (std::max(PSHelper.numthreads(),1));
+        typename FFLAS::ParSeqHelper::Parallel<FFLAS::CuttingStrategy::Block,FFLAS::StrategyParameter::Threads> PH (std::max(PSHelper.numthreads(),1));
         
         
 		SYNCH_GROUP(
@@ -201,7 +201,7 @@ namespace FFPACK {
 				// F = P2 [ L2 ] [ U2 V2 ] Q2
 				//        [ M2 ]
 			TASK(MODE(CONSTREFERENCE(Fi, P2, Q2, F,/* A4R2,*/ R2) WRITE(R2/*, A4R2[0]*/) READWRITE(F[0], P2, Q2) ),
-				 R2 = pPLUQ( Fi, Diag, M2-R1, N-N2, F, lda, P2, Q2,std::max(nt/2,1))
+				 R2 = PLUQ( Fi, Diag, M2-R1, N-N2, F, lda, P2, Q2,PSHelper)
 					 //A4R2 = A4+R2;
 				 );
 
@@ -212,7 +212,7 @@ namespace FFPACK {
 				// G = P3 [ L3 ] [ U3 V3 ] Q3
 				//        [ M3 ]
 			TASK(MODE(CONSTREFERENCE(Fi, G, Q3, P3, R3) WRITE(R3, P3, Q3) READWRITE(G[0])),
-				 R3 = pPLUQ( Fi, Diag, M-M2, N2-R1, G, lda, P3, Q3,std::max(nt/2,1)));
+				 R3 = PLUQ( Fi, Diag, M-M2, N2-R1, G, lda, P3, Q3,PSHelper));
     
 				// H <- A4 - ED
 			TASK(MODE(CONSTREFERENCE(Fi, A3, A2, A4, pWH) READ(M2, N2, R1, A3[0], A2[0]) READWRITE(A4[0])),
@@ -310,7 +310,7 @@ namespace FFPACK {
 			TASK(MODE(CONSTREFERENCE(Fi, R4, R, P4, Q4, R2, R3, M2, N2) READWRITE(R[0]) WRITE(R4, P4[0], Q4[0])),
 				 P4 = FFLAS::fflas_new<size_t>(M-M2-R3);
 				 Q4 = FFLAS::fflas_new<size_t>(N-N2-R2);
-				 R4 = pPLUQ (Fi, Diag, M-M2-R3, N-N2-R2, R, lda, P4, Q4,std::max(nt,1));
+				 R4 = PLUQ (Fi, Diag, M-M2-R3, N-N2-R2, R, lda, P4, Q4,PSHelper);
 				 );
 			CHECK_DEPENDENCIES;
 
diff --git a/fflas-ffpack/ffpack/ffpack_rankprofiles.inl b/fflas-ffpack/ffpack/ffpack_rankprofiles.inl
index 56aece1..f51a9b0 100644
--- a/fflas-ffpack/ffpack/ffpack_rankprofiles.inl
+++ b/fflas-ffpack/ffpack/ffpack_rankprofiles.inl
@@ -43,9 +43,10 @@ inline size_t RowRankProfile (const Field& F, const size_t M, const size_t N,
 	if (LuTag == FfpackSlabRecursive){
 		R = LUdivine (F, FFLAS::FflasNonUnit, FFLAS::FflasNoTrans, M, N, A, lda, P, Q);
 		std::swap(P,Q);
-	} else
-		R = PLUQ (F, FFLAS::FflasNonUnit, M, N, A, lda, P, Q);
-		
+	} else{
+		FFLAS::ParSeqHelper::Sequential PSHelper;
+		R = PLUQ (F, FFLAS::FflasNonUnit, M, N, A, lda, P, Q, PSHelper);
+	}
 	rkprofile = FFLAS::fflas_new<size_t> (R);
 	
 	RankProfileFromLU (P, M, R, rkprofile, LuTag);
@@ -67,9 +68,10 @@ inline size_t ColumnRankProfile (const Field& F, const size_t M, const size_t N,
 
 	if (LuTag == FfpackSlabRecursive){
 		R = LUdivine (F, FFLAS::FflasNonUnit, FFLAS::FflasTrans, M, N, A, lda, P, Q);
-	} else
-		R = PLUQ (F, FFLAS::FflasNonUnit, M, N, A, lda, P, Q);
-		
+	} else{
+		FFLAS::ParSeqHelper::Sequential PSHelper;
+		R = PLUQ (F, FFLAS::FflasNonUnit, M, N, A, lda, P, Q, PSHelper);
+	}
 	rkprofile = FFLAS::fflas_new<size_t> (R);
 	
 	RankProfileFromLU (Q, N, R, rkprofile, LuTag);
diff --git a/fflas-ffpack/interfaces/libs/ffpack.C b/fflas-ffpack/interfaces/libs/ffpack.C
index 330c9ce..7c75920 100644
--- a/fflas-ffpack/interfaces/libs/ffpack.C
+++ b/fflas-ffpack/interfaces/libs/ffpack.C
@@ -329,10 +329,12 @@ PLUQ_modular_double (const double p, const enum FFLAS::FFLAS_DIAG Diag,
 {
 	if (positive) {
 		Modular<double> F(p);
-		return PLUQ(F,(enum FFLAS::FFLAS_DIAG)Diag,M,N,A,lda,P,Q);
+		FFLAS::ParSeqHelper::Sequential PSHelper;
+		return PLUQ(F,(enum FFLAS::FFLAS_DIAG)Diag,M,N,A,lda,P,Q,PSHelper);
 	} else {
 		ModularBalanced<double> F(p);
-		return PLUQ(F,(enum FFLAS::FFLAS_DIAG)Diag,M,N,A,lda,P,Q);
+		FFLAS::ParSeqHelper::Sequential PSHelper;
+		return PLUQ(F,(enum FFLAS::FFLAS_DIAG)Diag,M,N,A,lda,P,Q,PSHelper);
 	}
 }
 
diff --git a/fflas-ffpack/interfaces/libs/ffpack_inst_implem.inl b/fflas-ffpack/interfaces/libs/ffpack_inst_implem.inl
index 51e117c..4256762 100644
--- a/fflas-ffpack/interfaces/libs/ffpack_inst_implem.inl
+++ b/fflas-ffpack/interfaces/libs/ffpack_inst_implem.inl
@@ -91,13 +91,13 @@ namespace FFPACK {
 						const size_t width, const size_t M2,
 						const size_t R1, const size_t R2,
 						const size_t R3, const size_t R4) ;
-	
+/*
 	template INST_OR_DECL
 	size_t pPLUQ(const FFLAS_FIELD<FFLAS_ELT>& Fi, const FFLAS::FFLAS_DIAG Diag,
 				 const size_t M, const size_t N,
 				 FFLAS_ELT* A, const size_t lda,
 				 size_t* P, size_t* Q, int nt);
-
+*/
 	template INST_OR_DECL
 	void fgetrs (const FFLAS_FIELD<FFLAS_ELT>& F,
 				 const FFLAS::FFLAS_SIDE Side,
@@ -150,7 +150,7 @@ namespace FFPACK {
 	size_t PLUQ (const FFLAS_FIELD<FFLAS_ELT>& F, const FFLAS::FFLAS_DIAG Diag,
 				 const size_t M, const size_t N,
 				 FFLAS_ELT* A, const size_t lda,
-				 size_t*P, size_t *Q, size_t BCThreshold);
+				 size_t*P, size_t *Q, FFLAS::ParSeqHelper::Sequential& PSHelper);
 
 	template INST_OR_DECL
 	size_t LUdivine (const FFLAS_FIELD<FFLAS_ELT>& F, const FFLAS::FFLAS_DIAG Diag,  const FFLAS::FFLAS_TRANSPOSE trans,
diff --git a/tests/test-pluq-check.C b/tests/test-pluq-check.C
index 5860842..a9d1dbf 100644
--- a/tests/test-pluq-check.C
+++ b/tests/test-pluq-check.C
@@ -74,6 +74,7 @@ int main(int argc, char** argv) {
 	size_t pass = 0;	// number of tests that have successfully passed
 
 	FFLAS_DIAG Diag = FflasNonUnit;
+	FFLAS::ParSeqHelper::Sequential PSHelper;
 	for(size_t it=0; it<iter; ++it) {
 		if (random_dim) {
 			m = random() % MAXM + 1;
@@ -88,7 +89,7 @@ int main(int argc, char** argv) {
 		PAR_BLOCK { pfrand(F,Rand, m,n,A,m/MAX_THREADS); }
   
 		try {
-			FFPACK::PLUQ(F, Diag, m, n, A, n, P, Q);
+			FFPACK::PLUQ(F, Diag, m, n, A, n, P, Q, PSHelper);
 			std::cerr << m << 'x' << n << ' ' << Diag << " pluq verification PASSED\n";
 			pass++;
 		} catch(FailurePLUQCheck &e) {
