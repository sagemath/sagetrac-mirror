Author: François Bissey francois.bissey@canterbury.ac.nz
Patch between 4.0.1 and https://github.com/pexpect/pexpect/commit/40ce421051c0a54f3b3849424491882cf1339801
The current top of the "superfluous sleep" branch of pexpect which
includes behavior we requested for sage.

diff -Naur pexpect-4.0.1.orig/DEVELOPERS.rst pexpect-4.0.1/DEVELOPERS.rst
--- pexpect-4.0.1.orig/DEVELOPERS.rst	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/DEVELOPERS.rst	2015-11-05 13:29:44.347347835 +1300
@@ -0,0 +1,12 @@
+To run the tests, use `py.test <http://pytest.org/latest/>`_::
+
+    py.test tests
+
+The tests are all located in the tests/ directory. To add a new unit
+test all you have to do is create the file in the tests/ directory with a
+filename in this format::
+
+    test_*.py
+
+New test case classes may wish to inherit from ``PexpectTestCase.PexpectTestCase``
+in the tests directory, which sets up some convenient functionality.
diff -Naur pexpect-4.0.1.orig/MANIFEST.in pexpect-4.0.1/MANIFEST.in
--- pexpect-4.0.1.orig/MANIFEST.in	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/MANIFEST.in	2015-11-05 13:29:44.347347835 +1300
@@ -0,0 +1,6 @@
+recursive-include doc *
+prune doc/_build
+recursive-include examples *
+include .coveragerc README.rst LICENSE pexpect/bashrc.sh
+recursive-include tests *
+global-exclude __pycache__ *.pyc *~
diff -Naur pexpect-4.0.1.orig/PKG-INFO pexpect-4.0.1/PKG-INFO
--- pexpect-4.0.1.orig/PKG-INFO	2015-10-07 03:36:49.000000000 +1300
+++ pexpect-4.0.1/PKG-INFO	1970-01-01 12:00:00.000000000 +1200
@@ -1,47 +0,0 @@
-Metadata-Version: 1.1
-Name: pexpect
-Version: 4.0.1
-Summary: Pexpect allows easy control of interactive console applications.
-Home-page: http://pexpect.readthedocs.org/
-Author: Noah Spurrier; Thomas Kluyver; Jeff Quast
-Author-email: noah@noah.org; thomas@kluyver.me.uk; contact@jeffquast.com
-License: ISC license
-Description: 
-        Pexpect is a pure Python module for spawning child applications; controlling
-        them; and responding to expected patterns in their output. Pexpect works like
-        Don Libes' Expect. Pexpect allows your script to spawn a child application and
-        control it as if a human were typing commands.
-        
-        Pexpect can be used for automating interactive applications such as ssh, ftp,
-        passwd, telnet, etc. It can be used to a automate setup scripts for duplicating
-        software package installations on different servers. It can be used for
-        automated software testing. Pexpect is in the spirit of Don Libes' Expect, but
-        Pexpect is pure Python.
-        
-        The main features of Pexpect require the pty module in the Python standard
-        library, which is only available on Unix-like systems. Some features—waiting
-        for patterns from file descriptors or subprocesses—are also available on
-        Windows.
-        
-Platform: UNIX
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Environment :: Console
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: System Administrators
-Classifier: License :: OSI Approved :: ISC License (ISCL)
-Classifier: Operating System :: POSIX
-Classifier: Operating System :: MacOS :: MacOS X
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 2.6
-Classifier: Programming Language :: Python :: 2.7
-Classifier: Programming Language :: Python :: 3
-Classifier: Topic :: Software Development
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Classifier: Topic :: Software Development :: Quality Assurance
-Classifier: Topic :: Software Development :: Testing
-Classifier: Topic :: System
-Classifier: Topic :: System :: Archiving :: Packaging
-Classifier: Topic :: System :: Installation/Setup
-Classifier: Topic :: System :: Shells
-Classifier: Topic :: System :: Software Distribution
-Classifier: Topic :: Terminals
diff -Naur pexpect-4.0.1.orig/README.rst pexpect-4.0.1/README.rst
--- pexpect-4.0.1.orig/README.rst	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/README.rst	2015-11-05 13:29:44.347347835 +1300
@@ -0,0 +1,55 @@
+.. image:: https://travis-ci.org/pexpect/pexpect.png?branch=master
+   :target: https://travis-ci.org/pexpect/pexpect
+   :align: right
+   :alt: Build status
+
+Pexpect is a Pure Python Expect-like module
+
+Pexpect makes Python a better tool for controlling other applications.
+
+Pexpect is a pure Python module for spawning child applications; controlling
+them; and responding to expected patterns in their output. Pexpect works like
+Don Libes' Expect. Pexpect allows your script to spawn a child application and
+control it as if a human were typing commands.
+
+Pexpect can be used for automating interactive applications such as ssh, ftp,
+passwd, telnet, etc. It can be used to a automate setup scripts for duplicating
+software package installations on different servers. It can be used for
+automated software testing. Pexpect is in the spirit of Don Libes' Expect, but
+Pexpect is pure Python.
+
+The main features of Pexpect require the pty module in the Python standard
+library, which is only available on Unix-like systems. Some features—waiting
+for patterns from file descriptors or subprocesses—are also available on
+Windows.
+
+If you want to work with the development version of the source code then please
+read the DEVELOPERS.rst document in the root of the source code tree.
+
+Free, open source, and all that good stuff.
+
+You can install Pexpect using pip::
+
+    pip install pexpect
+
+`Docs on ReadTheDocs <http://pexpect.readthedocs.org/>`_
+
+PEXPECT LICENSE::
+
+    http://opensource.org/licenses/isc-license.txt
+
+    Copyright (c) 2013-2014, Pexpect development team
+    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
+
+    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
+    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
+    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
+    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+This license is approved by the OSI and FSF as GPL-compatible.
diff -Naur pexpect-4.0.1.orig/doc/conf.py pexpect-4.0.1/doc/conf.py
--- pexpect-4.0.1.orig/doc/conf.py	2015-10-07 03:31:40.000000000 +1300
+++ pexpect-4.0.1/doc/conf.py	2015-11-05 13:29:44.357347837 +1300
@@ -52,9 +52,9 @@
 # built documents.
 #
 # The short X.Y version.
-version = '4.0.1'
+version = '4.1'
 # The full version, including alpha/beta/rc tags.
-release = '4.0.1'
+release = '4.1.dev'
 
 # The language for content autogenerated by Sphinx. Refer to documentation
 # for a list of supported languages.
diff -Naur pexpect-4.0.1.orig/notes/my_forkpty.py pexpect-4.0.1/notes/my_forkpty.py
--- pexpect-4.0.1.orig/notes/my_forkpty.py	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/notes/my_forkpty.py	2015-11-05 13:29:44.397347850 +1300
@@ -0,0 +1,89 @@
+import os, fcntl, termios
+import time
+
+def my_forkpty():
+
+    (master_fd, slave_fd) = os.openpty()
+
+    if (master_fd < 0  or  slave_fd < 0):
+        raise ExceptionPexpect("Forkpty failed")
+
+    # slave_name = ptsname(master_fd);
+
+    pid = os.fork();
+    if pid == -1:
+        raise ExceptionPexpect("Forkpty failed")
+    elif pid == 0: # Child
+        if hasattr(termios, 'TIOCNOTTY'):
+        #        Some platforms require an explicit detach of the
+        #        current controlling tty before closing stdin, stdout, stderr.
+        #        OpenBSD says that this is obsolete, but doesn't hurt.
+            try:
+                fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY)
+            except:
+                pass
+            else: #if fd >= 0:
+                fcntl.ioctl(fd, termios.TIOCNOTTY, 0)
+                os.close(fd)
+
+        # The setsid() system call will place the process into its own session
+        # which has the effect of disassociating it from the controlling terminal.
+        # This is known to be true for OpenBSD.
+        os.setsid()
+        # except:            return posix_error();
+
+        # Verify that we are disconnected from the controlling tty.
+        try:
+            fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY)
+            os.close(fd)
+            raise ExceptionPexpect("Forkpty failed")
+        except:
+            pass
+        if 'TIOCSCTTY' in dir(termios):
+            # Make the pseudo terminal the controlling terminal for this process
+            # (the process must not currently have a controlling terminal).
+            if fcntl.ioctl(slave_fd, termios.TIOCSCTTY, '') < 0:
+                raise ExceptionPexpect("Forkpty failed")
+
+#        # Verify that we can open to the slave pty file. */
+#        fd = os.open(slave_name, os.O_RDWR);
+#        if fd < 0:
+#            raise ExceptionPexpect("Forkpty failed")
+#        else:
+#            os.close(fd);
+
+        # Verify that we now have a controlling tty.
+        fd = os.open("/dev/tty", os.O_WRONLY)
+        if fd < 0:
+            raise ExceptionPexpect("This process could not get a controlling tty.")
+        else:
+            os.close(fd)
+
+        os.close(master_fd)
+        os.dup2(slave_fd, 0)
+        os.dup2(slave_fd, 1)
+        os.dup2(slave_fd, 2)
+        if slave_fd > 2:
+            os.close(slave_fd)
+        pid = 0
+
+    else:
+        # PARENT 
+        os.close(slave_fd);
+
+    if pid == -1:
+        raise ExceptionPexpect("This process could not get a controlling tty.")
+#    if (pid == 0)
+#        PyOS_AfterFork();
+
+    return (pid, master_fd)
+
+pid, fd = my_forkpty ()
+if pid == 0: # child
+    print 'I am not a robot!'
+else:
+    print '(pid, fd) = (%d, %d)' % (pid, fd)
+    time.sleep(1) # Give the child a chance to print.
+    print 'Robots always say:', os.read(fd,100)
+    os.close(fd)
+
diff -Naur pexpect-4.0.1.orig/notes/notes.txt pexpect-4.0.1/notes/notes.txt
--- pexpect-4.0.1.orig/notes/notes.txt	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/notes/notes.txt	2015-11-05 13:29:44.397347850 +1300
@@ -0,0 +1,50 @@
+
+####################
+#
+#        NOTES
+#
+####################
+
+##    def send_human(self, text, delay_min = 0, delay_max = 1):
+##        pass
+##    def spawn2(self, command, args):
+##        """return pid, fd_stdio, fd_stderr
+##        """
+##        pass
+
+
+# Reason for double fork:
+# http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC15
+# Reason for ptys:
+# http://www.erlenstar.demon.co.uk/unix/faq_4.html#SEC52
+
+# Nonblocking on Win32?
+# Reasearch this as a way to maybe make pipe work for Win32.
+# http://groups.google.com/groups?q=setraw+tty&hl=en&selm=uvgpvisvk.fsf%40roundpoint.com&rnum=7
+# 
+#    if istty:
+#        if os.name=='posix':
+#            import tty
+#            tty.setraw(sys.stdin.fileno())
+#        elif os.name=='nt':
+#            import win32file, win32con
+#            hstdin = win32file._get_osfhandle(sys.stdin.fileno())
+#            modes = (win32file.GetConsoleMode(hstdin)
+#                     & ~(win32con.ENABLE_LINE_INPUT
+#                         |win32con.ENABLE_ECHO_INPUT))
+#            win32file.SetConsoleMode(hstdin, modes)
+
+# Basic documentation:
+#       Explain use of lists of patterns and return index.
+#       Explain exceptions for non-handled special cases like EOF
+
+# Test bad fork
+# Test ENOENT. In other words, no more TTY devices.
+
+#GLOBAL_SIGCHLD_RECEIVED = 0
+#def childdied (signum, frame):
+#    print 'Signal handler called with signal', signum
+#    frame.f_globals['pexpect'].GLOBAL_SIGCHLD_RECEIVED = 1
+#    print str(frame.f_globals['pexpect'].GLOBAL_SIGCHLD_RECEIVED)
+#    GLOBAL_SIGCHLD_RECEIVED = 1
+
diff -Naur pexpect-4.0.1.orig/notes/posixmodule.c.diff pexpect-4.0.1/notes/posixmodule.c.diff
--- pexpect-4.0.1.orig/notes/posixmodule.c.diff	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/notes/posixmodule.c.diff	2015-11-05 13:29:44.397347850 +1300
@@ -0,0 +1,233 @@
+*** Python-2.2.1.orig/Modules/posixmodule.c	Tue Mar 12 16:38:31 2002
+--- Python-2.2.1/Modules/posixmodule.c	Tue May 21 01:16:29 2002
+***************
+*** 1904,1910 ****
+  }
+  #endif
+  
+! #if defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY)
+  #ifdef HAVE_PTY_H
+  #include <pty.h>
+  #else
+--- 1904,1913 ----
+  }
+  #endif
+  
+! #if defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) || defined(sun)
+! #ifdef sun
+! #include <sys/stropts.h>
+! #endif
+  #ifdef HAVE_PTY_H
+  #include <pty.h>
+  #else
+***************
+*** 1914,1920 ****
+  #endif /* HAVE_PTY_H */
+  #endif /* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) */
+  
+! #if defined(HAVE_OPENPTY) || defined(HAVE__GETPTY)
+  static char posix_openpty__doc__[] =
+  "openpty() -> (master_fd, slave_fd)\n\
+  Open a pseudo-terminal, returning open fd's for both master and slave end.\n";
+--- 1917,1923 ----
+  #endif /* HAVE_PTY_H */
+  #endif /* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) */
+  
+! #if defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) || defined(sun)
+  static char posix_openpty__doc__[] =
+  "openpty() -> (master_fd, slave_fd)\n\
+  Open a pseudo-terminal, returning open fd's for both master and slave end.\n";
+***************
+*** 1925,1932 ****
+  	int master_fd, slave_fd;
+  #ifndef HAVE_OPENPTY
+  	char * slave_name;
+  #endif
+! 
+  	if (!PyArg_ParseTuple(args, ":openpty"))
+  		return NULL;
+  
+--- 1928,1941 ----
+  	int master_fd, slave_fd;
+  #ifndef HAVE_OPENPTY
+  	char * slave_name;
++ #ifdef sun
++         void *sig_saved;
+  #endif
+! #endif
+! #if !defined(HAVE_OPENPTY) && !defined(HAVE__GETPTY) && defined(sun)
+!         extern char *ptsname();
+! #endif
+!         
+  	if (!PyArg_ParseTuple(args, ":openpty"))
+  		return NULL;
+  
+***************
+*** 1933,1939 ****
+  #ifdef HAVE_OPENPTY
+  	if (openpty(&master_fd, &slave_fd, NULL, NULL, NULL) != 0)
+  		return posix_error();
+! #else
+  	slave_name = _getpty(&master_fd, O_RDWR, 0666, 0);
+  	if (slave_name == NULL)
+  		return posix_error();
+--- 1942,1948 ----
+  #ifdef HAVE_OPENPTY
+  	if (openpty(&master_fd, &slave_fd, NULL, NULL, NULL) != 0)
+  		return posix_error();
+! #elif HAVE__GETPTY
+  	slave_name = _getpty(&master_fd, O_RDWR, 0666, 0);
+  	if (slave_name == NULL)
+  		return posix_error();
+***************
+*** 1941,1946 ****
+--- 1950,1966 ----
+  	slave_fd = open(slave_name, O_RDWR);
+  	if (slave_fd < 0)
+  		return posix_error();
++ #else
++         master_fd = open("/dev/ptmx", O_RDWR|O_NOCTTY);  /* open master */
++         sig_saved = signal(SIGCHLD, SIG_DFL);
++         grantpt(master_fd);                     /* change permission of   slave */
++         unlockpt(master_fd);                    /* unlock slave */
++         signal(SIGCHLD,sig_saved);
++         slave_name = ptsname(master_fd);         /* get name of slave */
++         slave_fd = open(slave_name, O_RDWR);    /* open slave */
++         ioctl(slave_fd, I_PUSH, "ptem");       /* push ptem */
++         ioctl(slave_fd, I_PUSH, "ldterm");     /* push ldterm*/
++         ioctl(slave_fd, I_PUSH, "ttcompat");     /* push ttcompat*/
+  #endif /* HAVE_OPENPTY */
+  
+  	return Py_BuildValue("(ii)", master_fd, slave_fd);
+***************
+*** 1948,1954 ****
+  }
+  #endif /* defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) */
+  
+! #ifdef HAVE_FORKPTY
+  static char posix_forkpty__doc__[] =
+  "forkpty() -> (pid, master_fd)\n\
+  Fork a new process with a new pseudo-terminal as controlling tty.\n\n\
+--- 1968,1974 ----
+  }
+  #endif /* defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) */
+  
+! #if defined(HAVE_FORKPTY) || defined(sun)
+  static char posix_forkpty__doc__[] =
+  "forkpty() -> (pid, master_fd)\n\
+  Fork a new process with a new pseudo-terminal as controlling tty.\n\n\
+***************
+*** 1959,1968 ****
+--- 1979,2067 ----
+  posix_forkpty(PyObject *self, PyObject *args)
+  {
+  	int master_fd, pid;
++ #if defined(sun)
++         int slave;
++ 	char * slave_name;
++         void *sig_saved;
++         int fd;
++ #endif
+  	
+  	if (!PyArg_ParseTuple(args, ":forkpty"))
+  		return NULL;
++ #if defined(sun)
++         master_fd = open("/dev/ptmx", O_RDWR|O_NOCTTY);  /* open master */
++         sig_saved = signal(SIGCHLD, SIG_DFL);
++         grantpt(master_fd);                     /* change permission of   slave */
++         unlockpt(master_fd);                    /* unlock slave */
++         signal(SIGCHLD,sig_saved);
++         slave_name = ptsname(master_fd);         /* get name of slave */
++         slave = open(slave_name, O_RDWR);    /* open slave */
++         ioctl(slave, I_PUSH, "ptem");       /* push ptem */
++         ioctl(slave, I_PUSH, "ldterm");     /* push ldterm*/
++         ioctl(slave, I_PUSH, "ttcompat");     /* push ttcompat*/
++         if (master_fd < 0 || slave < 0)
++         {
++             return posix_error();
++         }
++ 	switch (pid = fork()) {
++ 	case -1:	
++             return posix_error();
++ 	case 0:
++             /* First disconnect from the old controlling tty. */
++ #ifdef TIOCNOTTY
++             fd = open("/dev/tty", O_RDWR | O_NOCTTY);
++             if (fd >= 0) {
++ 		(void) ioctl(fd, TIOCNOTTY, NULL);
++ 		close(fd);
++             }
++ #endif /* TIOCNOTTY */
++             if (setsid() < 0)
++ 		return posix_error();
++             
++             /*
++              * Verify that we are successfully disconnected from the controlling
++              * tty.
++              */
++             fd = open("/dev/tty", O_RDWR | O_NOCTTY);
++             if (fd >= 0) {
++ 		return posix_error();
++ 		close(fd);
++             }
++             /* Make it our controlling tty. */
++ #ifdef TIOCSCTTY
++             if (ioctl(slave, TIOCSCTTY, NULL) < 0)
++ 		return posix_error();
++ #endif /* TIOCSCTTY */
++             fd = open(slave_name, O_RDWR);
++             if (fd < 0) {
++ 		return posix_error();
++             } else {
++ 		close(fd);
++             }
++             /* Verify that we now have a controlling tty. */
++             fd = open("/dev/tty", O_WRONLY);
++             if (fd < 0)
++ 		return posix_error();
++             else {
++ 		close(fd);
++             }
++             (void) close(master_fd);
++             (void) dup2(slave, 0);
++             (void) dup2(slave, 1);
++             (void) dup2(slave, 2);
++             if (slave > 2)
++                 (void) close(slave);
++             pid = 0;
++             break;
++           defautlt:
++             /*
++              * parent
++              */
++             (void) close(slave);
++ 	}
++ #else
+  	pid = forkpty(&master_fd, NULL, NULL, NULL);
++ #endif
+  	if (pid == -1)
+  		return posix_error();
+  	if (pid == 0)
+***************
+*** 5607,5616 ****
+  #ifdef HAVE_FORK
+  	{"fork",	posix_fork, METH_VARARGS, posix_fork__doc__},
+  #endif /* HAVE_FORK */
+! #if defined(HAVE_OPENPTY) || defined(HAVE__GETPTY)
+  	{"openpty",	posix_openpty, METH_VARARGS, posix_openpty__doc__},
+  #endif /* HAVE_OPENPTY || HAVE__GETPTY */
+! #ifdef HAVE_FORKPTY
+  	{"forkpty",	posix_forkpty, METH_VARARGS, posix_forkpty__doc__},
+  #endif /* HAVE_FORKPTY */
+  #ifdef HAVE_GETEGID
+--- 5706,5715 ----
+  #ifdef HAVE_FORK
+  	{"fork",	posix_fork, METH_VARARGS, posix_fork__doc__},
+  #endif /* HAVE_FORK */
+! #if defined(HAVE_OPENPTY) || defined(HAVE__GETPTY) || defined(sun)
+  	{"openpty",	posix_openpty, METH_VARARGS, posix_openpty__doc__},
+  #endif /* HAVE_OPENPTY || HAVE__GETPTY */
+! #if defined(HAVE_FORKPTY) || defined(sun)
+  	{"forkpty",	posix_forkpty, METH_VARARGS, posix_forkpty__doc__},
+  #endif /* HAVE_FORKPTY */
+  #ifdef HAVE_GETEGID
diff -Naur pexpect-4.0.1.orig/pexpect/__init__.py pexpect-4.0.1/pexpect/__init__.py
--- pexpect-4.0.1.orig/pexpect/__init__.py	2015-10-07 03:31:30.000000000 +1300
+++ pexpect-4.0.1/pexpect/__init__.py	2015-11-05 13:29:44.397347850 +1300
@@ -75,7 +75,7 @@
     from .pty_spawn import spawn, spawnu
     from .run import run, runu
 
-__version__ = '4.0.1'
+__version__ = '4.1.dev'
 __revision__ = ''
 __all__ = ['ExceptionPexpect', 'EOF', 'TIMEOUT', 'spawn', 'spawnu', 'run', 'runu',
            'which', 'split_command_line', '__version__', '__revision__']
diff -Naur pexpect-4.0.1.orig/pexpect/async.py pexpect-4.0.1/pexpect/async.py
--- pexpect-4.0.1.orig/pexpect/async.py	2015-10-04 21:18:45.000000000 +1300
+++ pexpect-4.0.1/pexpect/async.py	2015-11-05 13:29:44.397347850 +1300
@@ -23,6 +23,7 @@
         return expecter.timeout(e)
 
 class PatternWaiter(asyncio.Protocol):
+    transport = None
     def __init__(self, expecter):
         self.expecter = expecter
         self.fut = asyncio.Future()
@@ -30,10 +31,15 @@
     def found(self, result):
         if not self.fut.done():
             self.fut.set_result(result)
+            self.transport.pause_reading()
     
     def error(self, exc):
         if not self.fut.done():
             self.fut.set_exception(exc)
+            self.transport.pause_reading()
+
+    def connection_made(self, transport):
+        self.transport = transport
     
     def data_received(self, data):
         spawn = self.expecter.spawn
@@ -41,11 +47,11 @@
         spawn._log(s, 'read')
 
         if self.fut.done():
-            spawn.buffer += data
+            spawn.buffer += s
             return
 
         try:
-            index = self.expecter.new_data(data)
+            index = self.expecter.new_data(s)
             if index is not None:
                 # Found a match
                 self.found(index)
diff -Naur pexpect-4.0.1.orig/pexpect/bashrc.sh pexpect-4.0.1/pexpect/bashrc.sh
--- pexpect-4.0.1.orig/pexpect/bashrc.sh	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/pexpect/bashrc.sh	2015-11-05 13:29:44.397347850 +1300
@@ -0,0 +1,5 @@
+source /etc/bash.bashrc
+source ~/.bashrc
+
+# Reset PS1 so pexpect can find it
+PS1="$"
diff -Naur pexpect-4.0.1.orig/pexpect/expect.py pexpect-4.0.1/pexpect/expect.py
--- pexpect-4.0.1.orig/pexpect/expect.py	2015-10-04 21:18:45.000000000 +1300
+++ pexpect-4.0.1/pexpect/expect.py	2015-11-05 13:29:44.397347850 +1300
@@ -95,7 +95,8 @@
                     return self.timeout()
                 # Still have time left, so read more data
                 incoming = spawn.read_nonblocking(spawn.maxread, timeout)
-                time.sleep(0.0001)
+                if self.spawn.delayafterread is not None:
+                    time.sleep(self.spawn.delayafterread)
                 if timeout is not None:
                     timeout = end_time - time.time()
         except EOF as e:
@@ -294,4 +295,4 @@
         self.start = first_match
         self.match = the_match
         self.end = self.match.end()
-        return best_index
\ No newline at end of file
+        return best_index
diff -Naur pexpect-4.0.1.orig/pexpect/pty_spawn.py pexpect-4.0.1/pexpect/pty_spawn.py
--- pexpect-4.0.1.orig/pexpect/pty_spawn.py	2015-10-07 02:22:14.000000000 +1300
+++ pexpect-4.0.1/pexpect/pty_spawn.py	2015-11-05 13:29:44.397347850 +1300
@@ -285,6 +285,11 @@
         if dimensions is not None:
             kwargs['dimensions'] = dimensions
 
+        if self.encoding is not None:
+            # Encode command line using the specified encoding
+            self.args = [a if isinstance(a, bytes) else a.encode(self.encoding)
+                         for a in self.args]
+
         self.ptyproc = ptyprocess.PtyProcess.spawn(self.args, env=self.env,
                                                    cwd=self.cwd, **kwargs)
 
@@ -487,9 +492,9 @@
 
         This value may be discovered using fpathconf(3)::
 
-        >>> from os import fpathconf
-        >>> print(fpathconf(0, 'PC_MAX_CANON'))
-        256
+            >>> from os import fpathconf
+            >>> print(fpathconf(0, 'PC_MAX_CANON'))
+            256
 
         On such a system, only 256 bytes may be received per line. Any
         subsequent bytes received will be discarded. BEL (``'\a'``) is then
@@ -500,10 +505,10 @@
         Canonical input processing may be disabled altogether by executing
         a shell, then stty(1), before executing the final program::
 
-        >>> bash = pexpect.spawn('/bin/bash', echo=False)
-        >>> bash.sendline('stty -icanon')
-        >>> bash.sendline('base64')
-        >>> bash.sendline('x' * 5000)
+            >>> bash = pexpect.spawn('/bin/bash', echo=False)
+            >>> bash.sendline('stty -icanon')
+            >>> bash.sendline('base64')
+            >>> bash.sendline('x' * 5000)
         '''
 
         time.sleep(self.delaybeforesend)
diff -Naur pexpect-4.0.1.orig/pexpect/spawnbase.py pexpect-4.0.1/pexpect/spawnbase.py
--- pexpect-4.0.1.orig/pexpect/spawnbase.py	2015-10-04 21:18:45.000000000 +1300
+++ pexpect-4.0.1/pexpect/spawnbase.py	2015-11-05 13:29:44.397347850 +1300
@@ -70,6 +70,10 @@
         # Used by terminate() to give kernel time to update process status.
         # Time in seconds.
         self.delayafterterminate = 0.1
+        # After each call to read_nonblocking(), pexpect releases the GIL
+        # through a time.sleep(0.0001) call by default since version 2.1.
+        # When set as value 'None', the old 2.0 behavior is restored.
+        self.delayafterread = 0.0001
         self.softspace = False
         self.name = '<' + repr(self) + '>'
         self.closed = True
diff -Naur pexpect-4.0.1.orig/requirements-testing.txt pexpect-4.0.1/requirements-testing.txt
--- pexpect-4.0.1.orig/requirements-testing.txt	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/requirements-testing.txt	2015-11-05 13:29:44.397347850 +1300
@@ -0,0 +1,5 @@
+pytest
+pytest-cov
+coverage
+coveralls
+pytest-capturelog
diff -Naur pexpect-4.0.1.orig/tests/log pexpect-4.0.1/tests/log
--- pexpect-4.0.1.orig/tests/log	2015-10-04 00:05:43.000000000 +1300
+++ pexpect-4.0.1/tests/log	1970-01-01 12:00:00.000000000 +1200
@@ -1,10 +0,0 @@
-\,ESC
-P,ESC
-\,ESC
-P,ESC
-\,ESC
-P,ESC
-\,ESC
-P,ESC
-\,ESC
-r,SEMICOLON
diff -Naur pexpect-4.0.1.orig/tests/test_async.py pexpect-4.0.1/tests/test_async.py
--- pexpect-4.0.1.orig/tests/test_async.py	2015-10-04 21:18:45.000000000 +1300
+++ pexpect-4.0.1/tests/test_async.py	2015-11-05 13:29:44.427347860 +1300
@@ -43,9 +43,15 @@
         coro = p.expect('Blah', async=True)
         with self.assertRaises(pexpect.EOF):
             run(coro)
-    
+
     def test_expect_exact(self):
         p = pexpect.spawn('%s list100.py' % sys.executable)
         assert run(p.expect_exact(b'5', async=True)) == 0
         assert run(p.expect_exact(['wpeok', b'11'], async=True)) == 1
         assert run(p.expect_exact([b'foo', pexpect.EOF], async=True)) == 1
+
+    def test_async_utf8(self):
+        p = pexpect.spawn('%s list100.py' % sys.executable, encoding='utf8')
+        assert run(p.expect_exact(u'5', async=True)) == 0
+        assert run(p.expect_exact([u'wpeok', u'11'], async=True)) == 1
+        assert run(p.expect_exact([u'foo', pexpect.EOF], async=True)) == 1
diff -Naur pexpect-4.0.1.orig/tests/test_maxcanon.py pexpect-4.0.1/tests/test_maxcanon.py
--- pexpect-4.0.1.orig/tests/test_maxcanon.py	2015-10-04 21:18:45.000000000 +1300
+++ pexpect-4.0.1/tests/test_maxcanon.py	1970-01-01 12:00:00.000000000 +1200
@@ -1,176 +0,0 @@
-""" Module for canonical-mode tests. """
-# std imports
-import sys
-import os
-
-# local
-import pexpect
-from . import PexpectTestCase
-
-# 3rd-party
-import pytest
-
-
-class TestCaseCanon(PexpectTestCase.PexpectTestCase):
-    """
-    Test expected Canonical mode behavior (limited input line length).
-
-    All systems use the value of MAX_CANON which can be found using
-    fpathconf(3) value PC_MAX_CANON -- with the exception of Linux
-    and FreeBSD.
-
-    Linux, though defining a value of 255, actually honors the value
-    of 4096 from linux kernel include file tty.h definition
-    N_TTY_BUF_SIZE.
-
-    Linux also does not honor IMAXBEL. termios(3) states, "Linux does not
-    implement this bit, and acts as if it is always set." Although these
-    tests ensure it is enabled, this is a non-op for Linux.
-
-    FreeBSD supports neither, and instead uses a fraction (1/5) of the tty
-    speed which is always 9600.  Therefor, the maximum limited input line
-    length is 9600 / 5 = 1920.
-
-    These tests only ensure the correctness of the behavior described by
-    the sendline() docstring. pexpect is not particularly involved in
-    these scenarios, though if we wish to expose some kind of interface
-    to tty.setraw, for example, these tests may be re-purposed as such.
-
-    Lastly, portions of these tests are skipped on Travis-CI. It produces
-    unexpected behavior not reproduced on Debian/GNU Linux.
-    """
-
-    def setUp(self):
-        super(TestCaseCanon, self).setUp()
-
-        self.echo = False
-        if sys.platform.lower().startswith('linux'):
-            # linux is 4096, N_TTY_BUF_SIZE.
-            self.max_input = 4096
-            self.echo = True
-        elif sys.platform.lower().startswith('sunos'):
-            # SunOS allows PC_MAX_CANON + 1; see
-            # https://bitbucket.org/illumos/illumos-gate/src/d07a59219ab7fd2a7f39eb47c46cf083c88e932f/usr/src/uts/common/io/ldterm.c?at=default#cl-1888
-            self.max_input = os.fpathconf(0, 'PC_MAX_CANON') + 1
-        elif sys.platform.lower().startswith('freebsd'):
-            # http://lists.freebsd.org/pipermail/freebsd-stable/2009-October/052318.html
-            self.max_input = 9600 / 5
-        else:
-            # All others (probably) limit exactly at PC_MAX_CANON
-            self.max_input = os.fpathconf(0, 'PC_MAX_CANON')
-
-    @pytest.mark.skipif(
-        sys.platform.lower().startswith('freebsd'),
-        reason='os.write to BLOCK indefinitely on FreeBSD in this case'
-    )
-    def test_under_max_canon(self):
-        " BEL is not sent by terminal driver at maximum bytes - 1. "
-        # given,
-        child = pexpect.spawn('bash', echo=self.echo, timeout=5)
-        child.sendline('echo READY')
-        child.sendline('stty icanon imaxbel')
-        child.sendline('echo BEGIN; cat')
-
-        # some systems BEL on (maximum - 1), not able to receive CR,
-        # even though all characters up until then were received, they
-        # simply cannot be transmitted, as CR is part of the transmission.
-        send_bytes = self.max_input - 1
-
-        # exercise,
-        child.sendline('_' * send_bytes)
-
-        # fast forward beyond 'cat' command, as ^G can be found as part of
-        # set-xterm-title sequence of $PROMPT_COMMAND or $PS1.
-        child.expect_exact('BEGIN')
-
-        # verify, all input is found in echo output,
-        child.expect_exact('_' * send_bytes)
-
-        # BEL is not found,
-        with self.assertRaises(pexpect.TIMEOUT):
-            child.expect_exact('\a', timeout=1)
-
-        # cleanup,
-        child.sendeof()           # exit cat(1)
-        child.sendline('exit 0')  # exit bash(1)
-        child.expect(pexpect.EOF)
-        assert not child.isalive()
-        assert child.exitstatus == 0
-
-    @pytest.mark.skipif(
-        sys.platform.lower().startswith('freebsd'),
-        reason='os.write to BLOCK indefinitely on FreeBSD in this case'
-    )
-    def test_beyond_max_icanon(self):
-        " a single BEL is sent when maximum bytes is reached. "
-        # given,
-        child = pexpect.spawn('bash', echo=self.echo, timeout=5)
-        child.sendline('stty icanon imaxbel erase ^H')
-        child.sendline('cat')
-        send_bytes = self.max_input
-
-        # exercise,
-        child.sendline('_' * send_bytes)
-        child.expect_exact('\a')
-
-        # exercise, we must now backspace to send CR.
-        child.sendcontrol('h')
-        child.sendline()
-
-        if os.environ.get('TRAVIS', None) == 'true':
-            # Travis-CI has intermittent behavior here, possibly
-            # because the master process is itself, a PTY?
-            return
-
-        # verify the length of (maximum - 1) received by cat(1),
-        # which has written it back out,
-        child.expect_exact('_' * (send_bytes - 1))
-        # and not a byte more.
-        with self.assertRaises(pexpect.TIMEOUT):
-            child.expect_exact('_', timeout=1)
-
-        # cleanup,
-        child.sendeof()           # exit cat(1)
-        child.sendline('exit 0')  # exit bash(1)
-        child.expect_exact(pexpect.EOF)
-        assert not child.isalive()
-        assert child.exitstatus == 0
-
-    @pytest.mark.skipif(
-        sys.platform.lower().startswith('freebsd'),
-        reason='os.write to BLOCK indefinitely on FreeBSD in this case'
-    )
-    def test_max_no_icanon(self):
-        " may exceed maximum input bytes if canonical mode is disabled. "
-        # given,
-        child = pexpect.spawn('bash', echo=self.echo, timeout=5)
-        child.sendline('stty -icanon imaxbel')
-        child.sendline('echo BEGIN; cat')
-        send_bytes = self.max_input + 11
-
-        # exercise,
-        child.sendline('_' * send_bytes)
-
-        # fast forward beyond 'cat' command, as ^G can be found as part of
-        # set-xterm-title sequence of $PROMPT_COMMAND or $PS1.
-        child.expect_exact('BEGIN')
-
-        if os.environ.get('TRAVIS', None) == 'true':
-            # Travis-CI has intermittent behavior here, possibly
-            # because the master process is itself, a PTY?
-            return
-
-        # BEL is *not* found,
-        with self.assertRaises(pexpect.TIMEOUT):
-            child.expect_exact('\a', timeout=1)
-
-        # verify, all input is found in output,
-        child.expect_exact('_' * send_bytes)
-
-        # cleanup,
-        child.sendcontrol('c')    # exit cat(1) (eof wont work in -icanon)
-        child.sendcontrol('c')
-        child.sendline('exit 0')  # exit bash(1)
-        child.expect(pexpect.EOF)
-        assert not child.isalive()
-        assert child.exitstatus == 0
diff -Naur pexpect-4.0.1.orig/tools/display-fpathconf.py pexpect-4.0.1/tools/display-fpathconf.py
--- pexpect-4.0.1.orig/tools/display-fpathconf.py	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/tools/display-fpathconf.py	2015-11-05 13:29:44.437347864 +1300
@@ -0,0 +1,41 @@
+#!/usr/bin/env python
+"""Displays os.fpathconf values related to terminals. """
+from __future__ import print_function
+import sys
+import os
+
+
+def display_fpathconf():
+    DISP_VALUES = (
+        ('PC_MAX_CANON', ('Max no. of bytes in a '
+                          'terminal canonical input line.')),
+        ('PC_MAX_INPUT', ('Max no. of bytes for which '
+                          'space is available in a terminal input queue.')),
+        ('PC_PIPE_BUF', ('Max no. of bytes which will '
+                         'be written atomically to a pipe.')),
+        ('PC_VDISABLE', 'Terminal character disabling value.')
+    )
+    FMT = '{name:<13} {value:<5} {description}'
+
+    # column header
+    print(FMT.format(name='name', value='value', description='description'))
+    print(FMT.format(name=('-' * 13), value=('-' * 5), description=('-' * 11)))
+
+    fd = sys.stdin.fileno()
+    for name, description in DISP_VALUES:
+        key = os.pathconf_names.get(name, None)
+        if key is None:
+            value = 'UNDEF'
+        else:
+            try:
+                value = os.fpathconf(fd, name)
+            except OSError as err:
+                value = 'OSErrno {0.errno}'.format(err)
+        if name == 'PC_VDISABLE':
+            value = hex(value)
+        print(FMT.format(name=name, value=value, description=description))
+    print()
+
+
+if __name__ == '__main__':
+    display_fpathconf()
diff -Naur pexpect-4.0.1.orig/tools/display-maxcanon.py pexpect-4.0.1/tools/display-maxcanon.py
--- pexpect-4.0.1.orig/tools/display-maxcanon.py	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/tools/display-maxcanon.py	2015-11-05 13:29:44.437347864 +1300
@@ -0,0 +1,80 @@
+#!/usr/bin/env python
+"""
+This tool uses pexpect to test expected Canonical mode length.
+
+All systems use the value of MAX_CANON which can be found using
+fpathconf(3) value PC_MAX_CANON -- with the exception of Linux
+and FreeBSD.
+
+Linux, though defining a value of 255, actually honors the value
+of 4096 from linux kernel include file tty.h definition
+N_TTY_BUF_SIZE.
+
+Linux also does not honor IMAXBEL. termios(3) states, "Linux does not
+implement this bit, and acts as if it is always set." Although these
+tests ensure it is enabled, this is a non-op for Linux.
+
+FreeBSD supports neither, and instead uses a fraction (1/5) of the tty
+speed which is always 9600.  Therefor, the maximum limited input line
+length is 9600 / 5 = 1920.
+
+These tests only ensure the correctness of the behavior described by
+the sendline() docstring -- the values listed there, and above should
+be equal to the output of the given OS described, but no promises!
+"""
+# std import
+from __future__ import print_function
+import sys
+import os
+
+
+def detect_maxcanon():
+    import pexpect
+    bashrc = os.path.join(
+        # re-use pexpect/replwrap.py's bashrc file,
+        os.path.dirname(__file__), os.path.pardir, 'pexpect', 'bashrc.sh')
+
+    child = pexpect.spawn('bash', ['--rcfile', bashrc],
+                          echo=True, encoding='utf8', timeout=3)
+
+    child.sendline(u'echo -n READY_; echo GO')
+    child.expect_exact(u'READY_GO')
+
+    child.sendline(u'stty icanon imaxbel erase ^H; echo -n retval: $?')
+    child.expect_exact(u'retval: 0')
+
+    child.sendline(u'echo -n GO_; echo AGAIN')
+    child.expect_exact(u'GO_AGAIN')
+    child.sendline(u'cat')
+
+    child.delaybeforesend = 0
+
+    column, blocksize = 0, 64
+    ch_marker = u'_'
+
+    print('auto-detecting MAX_CANON: ', end='')
+    sys.stdout.flush()
+
+    while True:
+        child.send(ch_marker * blocksize)
+        result = child.expect([ch_marker * blocksize, u'\a'])
+        if result == 0:
+            # entire block fit without emitting bel
+            column += blocksize
+        elif result == 1:
+            # an '\a' was emitted, count the number of ch_markers
+            # found since last blocksize, determining our MAX_CANON
+            column += child.before.count(ch_marker)
+            break
+    print(column)
+
+if __name__ == '__main__':
+    try:
+        detect_maxcanon()
+    except ImportError:
+        # we'd like to use this with CI -- but until we integrate
+        # with tox, we can't determine a period in testing when
+        # the pexpect module has been installed 
+        print('warning: pexpect not in module path, MAX_CANON '
+              'could not be determined by systems test.',
+              file=sys.stderr)
diff -Naur pexpect-4.0.1.orig/tools/display-sighandlers.py pexpect-4.0.1/tools/display-sighandlers.py
--- pexpect-4.0.1.orig/tools/display-sighandlers.py	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/tools/display-sighandlers.py	2015-11-05 13:29:44.437347864 +1300
@@ -0,0 +1,24 @@
+#!/usr/bin/env python
+# Displays all signals, their values, and their handlers.
+from __future__ import print_function
+import signal
+FMT = '{name:<10} {value:<5} {description}'
+
+# header
+print(FMT.format(name='name', value='value', description='description'))
+print('-' * (33))
+
+for name, value in [(signal_name, getattr(signal, signal_name))
+                    for signal_name in dir(signal)
+                    if signal_name.startswith('SIG')
+                    and not signal_name.startswith('SIG_')]:
+    try:
+        handler = signal.getsignal(value)
+    except ValueError:
+        # FreeBSD: signal number out of range
+        handler = 'out of range'
+    description = {
+        signal.SIG_IGN: "ignored(SIG_IGN)",
+        signal.SIG_DFL: "default(SIG_DFL)"
+    }.get(handler, handler)
+    print(FMT.format(name=name, value=value, description=description))
diff -Naur pexpect-4.0.1.orig/tools/display-terminalinfo.py pexpect-4.0.1/tools/display-terminalinfo.py
--- pexpect-4.0.1.orig/tools/display-terminalinfo.py	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/tools/display-terminalinfo.py	2015-11-05 13:29:44.437347864 +1300
@@ -0,0 +1,209 @@
+#!/usr/bin/env python
+""" Display known information about our terminal. """
+from __future__ import print_function
+import termios
+import locale
+import sys
+import os
+
+BITMAP_IFLAG = {
+    'IGNBRK': 'ignore BREAK condition',
+    'BRKINT': 'map BREAK to SIGINTR',
+    'IGNPAR': 'ignore (discard) parity errors',
+    'PARMRK': 'mark parity and framing errors',
+    'INPCK': 'enable checking of parity errors',
+    'ISTRIP': 'strip 8th bit off chars',
+    'INLCR': 'map NL into CR',
+    'IGNCR': 'ignore CR',
+    'ICRNL': 'map CR to NL (ala CRMOD)',
+    'IXON': 'enable output flow control',
+    'IXOFF': 'enable input flow control',
+    'IXANY': 'any char will restart after stop',
+    'IMAXBEL': 'ring bell on input queue full',
+    'IUCLC': 'translate upper case to lower case',
+}
+
+BITMAP_OFLAG = {
+    'OPOST': 'enable following output processing',
+    'ONLCR': 'map NL to CR-NL (ala CRMOD)',
+    'OXTABS': 'expand tabs to spaces',
+    'ONOEOT': 'discard EOT\'s `^D\' on output)',
+    'OCRNL': 'map CR to NL',
+    'OLCUC': 'translate lower case to upper case',
+    'ONOCR': 'No CR output at column 0',
+    'ONLRET': 'NL performs CR function',
+}
+
+BITMAP_CFLAG = {
+    'CSIZE': 'character size mask',
+    'CS5': '5 bits (pseudo)',
+    'CS6': '6 bits',
+    'CS7': '7 bits',
+    'CS8': '8 bits',
+    'CSTOPB': 'send 2 stop bits',
+    'CREAD': 'enable receiver',
+    'PARENB': 'parity enable',
+    'PARODD': 'odd parity, else even',
+    'HUPCL': 'hang up on last close',
+    'CLOCAL': 'ignore modem status lines',
+    'CCTS_OFLOW': 'CTS flow control of output',
+    'CRTSCTS': 'same as CCTS_OFLOW',
+    'CRTS_IFLOW': 'RTS flow control of input',
+    'MDMBUF': 'flow control output via Carrier',
+}
+
+BITMAP_LFLAG = {
+    'ECHOKE': 'visual erase for line kill',
+    'ECHOE': 'visually erase chars',
+    'ECHO': 'enable echoing',
+    'ECHONL': 'echo NL even if ECHO is off',
+    'ECHOPRT': 'visual erase mode for hardcopy',
+    'ECHOCTL': 'echo control chars as ^(Char)',
+    'ISIG': 'enable signals INTR, QUIT, [D]SUSP',
+    'ICANON': 'canonicalize input lines',
+    'ALTWERASE': 'use alternate WERASE algorithm',
+    'IEXTEN': 'enable DISCARD and LNEXT',
+    'EXTPROC': 'external processing',
+    'TOSTOP': 'stop background jobs from output',
+    'FLUSHO': 'output being flushed (state)',
+    'NOKERNINFO': 'no kernel output from VSTATUS',
+    'PENDIN': 'XXX retype pending input (state)',
+    'NOFLSH': 'don\'t flush after interrupt',
+}
+
+CTLCHAR_INDEX = {
+    'VEOF': 'EOF',
+    'VEOL': 'EOL',
+    'VEOL2': 'EOL2',
+    'VERASE': 'ERASE',
+    'VWERASE': 'WERASE',
+    'VKILL': 'KILL',
+    'VREPRINT': 'REPRINT',
+    'VINTR': 'INTR',
+    'VQUIT': 'QUIT',
+    'VSUSP': 'SUSP',
+    'VDSUSP': 'DSUSP',
+    'VSTART': 'START',
+    'VSTOP': 'STOP',
+    'VLNEXT': 'LNEXT',
+    'VDISCARD': 'DISCARD',
+    'VMIN': '---',
+    'VTIME': '---',
+    'VSTATUS': 'STATUS',
+}
+
+
+def display_bitmask(kind, bitmap, value):
+    """ Display all matching bitmask values for ``value`` given ``bitmap``. """
+    col1_width = max(map(len, list(bitmap.keys()) + [kind]))
+    col2_width = 7
+    FMT = '{name:>{col1_width}} {value:>{col2_width}}   {description}'
+    print(FMT.format(name=kind,
+                     value='Value',
+                     description='Description',
+                     col1_width=col1_width,
+                     col2_width=col2_width))
+    print('{0} {1}   {2}'.format('-' * col1_width,
+                                 '-' * col2_width,
+                                 '-' * max(map(len, bitmap.values()))))
+    for flag_name, description in bitmap.items():
+        try:
+            bitmask = getattr(termios, flag_name)
+            bit_val = 'on' if bool(value & bitmask) else 'off'
+        except AttributeError:
+            bit_val = 'undef'
+        print(FMT.format(name=flag_name,
+                         value=bit_val,
+                         description=description,
+                         col1_width=col1_width,
+                         col2_width=col2_width))
+    print()
+
+
+def display_ctl_chars(index, cc):
+    """ Display all control character indicies, names, and values. """
+    title = 'Special Character'
+    col1_width = len(title)
+    col2_width = max(map(len, index.values()))
+    FMT = '{idx:<{col1_width}}   {name:<{col2_width}} {value}'
+    print('Special line Characters'.center(40).rstrip())
+    print(FMT.format(idx='Index',
+                     name='Name',
+                     value='Value',
+                     col1_width=col1_width,
+                     col2_width=col2_width))
+    print('{0}   {1} {2}'.format('-' * col1_width,
+                                 '-' * col2_width,
+                                 '-' * 10))
+    for index_name, name in index.items():
+        try:
+            index = getattr(termios, index_name)
+            value = cc[index]
+            if value == b'\xff':
+                value = '_POSIX_VDISABLE'
+            else:
+                value = repr(value)
+        except AttributeError:
+            value = 'undef'
+        print(FMT.format(idx=index_name,
+                         name=name,
+                         value=value,
+                         col1_width=col1_width,
+                         col2_width=col2_width))
+    print()
+
+
+def display_conf(kind, names, getter):
+    col1_width = max(map(len, names))
+    FMT = '{name:>{col1_width}}   {value}'
+    print(FMT.format(name=kind,
+                     value='value',
+                     col1_width=col1_width))
+    print('{0} {1}'.format('-' * col1_width, '-' * 27))
+    for name in names:
+        try:
+            value = getter(name)
+        except OSError as err:
+            value = err
+        print(FMT.format(name=name, value=value, col1_width=col1_width))
+    print()
+
+
+def main():
+    fd = sys.stdin.fileno()
+    locale.setlocale(locale.LC_ALL, '')
+    encoding = locale.getpreferredencoding()
+
+    print('os.isatty({0}) => {1}'.format(fd, os.isatty(fd)))
+    print('locale.getpreferredencoding() => {0}'.format(encoding))
+
+    display_conf(kind='pathconf',
+                 names=os.pathconf_names,
+                 getter=lambda name: os.fpathconf(fd, name))
+
+    try:
+        (iflag, oflag, cflag, lflag, ispeed, ospeed, cc
+         ) = termios.tcgetattr(fd)
+    except termios.error as err:
+        print('stdin is not a typewriter: {0}'.format(err))
+    else:
+        display_bitmask(kind='Input Mode',
+                        bitmap=BITMAP_IFLAG,
+                        value=iflag)
+        display_bitmask(kind='Output Mode',
+                        bitmap=BITMAP_OFLAG,
+                        value=oflag)
+        display_bitmask(kind='Control Mode',
+                        bitmap=BITMAP_CFLAG,
+                        value=cflag)
+        display_bitmask(kind='Local Mode',
+                        bitmap=BITMAP_LFLAG,
+                        value=lflag)
+        display_ctl_chars(index=CTLCHAR_INDEX,
+                          cc=cc)
+        print('os.ttyname({0}) => {1}'.format(fd, os.ttyname(fd)))
+        print('os.ctermid() => {0}'.format(os.ttyname(fd)))
+
+
+if __name__ == '__main__':
+    main()
diff -Naur pexpect-4.0.1.orig/tools/teamcity-coverage-report.sh pexpect-4.0.1/tools/teamcity-coverage-report.sh
--- pexpect-4.0.1.orig/tools/teamcity-coverage-report.sh	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/tools/teamcity-coverage-report.sh	2015-11-05 13:29:44.437347864 +1300
@@ -0,0 +1,27 @@
+#!/bin/bash
+# This is to be executed by each individual OS test. It only
+# combines coverage files and reports locally to the given
+# TeamCity build configuration.
+set -e
+set -o pipefail
+[ -z ${TEMP} ] && TEMP=/tmp
+
+# combine all .coverage* files,
+coverage combine
+
+# create ascii report,
+report_file=$(mktemp $TEMP/coverage.XXXXX)
+coverage report --rcfile=`dirname $0`/../.coveragerc > "${report_file}" 2>/dev/null
+
+# Report Code Coverage for TeamCity, using 'Service Messages',
+# https://confluence.jetbrains.com/display/TCD8/How+To...#HowTo...-ImportcoverageresultsinTeamCity
+# https://confluence.jetbrains.com/display/TCD8/Custom+Chart#CustomChart-DefaultStatisticsValuesProvidedbyTeamCity
+total_no_lines=$(awk '/TOTAL/{printf("%s",$2)}' < "${report_file}")
+total_no_misses=$(awk '/TOTAL/{printf("%s",$3)}' < "${report_file}")
+total_no_covered=$((${total_no_lines} - ${total_no_misses}))
+echo "##teamcity[buildStatisticValue key='CodeCoverageAbsLTotal' value='""${total_no_lines}""']"
+echo "##teamcity[buildStatisticValue key='CodeCoverageAbsLCovered' value='""${total_no_covered}""']"
+
+# Display for human consumption and remove ascii file.
+cat "${report_file}"
+rm "${report_file}"
diff -Naur pexpect-4.0.1.orig/tools/teamcity-runtests.sh pexpect-4.0.1/tools/teamcity-runtests.sh
--- pexpect-4.0.1.orig/tools/teamcity-runtests.sh	1970-01-01 12:00:00.000000000 +1200
+++ pexpect-4.0.1/tools/teamcity-runtests.sh	2015-11-05 13:29:44.437347864 +1300
@@ -0,0 +1,64 @@
+#!/bin/bash
+#
+# This script assumes that the project 'ptyprocess' is
+# available in the parent of the project's folder.
+set -e
+set -o pipefail
+
+if [ -z $1 ]; then
+	echo "$0 (2.6|2.7|3.3|3.4)"
+	exit 1
+fi
+
+export PYTHONIOENCODING=UTF8
+export LANG=en_US.UTF-8
+
+pyversion=$1
+shift
+here=$(cd `dirname $0`; pwd)
+osrel=$(uname -s)
+venv=teamcity-pexpect
+venv_wrapper=$(which virtualenvwrapper.sh)
+
+if [ -z $venv_wrapper ]; then
+	echo "virtualenvwrapper.sh not found in PATH." >&2
+	exit 1
+fi
+
+. ${venv_wrapper}
+rmvirtualenv ${venv} || true
+mkvirtualenv -p `which python${pyversion}` ${venv} || true
+workon ${venv}
+
+# install ptyprocess
+cd $here/../../ptyprocess
+pip uninstall --yes ptyprocess || true
+python setup.py install
+
+# install all test requirements
+pip install --upgrade pytest-cov coverage coveralls pytest-capturelog
+
+# run tests
+cd $here/..
+ret=0
+py.test \
+	--cov pexpect \
+	--cov-config .coveragerc \
+	--junit-xml=results.${osrel}.py${pyversion}.xml \
+	--verbose \
+	--verbose \
+	"$@" || ret=$?
+
+if [ $ret -ne 0 ]; then
+	# we always exit 0, preferring instead the jUnit XML
+	# results to be the dominate cause of a failed build.
+	echo "py.test returned exit code ${ret}." >&2
+	echo "the build should detect and report these failing tests." >&2
+fi
+
+# combine all coverage to single file, report for this build,
+# then move into ./build-output/ as a unique artifact to allow
+# the final "Full build" step to combine and report to coveralls.io
+`dirname $0`/teamcity-coverage-report.sh
+mkdir -p build-output
+mv .coverage build-output/.coverage.${osrel}.py{$pyversion}.$RANDOM.$$
