diff --git a/ginac/numeric.cpp b/ginac/numeric.cpp
index eb247a5..07a6588 100644
--- a/ginac/numeric.cpp
+++ b/ginac/numeric.cpp
@@ -166,84 +166,11 @@ inline void py_error(const char* errmsg) {
 #if PY_MAJOR_VERSION < 3
 #define PyNumber_TrueDivide PyNumber_Divide
 
-inline int Pynac_PyObj_Cmp(PyObject *optr1, PyObject *optr2, const char *errmsg) {
-        int result;
-        if (PyObject_Cmp(optr1, optr2, &result) == -1)
-                py_error(errmsg);
-        return result;
-}
-
-inline bool Pynac_PyObj_RichCmp(PyObject *optr1, PyObject *optr2, int opid, const char *errmsg) {
-        PyObject *obj1(nullptr), *obj2(nullptr);
-        if (PyComplex_CheckExact(optr1)) {
-                if (PyComplex_ImagAsDouble(optr1) != 0.0)
-                        return false;
-                obj1 = PyFloat_FromDouble(PyComplex_RealAsDouble(optr1));
-                optr1 = obj1;
-        }
-        if (PyComplex_CheckExact(optr2)) {
-                if (PyComplex_ImagAsDouble(optr2) != 0.0)
-                        return false;
-                obj2 = PyFloat_FromDouble(PyComplex_RealAsDouble(optr2));
-                optr2 = obj2;
-        }
-        int result;
-        if (PyObject_Cmp(optr1, optr2, &result) == -1)
-                py_error(errmsg);
-        if (obj1 != nullptr)
-                Py_DECREF(obj1);
-        if (obj2 != nullptr)
-                Py_DECREF(obj2);
-        switch (result) {
-                case -1: return opid == Py_LT || opid == Py_LE || opid == Py_NE;
-                case 0: return opid == Py_LE || opid == Py_EQ || opid == Py_GE;
-                case 1: return opid == Py_GT || opid == Py_GE || opid == Py_NE;
-                default: return false;
-        }
-}
 #else
 #define PyInt_Check PyLong_Check
 #define PyInt_AsLong PyLong_AsLong
 #define PyInt_FromLong PyLong_FromLong
 #define PyString_FromString PyBytes_FromString
-
-inline int Pynac_PyObj_Cmp(PyObject *optr1, PyObject *optr2, const char *errmsg) {
-        int result = PyObject_RichCompareBool(optr1, optr2, Py_LT);
-        if (result == 1)
-                return -1;
-        else if (result == -1)
-                py_error(errmsg);
-        else { // result == 0
-                result = PyObject_RichCompareBool(optr1, optr2, Py_GT);
-                if (result == -1)
-                        py_error(errmsg);
-        }
-        return result;
-}
-
-inline bool Pynac_PyObj_RichCmp(PyObject *optr1, PyObject *optr2, int opid, const char *errmsg) {
-        PyObject *obj1(nullptr), *obj2(nullptr);
-        if (PyComplex_CheckExact(optr1)) {
-                if (PyComplex_ImagAsDouble(optr1) != 0.0)
-                        return false;
-                obj1 = PyFloat_FromDouble(PyComplex_RealAsDouble(optr1));
-                optr1 = obj1;
-        }
-        if (PyComplex_CheckExact(optr2)) {
-                if (PyComplex_ImagAsDouble(optr2) != 0.0)
-                        return false;
-                obj2 = PyFloat_FromDouble(PyComplex_RealAsDouble(optr2));
-                optr2 = obj2;
-        }
-        int result = PyObject_RichCompareBool(optr1, optr2, opid);
-        if (result == -1)
-                py_error(errmsg);
-        if (obj1 != nullptr)
-                Py_DECREF(obj1);
-        if (obj2 != nullptr)
-                Py_DECREF(obj2);
-        return result;
-}
 #endif
 
 // The following variable gets changed to true once
@@ -609,7 +536,21 @@ int numeric::compare_same_type(const numeric& right) const {
                                 ret = -1;
                         return ret;
                 case PYOBJECT:
-                        return Pynac_PyObj_Cmp(v._pyobject, right.v._pyobject, "compare_same_type");
+                        {
+                        int result = PyObject_RichCompareBool(v._pyobject,
+                                        right.v._pyobject, Py_LT);
+                        if (result == 1)
+                                return -1;
+                        else if (result == -1)
+                                py_error("richcmp failed");
+                        else { // result == 0
+                                result = PyObject_RichCompareBool(v._pyobject,
+                                        right.v._pyobject, Py_GT);
+                                if (result == -1)
+                                        py_error("richcmp failed");
+                        }
+                        return result;
+                        }
                 default:
                         stub("invalid type: compare_same_type type not handled");
         }
@@ -1601,15 +1542,17 @@ int numeric::csgn() const {
                 case PYOBJECT:
                         int result;
                         if (is_real()) {
-                                result = Pynac_PyObj_Cmp(v._pyobject, ZERO, "csgn");
+                                numeric z(ZERO);
+                                Py_INCREF(ZERO);
+                                return compare_same_type(z);
                         } else {
-                                PyObject *tmp = py_funcs.py_real(v._pyobject);
-                                result = Pynac_PyObj_Cmp(tmp, ZERO, "csgn");
-                                Py_DECREF(tmp);
+                                numeric re = real();
+                                numeric z(ZERO);
+                                Py_INCREF(ZERO);
+                                result = re.compare_same_type(z);
                                 if (result == 0) {
-                                        tmp = py_funcs.py_imag(v._pyobject);
-                                        result = Pynac_PyObj_Cmp(tmp, ZERO, "csgn");
-                                        Py_DECREF(tmp);
+                                        numeric im = imag();
+                                        result = im.compare_same_type(z);
                                 }
                         }
                         return result;
@@ -1689,7 +1632,7 @@ bool numeric::is_positive() const {
                 case MPQ:
                         return mpq_cmp_si(v._bigrat, 0, 1) > 0;
                 case PYOBJECT:
-                        return is_real() and Pynac_PyObj_RichCmp(v._pyobject, ZERO, Py_GT, "is_positive");
+                        return is_real() and PyObject_RichCompareBool(v._pyobject, ZERO, Py_GT) == 1;
                 default:
                         stub("invalid type: is_positive() type not handled");
         }
@@ -1706,7 +1649,7 @@ bool numeric::is_negative() const {
                 case MPQ:
                         return mpq_cmp_si(v._bigrat, 0, 1) < 0;
                 case PYOBJECT:
-                        return is_real() and Pynac_PyObj_RichCmp(v._pyobject, ZERO, Py_LT, "is_negative");
+                        return is_real() and PyObject_RichCompareBool(v._pyobject, ZERO, Py_LT) == 1;
                 default:
                         stub("invalid type: is_negative() type not handled");
         }
@@ -1765,7 +1708,7 @@ bool numeric::is_nonneg_integer() const {
                 case MPQ:
                         return (is_integer() and (is_positive() or is_zero()));
                 case PYOBJECT:
-                        return is_integer() and Pynac_PyObj_RichCmp(v._pyobject, ZERO, Py_GE, "is_nonneg_integer");
+                        return is_integer() and PyObject_RichCompareBool(v._pyobject, ZERO, Py_GE) == 1;
                 default:
                         stub("invalid type: is_nonneg_integer() type not handled");
         }
@@ -2026,7 +1969,7 @@ bool numeric::operator<(const numeric &right) const {
                 case MPQ:
                         return mpq_cmp(v._bigrat, right.v._bigrat) < 0;
                 case PYOBJECT:
-                        return Pynac_PyObj_RichCmp(v._pyobject, right.v._pyobject, Py_LT, "<");
+                        return PyObject_RichCompareBool(v._pyobject, right.v._pyobject, Py_LT) == 1;
                 default:
                         stub("invalid type: operator< type not handled");
         }
@@ -2050,7 +1993,7 @@ bool numeric::operator<=(const numeric &right) const {
                 case MPQ:
                         return mpq_cmp(v._bigrat, right.v._bigrat) <= 0;
                 case PYOBJECT:
-                        return Pynac_PyObj_RichCmp(v._pyobject, right.v._pyobject, Py_LE, "<=");
+                        return PyObject_RichCompareBool(v._pyobject, right.v._pyobject, Py_LE) == 1;
                 default:
                         stub("invalid type: operator<= type not handled");
         }
@@ -2074,7 +2017,7 @@ bool numeric::operator>(const numeric &right) const {
                 case MPQ:
                         return mpq_cmp(v._bigrat, right.v._bigrat) > 0;
                 case PYOBJECT:
-                        return Pynac_PyObj_RichCmp(v._pyobject, right.v._pyobject, Py_GT, ">");
+                        return PyObject_RichCompareBool(v._pyobject, right.v._pyobject, Py_GT) == 1;
                 default:
                         stub("invalid type: operator> type not handled");
         }
@@ -2098,7 +2041,7 @@ bool numeric::operator>=(const numeric &right) const {
                 case MPQ:
                         return mpq_cmp(v._bigrat, right.v._bigrat) >= 0;
                 case PYOBJECT:
-                        return Pynac_PyObj_RichCmp(v._pyobject, right.v._pyobject, Py_GE, ">=");
+                        return PyObject_RichCompareBool(v._pyobject, right.v._pyobject, Py_GE) == 1;
                 default:
                         stub("invalid type: operator!= type not handled");
         }
@@ -2640,9 +2583,9 @@ const numeric numeric::Li2(const numeric &n, PyObject* parent) const {
 
         numeric rnum(ret);
         if (is_real() and n.is_integer() and rnum.real()<(*_num1_p))
-                return rnum.real();
+                return ex_to<numeric>(rnum.real().evalf(0, parent));
         else
-                return rnum;
+                return ex_to<numeric>(rnum.evalf(0, parent));
 }
 
 const numeric numeric::lgamma() const {
