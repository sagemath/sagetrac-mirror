diff -drNu src.orig/c9x-complex/cgamma.c src/c9x-complex/cgamma.c
--- src.orig/c9x-complex/cgamma.c	2010-04-06 11:46:28.000000000 +0200
+++ src/c9x-complex/cgamma.c	2013-01-08 15:07:41.335642544 +0100
@@ -258,7 +258,7 @@
 	    w = clgam(1.0 - x);
 	    c = LOGPI - clog( u ) - w;
 	    /* Adjust for reduced sine arg.  */
-	    cimag(c) += PI * p;
+	    (double)(__imag__ c = (cimag(c) + PI * p));
 	  }
 	goto ldone;
 	}
diff -drNu src.orig/c9x-complex/cgammaf.c src/c9x-complex/cgammaf.c
--- src.orig/c9x-complex/cgammaf.c	2010-04-06 11:46:28.000000000 +0200
+++ src/c9x-complex/cgammaf.c	2013-01-08 15:07:41.343641844 +0100
@@ -80,7 +80,7 @@
 Copyright 1984, 1998 Stephen L. Moshier
 */
 
-#include <complex.h>
+#include "complex.h"
 #include "mconf.h"
 
 #define MAXGAM 171.624376956302725
@@ -101,8 +101,14 @@
 static float SQTPI = 2.50662827463100050242f;
 
 extern float MAXLOGF, MAXNUMF, PIF;
-#ifndef ANSIPROT
+#ifdef ANSIPROT
+extern float sinhf ( float x );
+extern float coshf ( float x );
+extern float sinf ( float x );
+extern float cosf ( float x );
+#else
 float logf(), sinf(), polevlf(), p1evlf(), floorf(), fabsf();
+float cosf(), sinhf(), coshf();
 float complex cpowf(), cexpf(), cabsf();
 #endif
 
@@ -145,6 +151,7 @@
 {
 float p, q;
 float complex c, u;
+int k;
 
 if( fabsf(crealf(x)) > 13.0f )
 	{
@@ -152,14 +159,25 @@
 		{
 		q = crealf(x);
 		p = floorf(q);
-		if( p == q )
+		if((p == q ) && (cimag(x) == 0.0f))
 			{
 cgoverf:
 			mtherr( "cgammaf", OVERFLOW );
 			return( MAXNUMF + I * MAXNUMF);
 			}
-		c = csinf( PIF * (x - p) );
-		c = PIF/(c * cgammaf(1.0f - x) );
+		/* Compute sin(pi x)  */
+		k = q - 2.0f * floorf (0.5f * q);
+		q = PIF * (q - p);
+		p = PIF * cimag(x);
+		c = sinf(q) * coshf(p) + cosf(q) * sinhf(p) * I;
+		if (k & 1)
+		  c = -c;
+		/* Reflection formula.
+		   ??? The denominator has been observed to overflow,
+		   producing a NaN result on a SPARCstation instead of zero.
+		   Example:
+		   cgammaf(-19.425196335160404f - 18.188121066880587f*I) */
+		c = PIF/(c * cgammaf(1.0f - x));
 		}
 	else
 		{
@@ -173,8 +191,8 @@
 u = x;
 while( crealf(u) < 13.0f )
 	{
-	if (crealf(u) == 0.0f)
-	  goto cgoverf;
+	if ((crealf(u) == 0.0f) && (cimagf(u) == 0.0f))
+		goto cgoverf;
 	c *= u;
 	p += 1.0f;
 	u = x + p;
@@ -223,7 +241,7 @@
   }
 
 /* Reflection formula -z gamma(-z) gamma(z) = pi / sin(pi z)  */
-if( crealf(x) < -7.0f )
+if((crealf(x) < -7.0f) || (cimagf(x) < -7.0f))
 	{
 	q = crealf(x);
 	p = floorf(q);
@@ -247,7 +265,8 @@
 	    w = clgamf(1.0f - x);
 	    c = LOGPI - clogf( u ) - w;
 	    /* Adjust for reduced sine arg.  */
-	    cimagf(c) += PIF * p;
+	    //cimagf(c) += PIF * p;
+	    (float)(__imag__ c = (cimagf(c) + PIF * p));
 	  }
 	goto ldone;
 	}
diff -drNu src.orig/c9x-complex/cgammal.c src/c9x-complex/cgammal.c
--- src.orig/c9x-complex/cgammal.c	2010-04-06 11:46:28.000000000 +0200
+++ src/c9x-complex/cgammal.c	2013-01-08 15:07:41.351641311 +0100
@@ -134,8 +134,14 @@
 static long double SQTPIL = 2.50662827463100050241576528481104525L;
 
 extern long double MAXLOGL, MAXNUML, PIL;
-#ifndef ANSIPROT
+#ifdef ANSIPROT
+extern long double sinhl ( long double x );
+extern long double coshl ( long double x );
+extern long double sinl ( long double x );
+extern long double cosl ( long double x );
+#else
 long double logl(), sinl(), polevll(), p1evll(), floorl(), fabsl();
+long double sinhl(), coshl(), cosl();
 long double complex cpowl(), cexpl(), cabsl();
 #endif
 
@@ -174,7 +180,7 @@
 {
 long double complex c, u;
 long double p, q;
-int cj;
+int cj, k;
 
 cj = 0;
 if (cimagl(x) < 0.0L)
@@ -183,34 +189,41 @@
     x = conj(x);
   }
 
-q = creall(x);
-if( fabsl(q) > NGITER )
+if( fabsl(creall(x)) > NGITER )
 	{
-	if( q < 0.0L )
+	if( creall(x) < 0.0L )
 		{
+		q = creall(x);
 		p = floorl(q);
-		if( p == q )
+		if(( p == q ) && (cimagl(x) == 0.0L))
 			{
 			mtherr( "cgammal", OVERFLOW );
 			c = MAXNUML + I * MAXNUML;
 			goto gamdone;
 			}
-		c = csinl( PIL * (x - p) );
+		/*	c = csinl( PIL * x );*/
+		/* Compute sin(pi x)  */
+		k = q - 2.0L * floorl (0.5L * q);
+		q = PIL * (q - p);
+		p = PIL * cimagl(x);
+		c = sinl(q) * coshl(p) + cosl(q) * sinhl(p) * I;
+		if (k & 1)
+		  c = -c;
 		c = PIL/(c * cgammal(1.0L - x) );
+		goto gamdone;
 		}
 	else
 		{
-		c = cstirfl(x);
+		  c = cstirfl(x);
+		  goto gamdone;
 		}
-	goto gamdone;
 	}
-
 c = 1.0L;
 p = 0.0L;
 u = x;
 while( creall(u) < NGITER )
 	{
-	if( fabsl (creall(u)) < GSMALL )
+	if((fabsl (creall(u)) < GSMALL) && (fabsl (cimagl(u)) < GSMALL))
 		goto small;
 	c *= u;
 	p += 1.0L;
@@ -222,7 +235,7 @@
 
 
 small:
-if( creall(x) == 0.0L )
+if((creall(x) == 0.0L) && (cimagl(x) == 0.0L))
 	{
 	mtherr( "cgammal", SING );
 	c = MAXNUML + MAXNUML * I;
@@ -280,7 +293,7 @@
 
 /* -z gamma(-z) gamma(z) = pi / sin(pi z) */
 /* log gamma(z) = log pi - log sin(pi z) - log(-z) - log gamma(-z) */
-if( creall(x) < -NLGITER )
+if((creall(x) < -NLGITER) || (cimagl(x) < -NLGITER))
 	{
 	q = creall(x);
 	p = floorl(q);
@@ -304,7 +317,8 @@
 	    w = clgaml(1.0L - x);
 	    c = LOGPIL - clogl( u ) - w;
 	    /* Adjust for reduced sine arg.  */
-	    cimagl(c) += PIL * p;
+	    //cimagl(c) += PIL * p;
+	    (long double)(__imag__ c = cimagl(c) + PIL * p);
 	  }
 	goto ldone;
 	}
diff -drNu src.orig/c9x-complex/complex.h src/c9x-complex/complex.h
--- src.orig/c9x-complex/complex.h	2000-02-06 02:39:53.000000000 +0100
+++ src/c9x-complex/complex.h	2013-01-08 15:07:41.359640920 +0100
@@ -1,126 +1,131 @@
-/* This is a C9X complex.h implementation for the GNU C compiler.
-   It uses GNU extensions such as __complex__, but defines them
-   so the syntax specified by C9X works.
+/*
+** Replacement <complex.h> merging host version with cephes functions
+*/
 
-   S. L. Moshier
-   February, 1997  */
+/* Start by using host complex file.
+ * This has to come before the following protective #ifdef so that
+ * #include "complex.h" is correctly handled. */
+#include_next <complex.h>
 
+#ifndef __CEPHES_COMPLEX_H
+#define __CEPHES_COMPLEX_H
 
-/* This may look like something else, but it is really C9X.  */
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
-/* Use `I' as the imaginary unit.
-   Initialize complex constants like this:
-   double complex c = 1.0 + 2.0 * I;  */
-#define _Imaginary_I (1.0fi)
-#define I _Imaginary_I
+/* The following content is derived from
+ * http://www.opengroup.org/onlinepubs/9699919799/basedefs/complex.h.html
+ */
+extern double              (cabs)(double complex);
+extern float               (cabsf)(float complex);
+extern long double         (cabsl)(long double complex);
+extern double complex      (cacos)(double complex);
+extern float complex       (cacosf)(float complex);
+extern double complex      (cacosh)(double complex);
+extern float complex       (cacoshf)(float complex);
+extern long double complex (cacoshl)(long double complex);
+extern long double complex (cacosl)(long double complex);
+extern double complex      (cadd)(double complex a, double complex b); /*ceph*/
+extern double              (carg)(double complex);
+extern float               (cargf)(float complex);
+extern long double         (cargl)(long double complex);
+extern double complex      (casin)(double complex);
+extern float complex       (casinf)(float complex);
+extern double complex      (casinh)(double complex);
+extern float complex       (casinhf)(float complex);
+extern long double complex (casinhl)(long double complex);
+extern long double complex (casinl)(long double complex);
+extern double complex      (catan)(double complex);
+extern float complex       (catanf)(float complex);
+extern double complex      (catanh)(double complex);
+extern float complex       (catanhf)(float complex);
+extern long double complex (catanhl)(long double complex);
+extern long double complex (catanl)(long double complex);
+extern double complex      (ccos)(double complex);
+extern float complex       (ccosf)(float complex);
+extern double complex      (ccosh)(double complex);
+extern float complex       (ccoshf)(float complex);
+extern long double complex (ccoshl)(long double complex);
+extern long double complex (ccosl)(long double complex);
+extern double complex      (ccot)(double complex z);                   /*ceph*/
+extern float complex       (ccotf)(float complex z);                   /*ceph*/
+extern long double complex (ccotl)(long double complex z);             /*ceph*/
+extern double complex      (cdiv)(double complex a, double complex b); /*ceph*/
+extern double complex      (cexp)(double complex);
+extern float complex       (cexpf)(float complex);
+extern long double complex (cexpl)(long double complex);
+extern double complex      (cgamma)(double complex z);                 /*ceph*/
+extern float complex       (cgammaf)(float complex z);                 /*ceph*/
+extern long double complex (cgammal)(long double complex z);           /*ceph*/
+extern double              (cimag)(double complex);
+extern float               (cimagf)(float complex);
+extern long double         (cimagl)(long double complex);
+extern double complex 	   (clgam)(double complex z);                  /*ceph*/
+extern float complex       (clgamf)(float complex z);                  /*ceph*/
+extern long double complex (clgaml)(long double complex z);            /*ceph*/
+extern double complex      (clog)(double complex);
+extern float complex       (clogf)(float complex);
+extern long double complex (clogl)(long double complex);
+extern double complex      (cmul)(double complex a, double complex b); /*ceph*/
+extern double complex      (conj)(double complex);
+extern float complex       (conjf)(float complex);
+extern long double complex (conjl)(long double complex);
+extern double complex      (cpow)(double complex, double complex);
+extern float complex       (cpowf)(float complex, float complex);
+extern long double complex (cpowl)(long double complex, long double complex);
+extern double complex      (cproj)(double complex);
+extern float complex       (cprojf)(float complex);
+extern long double complex (cprojl)(long double complex);
+extern double              (creal)(double complex);
+extern float               (crealf)(float complex);
+extern long double         (creall)(long double complex);
+extern double complex      (csin)(double complex);
+extern float complex       (csinf)(float complex);
+extern double complex      (csinh)(double complex);
+extern float complex       (csinhf)(float complex);
+extern long double complex (csinhl)(long double complex);
+extern long double complex (csinl)(long double complex);
+extern double complex      (csqrt)(double complex);
+extern float complex       (csqrtf)(float complex);
+extern long double complex (csqrtl)(long double complex);
+extern double complex      (csub)(double complex a, double complex b); /*ceph*/
+extern double complex      (ctan)(double complex);
+extern float complex       (ctanf)(float complex);
+extern double complex      (ctanh)(double complex);
+extern float complex       (ctanhf)(float complex);
+extern long double complex (ctanhl)(long double complex);
+extern long double complex (ctanl)(long double complex);
 
+/* macro versions of some of the above functions, from the cephes complex.h */
 /* These are not typed in gcc.  They preseve the type of the argument.  */
 /* Complex conjugate function.  */
 #define conj(x) (~(x))
 /* Function to get imaginary part.  */
-#define cimag(x) (__imag__ (x))
+#define cimag(x) (__imag__(x))
 /* Function to get real part.  */
-#define creal(x) (__real__ (x))
+#define creal(x) (__real__(x))
 
-extern double atan2 (double, double);
-#define carg(z) (atan2 ((double) cimag (z), (double) creal (z)))
+extern double (atan2)(double, double);
+#define carg(z) (atan2((double)cimag(z), (double)creal(z)))
 
-/* This is the new C language key word.
-   ... Actually, the key word that the compiler is supposed to reserve
-   and understand as part of the language is spelled "_Complex" but
-   gcc understands "__complex__."  The macro "complex" is supposed to
-   exist and expand to _Complex in complex.h.  But "_Complex" will seldom
-   if ever appear in user programs.  */
-#define complex __complex__
-/* Remove this whenever gcc implements _Complex as a key word.  */
-#define _Complex __complex__
+/* There are float and long double sizes, too.  */
+#define cimagf(x) ((float)__imag__(x))
+#define crealf(x) ((float)__real__(x))
+extern float (atan2f)(float, float);
+#define cargf(z) (atan2f((float)cimag(z), (float)creal(z)))
+
+#define cimagl(x) ((long double)__imag__(x))
+#define creall(x) ((long double)__real__(x))
+extern long double (atan2l)(long double, long double);
+#define cargl(z) (atan2l((long double)cimag(z), (long double)creal(z)))
 
 /* These pragmas can't work without a compiler modification.  */
 #define CX_LIMITED_RANGE_ON
 #define CX_LIMITED_RANGE_OFF
 #define CX_LIMITED_RANGE_DEFAULT CX_LIMITED_RANGE_ON
 
-/* The builtin complex absolute value in gcc currently is unreachable
-   due to overzealous type checking.  */
-extern double cabs ( double complex z );
-extern double hypot ( double x, double y );
-
-/* Prototypes for clog.c.
-   This is how you declare complex things in the new C language.  */
-extern double complex clog ( double complex z );
-extern double complex cexp ( double complex z );
-extern double complex csqrt ( double complex z );
-extern double complex csin ( double complex z );
-extern double complex ccos ( double complex z );
-extern double complex ctan ( double complex z );
-extern double complex ccot ( double complex z );
-extern double complex casin ( double complex z );
-extern double complex cacos ( double complex z );
-extern double complex catan ( double complex z );
-extern double complex csinh ( double complex z );
-extern double complex casinh ( double complex z );
-extern double complex ccosh ( double complex z );
-extern double complex cacosh ( double complex z );
-extern double complex ctanh ( double complex z );
-extern double complex catanh ( double complex z );
-extern double complex cpow (double complex a, double complex z);
-
-/* These functions might be used if the compiler were to generate
-   subroutine calls.  But their names would be spelled some other way.  */
-extern double complex cadd ( double complex a, double complex b );
-extern double complex csub ( double complex a, double complex b );
-extern double complex cmul ( double complex a, double complex b );
-extern double complex cdiv ( double complex a, double complex b );
-
-/* There are float and long double sizes, too.  */
-#define cimagf(x) ((float) __imag__ (x))
-#define crealf(x) ((float) __real__ (x))
-extern float atan2f (float, float);
-#define cargf(z) (atan2f ((float) cimag (z), (float) creal (z)))
-extern float cabsf ( float complex z );
-extern float complex clogf ( float complex z );
-extern float complex cexpf ( float complex z );
-extern float complex csqrtf ( float complex z );
-extern float complex csinf ( float complex z );
-extern float complex ccosf ( float complex z );
-extern float complex ctanf ( float complex z );
-extern float complex ccotf ( float complex z );
-extern float complex casinf ( float complex z );
-extern float complex cacosf ( float complex z );
-extern float complex catanf ( float complex z );
-extern float complex csinhf ( float complex z );
-extern float complex casinhf ( float complex z );
-extern float complex ccoshf ( float complex z );
-extern float complex cacoshf ( float complex z );
-extern float complex ctanhf ( float complex z );
-extern float complex catanhf ( float complex z );
-extern float complex cpowf (float complex a, float complex z);
-
-#define cimagl(x) ((long double) __imag__ (x))
-#define creall(x) ((long double) __real__ (x))
-extern long double atan2l (long double, long double);
-#define cargl(z) (atan2l ((long double) cimag (z), (long double) creal (z)))
-extern long double cabsl ( long double complex z );
-extern long double complex clogl ( long double complex z );
-extern long double complex cexpl ( long double complex z );
-extern long double complex csqrtl ( long double complex z );
-extern long double complex csinl ( long double complex z );
-extern long double complex ccosl ( long double complex z );
-extern long double complex ctanl ( long double complex z );
-extern long double complex ccotl ( long double complex z );
-extern long double complex casinl ( long double complex z );
-extern long double complex cacosl ( long double complex z );
-extern long double complex catanl ( long double complex z );
-extern long double complex csinhl ( long double complex z );
-extern long double complex casinhl ( long double complex z );
-extern long double complex ccoshl ( long double complex z );
-extern long double complex cacoshl ( long double complex z );
-extern long double complex ctanhl ( long double complex z );
-extern long double complex catanhl ( long double complex z );
-extern long double complex cpowl (long double complex a, long double complex z);
-extern float complex clgamf ( float complex z );
-extern double complex clgam ( double complex z );
-extern long double complex clgaml ( long double complex z );
-extern float complex cgammaf ( float complex z );
-extern double complex cgamma ( double complex z );
-extern long double complex cgammal ( long double complex z );
+#if defined(__cplusplus)
+}
+#endif
+#endif
diff -drNu src.orig/c9x-complex/makefile src/c9x-complex/makefile
--- src.orig/c9x-complex/makefile	2010-04-06 11:46:28.000000000 +0200
+++ src/c9x-complex/makefile	2013-01-08 15:07:41.367640529 +0100
@@ -1,17 +1,25 @@
 # Makefile for C9X complex variables library
 # Edit endian-ness and computer type properly in mconf.h before compiling.
+# For additional test programs see also celefunt.mak.
 
-#CC = gcc
-CC=/b/gnu/linux/gcc/xgcc -B/b/gnu/linux/gcc/ -I/b/gnu/linux/include
+# Caution: the tests contain some references to the cephes math library
+# or references to standard float or long double functions that might
+# not be available.
+# This should be enough to run at least the double precision functions:
+LIBS = stubs.o -lm
+# These are intended to get the cephes libraries:
+#LIBS = -lml -lmd -lmf
+#LIBS = ../libml.a ../libmd.a ../libmf.a
+
+CC = gcc
+#CC = /b/gnu/gcc-build/gcc/xgcc -B/b/gnu/gcc-build/gcc/ -I/b/gnu/gcc-build/gcc
 # For 128-bit wide long double
 #PRECFLAGS = -DLD128BITS
 PRECFLAGS = 
-CFLAGS = $(PRECFLAGS) -g -O2 -Wall
-# This should be enough to run at least the double precision functions
-#LIBS = stubs.o -lm
-# These are intended to get the cephes libraries
-LIBS = -lml -lmd -lmf
-#LIBS = ../libml.a ../libmd.a ../libmf.a
+CFLAGS = $(PRECFLAGS) -I. -g -O2 -Wall
+#CFLAGS = $(PRECFLAGS) -I. -g -O1 -Wall
+#CFLAGS = $(PRECFLAGS) -I. -g -O0 -Wall
+
 # float precision
 SFILES = cmplxf.o clogf.o cgammaf.o
 # double precision
@@ -22,7 +30,7 @@
 LIBMCFILES = $(SFILES) $(DFILES) $(LFILES)
 
 # mtstf and mtstl test the float and long double functions.
-all: libmc.a mtst cvect dccalc mtstf mtstl
+all: libmc.a mtst cvect dccalc mtstf whitebxf whitebx
 
 mtst: mtst.o $(DFILES) stubs.o
 	$(CC) -v -o mtst mtst.o $(DFILES) $(LIBS)
@@ -36,8 +44,19 @@
 cvect: cvect.o clog.o cmplx.o stubs.o
 	$(CC) -o cvect cvect.o clog.o cmplx.o $(LIBS)
 
-cvect-nans: cvect-nans.o clog-nans.o cmplx-nans.o
-	$(CC) -o cvect-nans cvect-nans.o clog-nans.o cmplx-nans.o $(LIBS)
+#cvect-nans: cvect-nans.o clog-nans.o cmplx-nans.o
+#	$(CC) -o cvect-nans cvect-nans.o clog-nans.o cmplx-nans.o $(LIBS)
+
+whitebxf: whitebxf.o libmc.a
+	$(CC) $(CFLAGS) -o whitebxf whitebxf.o libmc.a $(LIBS)
+
+whitebxf.o: whitebxf.c complex.h
+
+whitebx: whitebx.o  libmc.a
+	$(CC) $(CFLAGS) -o whitebx whitebx.o libmc.a $(LIBS)
+
+whitebx.o: whitebx.c complex.h
+
 
 libmc.a: $(LIBMCFILES)
 	rm -f libmc.a
@@ -66,11 +85,13 @@
 #clog-nans.o: clog-nans.c complex.h protos.h
 #cmplx-nans.o: cmplx-nans.c complex.h protos.h
 
-check: mtst cvect mtstf
-	-mtstf
-	-cvect
-	-mtst
-	-mtstl
+check: mtst cvect mtstf whitebxf whitebx
+	-./mtstf
+	-./cvect
+	-./mtst
+	-./whitebxf
+	-./whitebx
+	echo For additional tests, make -f celefunt.mak
 
 clean:
 	rm -f *.o
@@ -93,11 +114,13 @@
 	rm -f tcsinf
 	rm -f tcsqrt
 	rm -f tcsqrtf
+	rm -f whitebxf
+	rm -f whitebx
 
-zip:
-	rm -f c9x-complex.zip
-	rm -f c9x-complex.shar
-	rm -f c9x-complex.shar.gz
-	zip c9x-complex.zip *.c *.h *.pat *.doc *.mak makefile read.me
-	shar *.c *.h *.pat *.doc *.mak makefile read.me > c9x-complex.shar
-	gzip c9x-complex.shar
+#zip:
+#	rm -f c9x-complex.zip
+#	rm -f c9x-complex.shar
+#	rm -f c9x-complex.shar.gz
+#	zip c9x-complex.zip *.c *.h *.pat *.doc *.mak makefile read.me
+#	shar *.c *.h *.pat *.doc *.mak makefile read.me > c9x-complex.shar
+#	gzip c9x-complex.shar
diff -drNu src.orig/complex.h src/complex.h
--- src.orig/complex.h	2000-02-06 02:39:53.000000000 +0100
+++ src/complex.h	2013-01-08 15:07:41.375640150 +0100
@@ -1,126 +1,131 @@
-/* This is a C9X complex.h implementation for the GNU C compiler.
-   It uses GNU extensions such as __complex__, but defines them
-   so the syntax specified by C9X works.
+/*
+** Replacement <complex.h> merging host version with cephes functions
+*/
 
-   S. L. Moshier
-   February, 1997  */
+/* Start by using host complex file.
+ * This has to come before the following protective #ifdef so that
+ * #include "complex.h" is correctly handled. */
+#include_next <complex.h>
 
+#ifndef __CEPHES_COMPLEX_H
+#define __CEPHES_COMPLEX_H
 
-/* This may look like something else, but it is really C9X.  */
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
-/* Use `I' as the imaginary unit.
-   Initialize complex constants like this:
-   double complex c = 1.0 + 2.0 * I;  */
-#define _Imaginary_I (1.0fi)
-#define I _Imaginary_I
+/* The following content is derived from
+ * http://www.opengroup.org/onlinepubs/9699919799/basedefs/complex.h.html
+ */
+extern double              (cabs)(double complex);
+extern float               (cabsf)(float complex);
+extern long double         (cabsl)(long double complex);
+extern double complex      (cacos)(double complex);
+extern float complex       (cacosf)(float complex);
+extern double complex      (cacosh)(double complex);
+extern float complex       (cacoshf)(float complex);
+extern long double complex (cacoshl)(long double complex);
+extern long double complex (cacosl)(long double complex);
+extern double complex      (cadd)(double complex a, double complex b); /*ceph*/
+extern double              (carg)(double complex);
+extern float               (cargf)(float complex);
+extern long double         (cargl)(long double complex);
+extern double complex      (casin)(double complex);
+extern float complex       (casinf)(float complex);
+extern double complex      (casinh)(double complex);
+extern float complex       (casinhf)(float complex);
+extern long double complex (casinhl)(long double complex);
+extern long double complex (casinl)(long double complex);
+extern double complex      (catan)(double complex);
+extern float complex       (catanf)(float complex);
+extern double complex      (catanh)(double complex);
+extern float complex       (catanhf)(float complex);
+extern long double complex (catanhl)(long double complex);
+extern long double complex (catanl)(long double complex);
+extern double complex      (ccos)(double complex);
+extern float complex       (ccosf)(float complex);
+extern double complex      (ccosh)(double complex);
+extern float complex       (ccoshf)(float complex);
+extern long double complex (ccoshl)(long double complex);
+extern long double complex (ccosl)(long double complex);
+extern double complex      (ccot)(double complex z);                   /*ceph*/
+extern float complex       (ccotf)(float complex z);                   /*ceph*/
+extern long double complex (ccotl)(long double complex z);             /*ceph*/
+extern double complex      (cdiv)(double complex a, double complex b); /*ceph*/
+extern double complex      (cexp)(double complex);
+extern float complex       (cexpf)(float complex);
+extern long double complex (cexpl)(long double complex);
+extern double complex      (cgamma)(double complex z);                 /*ceph*/
+extern float complex       (cgammaf)(float complex z);                 /*ceph*/
+extern long double complex (cgammal)(long double complex z);           /*ceph*/
+extern double              (cimag)(double complex);
+extern float               (cimagf)(float complex);
+extern long double         (cimagl)(long double complex);
+extern double complex 	   (clgam)(double complex z);                  /*ceph*/
+extern float complex       (clgamf)(float complex z);                  /*ceph*/
+extern long double complex (clgaml)(long double complex z);            /*ceph*/
+extern double complex      (clog)(double complex);
+extern float complex       (clogf)(float complex);
+extern long double complex (clogl)(long double complex);
+extern double complex      (cmul)(double complex a, double complex b); /*ceph*/
+extern double complex      (conj)(double complex);
+extern float complex       (conjf)(float complex);
+extern long double complex (conjl)(long double complex);
+extern double complex      (cpow)(double complex, double complex);
+extern float complex       (cpowf)(float complex, float complex);
+extern long double complex (cpowl)(long double complex, long double complex);
+extern double complex      (cproj)(double complex);
+extern float complex       (cprojf)(float complex);
+extern long double complex (cprojl)(long double complex);
+extern double              (creal)(double complex);
+extern float               (crealf)(float complex);
+extern long double         (creall)(long double complex);
+extern double complex      (csin)(double complex);
+extern float complex       (csinf)(float complex);
+extern double complex      (csinh)(double complex);
+extern float complex       (csinhf)(float complex);
+extern long double complex (csinhl)(long double complex);
+extern long double complex (csinl)(long double complex);
+extern double complex      (csqrt)(double complex);
+extern float complex       (csqrtf)(float complex);
+extern long double complex (csqrtl)(long double complex);
+extern double complex      (csub)(double complex a, double complex b); /*ceph*/
+extern double complex      (ctan)(double complex);
+extern float complex       (ctanf)(float complex);
+extern double complex      (ctanh)(double complex);
+extern float complex       (ctanhf)(float complex);
+extern long double complex (ctanhl)(long double complex);
+extern long double complex (ctanl)(long double complex);
 
+/* macro versions of some of the above functions, from the cephes complex.h */
 /* These are not typed in gcc.  They preseve the type of the argument.  */
 /* Complex conjugate function.  */
 #define conj(x) (~(x))
 /* Function to get imaginary part.  */
-#define cimag(x) (__imag__ (x))
+#define cimag(x) (__imag__(x))
 /* Function to get real part.  */
-#define creal(x) (__real__ (x))
+#define creal(x) (__real__(x))
 
-extern double atan2 (double, double);
-#define carg(z) (atan2 ((double) cimag (z), (double) creal (z)))
+extern double (atan2)(double, double);
+#define carg(z) (atan2((double)cimag(z), (double)creal(z)))
 
-/* This is the new C language key word.
-   ... Actually, the key word that the compiler is supposed to reserve
-   and understand as part of the language is spelled "_Complex" but
-   gcc understands "__complex__."  The macro "complex" is supposed to
-   exist and expand to _Complex in complex.h.  But "_Complex" will seldom
-   if ever appear in user programs.  */
-#define complex __complex__
-/* Remove this whenever gcc implements _Complex as a key word.  */
-#define _Complex __complex__
+/* There are float and long double sizes, too.  */
+#define cimagf(x) ((float)__imag__(x))
+#define crealf(x) ((float)__real__(x))
+extern float (atan2f)(float, float);
+#define cargf(z) (atan2f((float)cimag(z), (float)creal(z)))
+
+#define cimagl(x) ((long double)__imag__(x))
+#define creall(x) ((long double)__real__(x))
+extern long double (atan2l)(long double, long double);
+#define cargl(z) (atan2l((long double)cimag(z), (long double)creal(z)))
 
 /* These pragmas can't work without a compiler modification.  */
 #define CX_LIMITED_RANGE_ON
 #define CX_LIMITED_RANGE_OFF
 #define CX_LIMITED_RANGE_DEFAULT CX_LIMITED_RANGE_ON
 
-/* The builtin complex absolute value in gcc currently is unreachable
-   due to overzealous type checking.  */
-extern double cabs ( double complex z );
-extern double hypot ( double x, double y );
-
-/* Prototypes for clog.c.
-   This is how you declare complex things in the new C language.  */
-extern double complex clog ( double complex z );
-extern double complex cexp ( double complex z );
-extern double complex csqrt ( double complex z );
-extern double complex csin ( double complex z );
-extern double complex ccos ( double complex z );
-extern double complex ctan ( double complex z );
-extern double complex ccot ( double complex z );
-extern double complex casin ( double complex z );
-extern double complex cacos ( double complex z );
-extern double complex catan ( double complex z );
-extern double complex csinh ( double complex z );
-extern double complex casinh ( double complex z );
-extern double complex ccosh ( double complex z );
-extern double complex cacosh ( double complex z );
-extern double complex ctanh ( double complex z );
-extern double complex catanh ( double complex z );
-extern double complex cpow (double complex a, double complex z);
-
-/* These functions might be used if the compiler were to generate
-   subroutine calls.  But their names would be spelled some other way.  */
-extern double complex cadd ( double complex a, double complex b );
-extern double complex csub ( double complex a, double complex b );
-extern double complex cmul ( double complex a, double complex b );
-extern double complex cdiv ( double complex a, double complex b );
-
-/* There are float and long double sizes, too.  */
-#define cimagf(x) ((float) __imag__ (x))
-#define crealf(x) ((float) __real__ (x))
-extern float atan2f (float, float);
-#define cargf(z) (atan2f ((float) cimag (z), (float) creal (z)))
-extern float cabsf ( float complex z );
-extern float complex clogf ( float complex z );
-extern float complex cexpf ( float complex z );
-extern float complex csqrtf ( float complex z );
-extern float complex csinf ( float complex z );
-extern float complex ccosf ( float complex z );
-extern float complex ctanf ( float complex z );
-extern float complex ccotf ( float complex z );
-extern float complex casinf ( float complex z );
-extern float complex cacosf ( float complex z );
-extern float complex catanf ( float complex z );
-extern float complex csinhf ( float complex z );
-extern float complex casinhf ( float complex z );
-extern float complex ccoshf ( float complex z );
-extern float complex cacoshf ( float complex z );
-extern float complex ctanhf ( float complex z );
-extern float complex catanhf ( float complex z );
-extern float complex cpowf (float complex a, float complex z);
-
-#define cimagl(x) ((long double) __imag__ (x))
-#define creall(x) ((long double) __real__ (x))
-extern long double atan2l (long double, long double);
-#define cargl(z) (atan2l ((long double) cimag (z), (long double) creal (z)))
-extern long double cabsl ( long double complex z );
-extern long double complex clogl ( long double complex z );
-extern long double complex cexpl ( long double complex z );
-extern long double complex csqrtl ( long double complex z );
-extern long double complex csinl ( long double complex z );
-extern long double complex ccosl ( long double complex z );
-extern long double complex ctanl ( long double complex z );
-extern long double complex ccotl ( long double complex z );
-extern long double complex casinl ( long double complex z );
-extern long double complex cacosl ( long double complex z );
-extern long double complex catanl ( long double complex z );
-extern long double complex csinhl ( long double complex z );
-extern long double complex casinhl ( long double complex z );
-extern long double complex ccoshl ( long double complex z );
-extern long double complex cacoshl ( long double complex z );
-extern long double complex ctanhl ( long double complex z );
-extern long double complex catanhl ( long double complex z );
-extern long double complex cpowl (long double complex a, long double complex z);
-extern float complex clgamf ( float complex z );
-extern double complex clgam ( double complex z );
-extern long double complex clgaml ( long double complex z );
-extern float complex cgammaf ( float complex z );
-extern double complex cgamma ( double complex z );
-extern long double complex cgammal ( long double complex z );
+#if defined(__cplusplus)
+}
+#endif
+#endif
diff -drNu src.orig/double/makefile src/double/makefile
--- src.orig/double/makefile	2010-04-06 11:46:28.000000000 +0200
+++ src/double/makefile	2013-01-08 15:07:41.383639902 +0100
@@ -22,7 +22,13 @@
 tan.o tandg.o tanh.o unity.o yn.o zeta.o zetac.o \
 sqrt.o floor.o setprec.o mtherr.o
 
-all: libmd.a mtst dtestvec monot dcalc paranoia # stamp-timing
+all: libmd.a mtst dtestvec monot dcalc # stamp-timing
+
+check:  mtst dtestvec monot dcalc
+	./mtst
+	./dtestvec
+	./monot
+	./dcalc
 
 stamp-timing: libmd.a mtst time-it
 	time-it "mtst > /dev/null"
@@ -86,14 +92,14 @@
 #	$(AS) -o setprec.o setprec.387
 
 # ELF versions for linux (no underscores)
-sqrt.o: sqrtelf.387
-	$(AS) -o sqrt.o sqrtelf.387
+#sqrt.o: sqrtelf.387
+#	$(AS) -o sqrt.o sqrtelf.387
 
 #floor.o: floorelf.387
 #	$(AS) -o floor.o floorelf.387
 
-setprec.o: setprelf.387
-	$(AS) -o setprec.o setprelf.387
+#setprec.o: setprelf.387
+#	$(AS) -o setprec.o setprelf.387
 
 # Motorola 68881. Caution, subroutine return conventions vary.
 #sqrt.o: sqrt.688
diff -drNu src.orig/ldouble/gammal.c src/ldouble/gammal.c
--- src.orig/ldouble/gammal.c	2000-05-28 17:21:01.000000000 +0200
+++ src/ldouble/gammal.c	2013-01-08 15:07:41.391639726 +0100
@@ -6,20 +6,16 @@
  *
  * SYNOPSIS:
  *
- * long double x, y, gammal();
- * extern int sgngam;
+ * long double x, y, tgammal();
  *
- * y = gammal( x );
+ * y = tgammal( x );
  *
  *
  *
  * DESCRIPTION:
  *
  * Returns gamma function of the argument.  The result is
- * correctly signed, and the sign (+1 or -1) is also
- * returned in a global (extern) variable named sgngam.
- * This variable is also filled in by the logarithmic gamma
- * function lgam().
+ * correctly signed.
  *
  * Arguments |x| <= 13 are reduced by recurrence and the function
  * approximated by a rational function of degree 7/8 in the
@@ -38,7 +34,7 @@
  * Accuracy for large arguments is dominated by error in powl().
  *
  */
-/*							lgaml()
+/*							lgammal()
  *
  *	Natural logarithm of gamma function
  *
@@ -46,10 +42,10 @@
  *
  * SYNOPSIS:
  *
- * long double x, y, lgaml();
- * extern int sgngam;
+ * long double x, y, lgammal();
+ * extern int signgam;
  *
- * y = lgaml( x );
+ * y = lgammal( x );
  *
  *
  *
@@ -58,7 +54,7 @@
  * Returns the base e (2.718...) logarithm of the absolute
  * value of the gamma function of the argument.
  * The sign (+1 or -1) of the gamma function is returned in a
- * global (extern) variable named sgngam.
+ * global (extern) variable named signgam.
  *
  * For arguments greater than 33, the logarithm of the gamma
  * function is approximated by the logarithmic version of
@@ -90,7 +86,6 @@
 Copyright 1994 by Stephen L. Moshier
 */
 
-
 #include "mconf.h"
 /*
 gamma(x+2)  = gamma(x+2) P(x)/Q(x)
@@ -336,18 +331,18 @@
 };
 #endif
 
-int sgngaml = 0;
-extern int sgngaml;
+/*int signgam = 0;*/
+extern int signgam;
 extern long double MAXLOGL, MAXNUML, PIL;
 /* #define PIL 3.14159265358979323846L */
 /* #define MAXNUML 1.189731495357231765021263853E4932L */
 
 #ifdef ANSIPROT
 extern long double fabsl ( long double );
-extern long double lgaml ( long double );
+extern long double lgammal ( long double );
 extern long double logl ( long double );
 extern long double expl ( long double );
-extern long double gammal ( long double );
+extern long double tgammal ( long double );
 extern long double sinl ( long double );
 extern long double floorl ( long double );
 extern long double powl ( long double, long double );
@@ -357,7 +352,7 @@
 extern int isfinitel ( long double );
 static long double stirf ( long double );
 #else
-long double fabsl(), lgaml(), logl(), expl(), gammal(), sinl();
+long double fabsl(), lgammal(), logl(), expl(), tgammal(), sinl();
 long double floorl(), powl(), polevll(), p1evll(), isnanl(), isfinitel();
 static long double stirf();
 #endif
@@ -403,13 +398,13 @@
 
 
 
-long double gammal(x)
+long double tgammal(x)
 long double x;
 {
 long double p, q, z;
 int i;
+int signgam = 1;
 
-sgngaml = 1;
 #ifdef NANS
 if( isnanl(x) )
 	return(NANL);
@@ -435,7 +430,7 @@
 			{
 gamnan:
 #ifdef NANS
-			mtherr( "gammal", DOMAIN );
+			mtherr( "tgammal", DOMAIN );
 			return (NANL);
 #else
 			goto goverf;
@@ -443,7 +438,7 @@
 			}
 		i = p;
 		if( (i & 1) == 0 )
-			sgngaml = -1;
+			signgam = -1;
 		z = q - p;
 		if( z > 0.5L )
 			{
@@ -456,10 +451,10 @@
 			{
 goverf:
 #ifdef INFINITIES
-			return( sgngaml * INFINITYL);
+			return( signgam * INFINITYL);
 #else
-			mtherr( "gammal", OVERFLOW );
-			return( sgngaml * MAXNUML);
+			mtherr( "tgammal", OVERFLOW );
+			return( signgam * MAXNUML);
 #endif
 			}
 		z = PIL/z;
@@ -468,7 +463,7 @@
 		{
 		z = stirf(x);
 		}
-	return( sgngaml * z );
+	return( signgam * z );
 	}
 
 z = 1.0L;
@@ -642,13 +637,13 @@
 /* Logarithm of gamma function */
 
 
-long double lgaml(x)
+long double lgammal(x)
 long double x;
 {
 long double p, q, w, z, f, nx;
 int i;
 
-sgngaml = 1;
+signgam = 1;
 #ifdef NANS
 if( isnanl(x) )
 	return(NANL);
@@ -660,12 +655,12 @@
 if( x < -34.0L )
 	{
 	q = -x;
-	w = lgaml(q); /* note this modifies sgngam! */
+	w = lgammal(q); /* note this modifies signgam! */
 	p = floorl(q);
 	if( p == q )
 		{
 #ifdef INFINITIES
-		mtherr( "lgaml", SING );
+		mtherr( "lgammal", SING );
 		return (INFINITYL);
 #else
 		goto loverf;
@@ -673,9 +668,9 @@
 		}
 	i = p;
 	if( (i & 1) == 0 )
-		sgngaml = -1;
+		signgam = -1;
 	else
-		sgngaml = 1;
+		signgam = 1;
 	z = q - p;
 	if( z > 0.5L )
 		{
@@ -711,11 +706,11 @@
 		}
 	if( z < 0.0L )
 		{
-		sgngaml = -1;
+		signgam = -1;
 		z = -z;
 		}
 	else
-		sgngaml = 1;
+		signgam = 1;
 	if( x == 2.0L )
 		return( logl(z) );
 	x = (nx - 2.0L) + f;
@@ -727,10 +722,10 @@
 	{
 loverf:
 #ifdef INFINITIES
-	return( sgngaml * INFINITYL );
+	return( signgam * INFINITYL );
 #else
-	mtherr( "lgaml", OVERFLOW );
-	return( sgngaml * MAXNUML );
+	mtherr( "lgammal", OVERFLOW );
+	return( signgam * MAXNUML );
 #endif
 	}
 
@@ -754,11 +749,11 @@
 	q = z / (x * polevll( x, S, 8 ));
 if( q < 0.0L )
 	{
-	sgngaml = -1;
+	signgam = -1;
 	q = -q;
 	}
 else
-	sgngaml = 1;
+	signgam = 1;
 q = logl( q );
 return(q);
 }
diff -drNu src.orig/ldouble/makefile src/ldouble/makefile
--- src.orig/ldouble/makefile	2010-04-06 11:46:28.000000000 +0200
+++ src/ldouble/makefile	2013-01-08 15:07:41.399639696 +0100
@@ -12,11 +12,11 @@
 exp10l.o exp2l.o expl.o fdtrl.o gammal.o gdtrl.o igamil.o igaml.o \
 incbetl.o incbil.o isnanl.o j0l.o j1l.o jnl.o ldrand.o log10l.o log2l.o \
 logl.o nbdtrl.o ndtril.o ndtrl.o pdtrl.o powl.o powil.o sinhl.o sinl.o \
-sqrtl.o stdtrl.o tanhl.o tanl.o unityl.o ynl.o \
+sqrtl.o stdtrl.o tanhl.o tanl.o ynl.o \
 floorl.o polevll.o unityl.o mtherr.o
 # cmplxl.o clogl.o
 
-all: mtstl lparanoi lcalc fltestl nantst testvect monotl libml.a
+all: mtstl lcalc fltestl nantst testvect monotl libml.a
 
 mtstl: libml.a mtstl.o $(OBJS)
 	$(CC) $(CFLAGS) -o mtstl mtstl.o libml.a $(LIBS)
@@ -59,10 +59,10 @@
 # ELF versions for linux
 #floorl.o: floorlelf.387
 #	as -o floorl.o floorlelf.387
-sqrtl.o: sqrtlelf.387
-	as -o sqrtl.o sqrtlelf.387
-setprec.o: setprelf.387
-	as -o setprec.o setprelf.387
+#sqrtl.o: sqrtlelf.387
+#	as -o sqrtl.o sqrtlelf.387
+#setprec.o: setprelf.387
+#	as -o setprec.o setprelf.387
 
 # 68K routines
 # For Sun 3
diff -drNu src.orig/Makefile src/Makefile
--- src.orig/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ src/Makefile	2013-01-08 15:08:01.743638992 +0100
@@ -0,0 +1,68 @@
+# FreeBSD makefile for cephes.
+
+# Build tools
+CC ?= gcc
+LD ?= ld
+CP ?= cp
+INSTALL ?= install
+
+# Intermediate (ar) libraries
+LIBS=c9x-complex/libmc.a double/libmd.a ldouble/libml.a single/libmf.a
+
+all: libm.so
+
+install: libm.so complex.h math.h
+	${INSTALL} -C -m 644 complex.h math.h "${SAGE_LOCAL}/include"
+	${INSTALL} -C -m 755 libm.so "${SAGE_LOCAL}/lib"
+
+check:
+	cd c9x-complex && ${MAKE} "CC=${CC}" check
+	cd double && ${MAKE} "CC=${CC}" check
+	cd ldouble && ${MAKE} "CC=${CC}" check
+	cd single && ${MAKE} "CC=${CC}" check
+#	cd c9x-complex && ${MAKE} "LIBS=-L.. -rpath .. -lm" "CC=${CC}" check
+#	cd double && ${MAKE} "LIBS=-L.. -rpath .. -lm" "CC=${CC}" check
+#	cd ldouble && ${MAKE} "LIBS=-L.. -rpath .. -lm" "CC=${CC}" check
+#	cd single && ${MAKE} "LIBS=-L.. -rpath .. -lm" "CC=${CC}" check
+#	TBD
+
+clean:
+	rm -f libm.so syms.c99 syms.libm syms.wanted
+	cd c9x-complex && ${MAKE} clean
+	cd double && ${MAKE} clean
+	cd ldouble && ${MAKE} clean
+	cd single && ${MAKE} clean
+
+# FreeBSD includes some but not all of the C99 maths functions.  Build
+# a "new" libm.so that uses cephes functions to replace the missing ones
+# (listed in syms.wanted) and then fallback to the base libm.so
+libm.so: ${LIBS} syms.wanted
+	${LD} -shared -o $@ $$(sed 's/^/-u /' syms.wanted) -L/usr/lib -lc -lm \
+	   ${LIBS} -lgcc
+
+# List of symbols defined in the FreeBSD base libc.so and libm.so
+# libc.so is included because some math-related functions are in libc.so
+syms.libm: /usr/lib/libc.so /usr/lib/libm.so
+	nm -Dgp $^ | sed 's/^.* //' | sort -uo $@
+
+# List of symbols defined in C99 math.h and complex.h
+# Doing it this way saves having to maintain a second list
+syms.c99: math.h complex.h
+	sed -ne 's/)(.*//' -e '/^extern/s/^.* (//p' $^ | sort -uo $@
+
+# List of symbols in C99 not defined in FreeBSD
+syms.wanted: syms.libm syms.c99
+	comm -23 syms.c99 syms.libm > $@
+
+# Force compilation in PIC mode to allow creation of a shared library
+c9x-complex/libmc.a: c9x-complex/complex.h
+	cd c9x-complex && ${MAKE} "CC=${CC} -DPIC -fpic" libmc.a
+
+double/libmd.a:
+	cd double && ${MAKE} "CC=${CC} -DPIC -fpic" libmd.a
+
+ldouble/libml.a:
+	cd ldouble && ${MAKE} "CC=${CC} -DPIC -fpic" libml.a
+
+single/libmf.a:
+	cd single && ${MAKE} "CC=${CC} -DPIC -fpic" libmf.a
diff -drNu src.orig/math.h src/math.h
--- src.orig/math.h	1970-01-01 01:00:00.000000000 +0100
+++ src/math.h	2013-01-08 15:07:41.407639759 +0100
@@ -0,0 +1,201 @@
+/*
+** Replacement <math.h> merging host version with cephes functions
+*/
+
+/* Start by using host math file.
+ * This has to come before the following protective #ifdef so that
+ * #include "math.h" is correctly handled. */
+#include_next <math.h>
+
+#ifndef __CEPHES_MATH_H
+#define __CEPHES_MATH_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* The following content is derived from
+ * http://www.opengroup.org/onlinepubs/9699919799/basedefs/math.h.html
+ */
+extern double      (acos)(double);
+extern float       (acosf)(float);
+extern double      (acosh)(double);
+extern float       (acoshf)(float);
+extern long double (acoshl)(long double);
+extern long double (acosl)(long double);
+extern double      (asin)(double);
+extern float       (asinf)(float);
+extern double      (asinh)(double);
+extern float       (asinhf)(float);
+extern long double (asinhl)(long double);
+extern long double (asinl)(long double);
+extern double      (atan)(double);
+extern double      (atan2)(double, double);
+extern float       (atan2f)(float, float);
+extern long double (atan2l)(long double, long double);
+extern float       (atanf)(float);
+extern double      (atanh)(double);
+extern float       (atanhf)(float);
+extern long double (atanhl)(long double);
+extern long double (atanl)(long double);
+extern double      (cbrt)(double);
+extern float       (cbrtf)(float);
+extern long double (cbrtl)(long double);
+extern double      (ceil)(double);
+extern float       (ceilf)(float);
+extern long double (ceill)(long double);
+extern double      (copysign)(double, double);
+extern float       (copysignf)(float, float);
+extern long double (copysignl)(long double, long double);
+extern double      (cos)(double);
+extern float       (cosf)(float);
+extern double      (cosh)(double);
+extern float       (coshf)(float);
+extern long double (coshl)(long double);
+extern long double (cosl)(long double);
+extern double      (erf)(double);
+extern double      (erfc)(double);
+extern float       (erfcf)(float);
+extern long double (erfcl)(long double);
+extern float       (erff)(float);
+extern long double (erfl)(long double);
+extern double      (exp)(double);
+extern double      (exp2)(double);
+extern float       (exp2f)(float);
+extern long double (exp2l)(long double);
+extern float       (expf)(float);
+extern long double (expl)(long double);
+extern double      (expm1)(double);
+extern float       (expm1f)(float);
+extern long double (expm1l)(long double);
+extern double      (fabs)(double);
+extern float       (fabsf)(float);
+extern long double (fabsl)(long double);
+extern double      (fdim)(double, double);
+extern float       (fdimf)(float, float);
+extern long double (fdiml)(long double, long double);
+extern double      (floor)(double);
+extern float       (floorf)(float);
+extern long double (floorl)(long double);
+extern double      (fma)(double, double, double);
+extern float       (fmaf)(float, float, float);
+extern long double (fmal)(long double, long double, long double);
+extern double      (fmax)(double, double);
+extern float       (fmaxf)(float, float);
+extern long double (fmaxl)(long double, long double);
+extern double      (fmin)(double, double);
+extern float       (fminf)(float, float);
+extern long double (fminl)(long double, long double);
+extern double      (fmod)(double, double);
+extern float       (fmodf)(float, float);
+extern long double (fmodl)(long double, long double);
+extern double      (frexp)(double, int *);
+extern float       (frexpf)(float, int *);
+extern long double (frexpl)(long double, int *);
+extern double      (hypot)(double, double);
+extern float       (hypotf)(float, float);
+extern long double (hypotl)(long double, long double);
+extern int         (ilogb)(double);
+extern int         (ilogbf)(float);
+extern int         (ilogbl)(long double);
+extern double      (j0)(double);		/* XSI extension */
+extern double      (j1)(double);		/* XSI extension */
+extern double      (jn)(int, double);		/* XSI extension */
+extern double      (ldexp)(double, int);
+extern float       (ldexpf)(float, int);
+extern long double (ldexpl)(long double, int);
+extern double      (lgamma)(double);
+extern float       (lgammaf)(float);
+extern long double (lgammal)(long double);
+extern long long   (llrint)(double);
+extern long long   (llrintf)(float);
+extern long long   (llrintl)(long double);
+extern long long   (llround)(double);
+extern long long   (llroundf)(float);
+extern long long   (llroundl)(long double);
+extern double      (log)(double);
+extern double      (log10)(double);
+extern float       (log10f)(float);
+extern long double (log10l)(long double);
+extern double      (log1p)(double);
+extern float       (log1pf)(float);
+extern long double (log1pl)(long double);
+extern double      (log2)(double);
+extern float       (log2f)(float);
+extern long double (log2l)(long double);
+extern double      (logb)(double);
+extern float       (logbf)(float);
+extern long double (logbl)(long double);
+extern float       (logf)(float);
+extern long double (logl)(long double);
+extern long        (lrint)(double);
+extern long        (lrintf)(float);
+extern long        (lrintl)(long double);
+extern long        (lround)(double);
+extern long        (lroundf)(float);
+extern long        (lroundl)(long double);
+extern double      (modf)(double, double *);
+extern float       (modff)(float, float *);
+extern long double (modfl)(long double, long double *);
+extern double      (nan)(const char *);
+extern float       (nanf)(const char *);
+extern long double (nanl)(const char *);
+extern double      (nearbyint)(double);
+extern float       (nearbyintf)(float);
+extern long double (nearbyintl)(long double);
+extern double      (nextafter)(double, double);
+extern float       (nextafterf)(float, float);
+extern long double (nextafterl)(long double, long double);
+extern double      (nexttoward)(double, long double);
+extern float       (nexttowardf)(float, long double);
+extern long double (nexttowardl)(long double, long double);
+extern double      (pow)(double, double);
+extern float       (powf)(float, float);
+extern long double (powl)(long double, long double);
+extern double      (remainder)(double, double);
+extern float       (remainderf)(float, float);
+extern long double (remainderl)(long double, long double);
+extern double      (remquo)(double, double, int *);
+extern float       (remquof)(float, float, int *);
+extern long double (remquol)(long double, long double, int *);
+extern double      (rint)(double);
+extern float       (rintf)(float);
+extern long double (rintl)(long double);
+extern double      (round)(double);
+extern float       (roundf)(float);
+extern long double (roundl)(long double);
+extern double      (scalbln)(double, long);
+extern float       (scalblnf)(float, long);
+extern long double (scalblnl)(long double, long);
+extern double      (scalbn)(double, int);
+extern float       (scalbnf)(float, int);
+extern long double (scalbnl)(long double, int);
+extern double      (sin)(double);
+extern float       (sinf)(float);
+extern double      (sinh)(double);
+extern float       (sinhf)(float);
+extern long double (sinhl)(long double);
+extern long double (sinl)(long double);
+extern double      (sqrt)(double);
+extern float       (sqrtf)(float);
+extern long double (sqrtl)(long double);
+extern double      (tan)(double);
+extern float       (tanf)(float);
+extern double      (tanh)(double);
+extern float       (tanhf)(float);
+extern long double (tanhl)(long double);
+extern long double (tanl)(long double);
+extern double      (tgamma)(double);
+extern float       (tgammaf)(float);
+extern long double (tgammal)(long double);
+extern double      (trunc)(double);
+extern float       (truncf)(float);
+extern long double (truncl)(long double);
+extern double      (y0)(double);		/* XSI extension */
+extern double      (y1)(double);		/* XSI extension */
+extern double      (yn)(int, double);	/* XSI extension */
+
+#if defined(__cplusplus)
+}
+#endif
+#endif
