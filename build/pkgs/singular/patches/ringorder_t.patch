From 90f715a0b0b2d389f393a20365b7afde7cb4b18c Mon Sep 17 00:00:00 2001
From: Hans Schoenemann <hannes@mathematik.uni-kl.de>
Date: Tue, 13 Dec 2016 10:01:44 +0100
Subject: [PATCH] change: use rRingOrder_t instead of int

---
 Singular/dyn_modules/gfanlib/containsMonomial.cc |  8 ++-
 Singular/dyn_modules/gfanlib/flip.cc             |  4 +-
 Singular/dyn_modules/gfanlib/startingCone.cc     |  6 ++-
 Singular/dyn_modules/gfanlib/tropicalCurves.cc   |  2 +-
 Singular/dyn_modules/gfanlib/tropicalStrategy.cc | 14 ++---
 Singular/ipshell.cc                              | 16 +++---
 Singular/links/ssiLink.cc                        |  4 +-
 Singular/walk.cc                                 | 56 +++++++++++++++-----
 kernel/GBEngine/kutil.cc                         |  8 +--
 kernel/ideals.cc                                 | 11 ++--
 libpolys/polys/monomials/ring.cc                 | 66 ++++++++++++------------
 libpolys/polys/monomials/ring.h                  |  8 +--
 libpolys/polys/sparsmat.cc                       |  2 +-
 13 files changed, 121 insertions(+), 84 deletions(-)

diff --git a/Singular/dyn_modules/gfanlib/containsMonomial.cc b/Singular/dyn_modules/gfanlib/containsMonomial.cc
index f751066..a321407 100644
--- a/Singular/dyn_modules/gfanlib/containsMonomial.cc
+++ b/Singular/dyn_modules/gfanlib/containsMonomial.cc
@@ -64,7 +64,7 @@ poly searchForMonomialViaStepwiseSaturation(const ideal I, const ring r, const g
   // set ordering to be wp(w)
   int n = rVar(r);
   ring rGraded = rCopy0(r,TRUE,FALSE);
-  rGraded->order = (int*) omAlloc0(3*sizeof(int));
+  rGraded->order = (rRingOrder_t*) omAlloc0(3*sizeof(rRingOrder_t));
   rGraded->block0 = (int*) omAlloc0(3*sizeof(int));
   rGraded->block1 = (int*) omAlloc0(3*sizeof(int));
   rGraded->wvhdl = (int**) omAlloc0(3*sizeof(int**));
@@ -143,9 +143,13 @@ poly searchForMonomialViaStepwiseSaturation(const ideal I, const ring r, const g
     w[0] = cache;
 
     ring rGradedNew = rCopy0(r,TRUE,FALSE);
-    rGradedNew->order = (int*) omAlloc0(3*sizeof(int));
+    omFree(rGradedNew->order);
+    rGradedNew->order = (rRingOrder_t*) omAlloc0(3*sizeof(rRingOrder_t));
+    omFree(rGradedNew->block0);
     rGradedNew->block0 = (int*) omAlloc0(3*sizeof(int));
+    omFree(rGradedNew->block1);
     rGradedNew->block1 = (int*) omAlloc0(3*sizeof(int));
+    omFree(rGradedNew->wvhdl);
     rGradedNew->wvhdl = (int**) omAlloc0(3*sizeof(int**));
     rGradedNew->order[0] = ringorder_wp;
     rGradedNew->block0[0] = 1;
diff --git a/Singular/dyn_modules/gfanlib/flip.cc b/Singular/dyn_modules/gfanlib/flip.cc
index bf9dc2e..e4935c2 100644
--- a/Singular/dyn_modules/gfanlib/flip.cc
+++ b/Singular/dyn_modules/gfanlib/flip.cc
@@ -26,7 +26,7 @@ std::pair<ideal,ring> flip(const ideal I, const ring r,
   ring sAdjusted = rCopy0(r);
   int n = rVar(sAdjusted);
   deleteOrdering(sAdjusted);
-  sAdjusted->order = (int*) omAlloc0(5*sizeof(int));
+  sAdjusted->order = (rRingOrder_t*) omAlloc0(5*sizeof(rRingOrder_t));
   sAdjusted->block0 = (int*) omAlloc0(5*sizeof(int));
   sAdjusted->block1 = (int*) omAlloc0(5*sizeof(int));
   sAdjusted->wvhdl = (int**) omAlloc0(5*sizeof(int**));
@@ -71,7 +71,7 @@ std::pair<ideal,ring> flip(const ideal I, const ring r,
   ring s = rCopy0(r);
   n = rVar(s);
   deleteOrdering(s);
-  s->order = (int*) omAlloc0(5*sizeof(int));
+  s->order = (rRingOrder_t*) omAlloc0(5*sizeof(rRingOrder_t));
   s->block0 = (int*) omAlloc0(5*sizeof(int));
   s->block1 = (int*) omAlloc0(5*sizeof(int));
   s->wvhdl = (int**) omAlloc0(5*sizeof(int**));
diff --git a/Singular/dyn_modules/gfanlib/startingCone.cc b/Singular/dyn_modules/gfanlib/startingCone.cc
index 59201e5..76d11c0 100644
--- a/Singular/dyn_modules/gfanlib/startingCone.cc
+++ b/Singular/dyn_modules/gfanlib/startingCone.cc
@@ -346,9 +346,13 @@ ring createTraversalStartingRing(const ring s, const gfan::ZMatrix &startingPoin
 
   // adjust weight and create new ordering
   int h = startingPoints.getHeight();
-  s0->order = (int*) omAlloc0((h+3)*sizeof(int));
+  omFree(s0->order);
+  s0->order = (rRingOrder_t*) omAlloc0((h+3)*sizeof(rRingOrder_t));
+  omFree(s0->block0);
   s0->block0 = (int*) omAlloc0((h+3)*sizeof(int));
+  omFree(s0->block1);
   s0->block1 = (int*) omAlloc0((h+3)*sizeof(int));
+  omFree(s0->wvhdl);
   s0->wvhdl = (int**) omAlloc0((h+3)*sizeof(int**));
   for (int i=0; i<h; i++)
   {
diff --git a/Singular/dyn_modules/gfanlib/tropicalCurves.cc b/Singular/dyn_modules/gfanlib/tropicalCurves.cc
index dc7792c..cffa022 100644
--- a/Singular/dyn_modules/gfanlib/tropicalCurves.cc
+++ b/Singular/dyn_modules/gfanlib/tropicalCurves.cc
@@ -56,7 +56,7 @@ static ring genericlyWeightedOrdering(const ring r, const gfan::ZVector &u, cons
   /* create a copy s of r and delete its ordering */
   ring s = rCopy0(r);
   omFree(s->order);
-  s->order  = (int*) omAlloc0((h+4)*sizeof(int));
+  s->order  = (rRingOrder_t*) omAlloc0((h+4)*sizeof(rRingOrder_t));
   omFree(s->block0);
   s->block0 = (int*) omAlloc0((h+4)*sizeof(int));
   omFree(s->block1);
diff --git a/Singular/dyn_modules/gfanlib/tropicalStrategy.cc b/Singular/dyn_modules/gfanlib/tropicalStrategy.cc
index b8dfc63..bdb2760 100644
--- a/Singular/dyn_modules/gfanlib/tropicalStrategy.cc
+++ b/Singular/dyn_modules/gfanlib/tropicalStrategy.cc
@@ -69,13 +69,13 @@ static bool noExtraReduction(ideal I, ring r, number /*p*/)
     allOnes[i] = 1;
   ring rShortcut = rCopy0(r);
 
-  int* order = rShortcut->order;
+  rRingOrder_t* order = rShortcut->order;
   int* block0 = rShortcut->block0;
   int* block1 = rShortcut->block1;
   int** wvhdl = rShortcut->wvhdl;
 
   int h = rBlocks(r);
-  rShortcut->order = (int*) omAlloc0((h+1)*sizeof(int));
+  rShortcut->order = (rRingOrder_t*) omAlloc0((h+1)*sizeof(rRingOrder_t));
   rShortcut->block0 = (int*) omAlloc0((h+1)*sizeof(int));
   rShortcut->block1 = (int*) omAlloc0((h+1)*sizeof(int));
   rShortcut->wvhdl = (int**) omAlloc0((h+1)*sizeof(int*));
@@ -178,7 +178,7 @@ static ring constructStartingRing(ring r)
     s->names[i] = oldNames[i-1];
   omFree(oldNames);
 
-  s->order = (int*) omAlloc0(3*sizeof(int));
+  s->order = (rRingOrder_t*) omAlloc0(3*sizeof(rRingOrder_t));
   s->block0 = (int*) omAlloc0(3*sizeof(int));
   s->block1 = (int*) omAlloc0(3*sizeof(int));
   s->wvhdl = (int**) omAlloc0(3*sizeof(int**));
@@ -444,7 +444,7 @@ ring tropicalStrategy::getShortcutRingPrependingWeight(const ring r, const gfan:
   ring rShortcut = rCopy0(r);
 
   // save old ordering
-  int* order = rShortcut->order;
+  rRingOrder_t* order = rShortcut->order;
   int* block0 = rShortcut->block0;
   int* block1 = rShortcut->block1;
   int** wvhdl = rShortcut->wvhdl;
@@ -452,7 +452,7 @@ ring tropicalStrategy::getShortcutRingPrependingWeight(const ring r, const gfan:
   // adjust weight and create new ordering
   gfan::ZVector w = adjustWeightForHomogeneity(v);
   int h = rBlocks(r); int n = rVar(r);
-  rShortcut->order = (int*) omAlloc0((h+1)*sizeof(int));
+  rShortcut->order = (rRingOrder_t*) omAlloc0((h+1)*sizeof(rRingOrder_t));
   rShortcut->block0 = (int*) omAlloc0((h+1)*sizeof(int));
   rShortcut->block1 = (int*) omAlloc0((h+1)*sizeof(int));
   rShortcut->wvhdl = (int**) omAlloc0((h+1)*sizeof(int*));
@@ -704,7 +704,7 @@ ring tropicalStrategy::copyAndChangeOrderingWP(const ring r, const gfan::ZVector
   deleteOrdering(s);
   gfan::ZVector wAdjusted = adjustWeightForHomogeneity(w);
   gfan::ZVector vAdjusted = adjustWeightUnderHomogeneity(v,wAdjusted);
-  s->order = (int*) omAlloc0(5*sizeof(int));
+  s->order = (rRingOrder_t*) omAlloc0(5*sizeof(rRingOrder_t));
   s->block0 = (int*) omAlloc0(5*sizeof(int));
   s->block1 = (int*) omAlloc0(5*sizeof(int));
   s->wvhdl = (int**) omAlloc0(5*sizeof(int**));
@@ -733,7 +733,7 @@ ring tropicalStrategy::copyAndChangeOrderingLS(const ring r, const gfan::ZVector
   ring s = rCopy0(r);
   int n = rVar(s);
   deleteOrdering(s);
-  s->order = (int*) omAlloc0(5*sizeof(int));
+  s->order = (rRingOrder_t*) omAlloc0(5*sizeof(rRingOrder_t));
   s->block0 = (int*) omAlloc0(5*sizeof(int));
   s->block1 = (int*) omAlloc0(5*sizeof(int));
   s->wvhdl = (int**) omAlloc0(5*sizeof(int**));
diff --git a/Singular/ipshell.cc b/Singular/ipshell.cc
index 40445ec..7f557e3 100644
--- a/Singular/ipshell.cc
+++ b/Singular/ipshell.cc
@@ -1572,7 +1572,7 @@ idhdl rDefault(const char *s)
   /*weights: entries for 3 blocks: NULL*/
   r->wvhdl = (int **)omAlloc0(3 * sizeof(int_ptr));
   /*order: dp,C,0*/
-  r->order = (int *) omAlloc(3 * sizeof(int *));
+  r->order = (rRingOrder_t *) omAlloc(3 * sizeof(rRingOrder_t *));
   r->block0 = (int *)omAlloc0(3 * sizeof(int *));
   r->block1 = (int *)omAlloc0(3 * sizeof(int *));
   /* ringorder dp for the first block: var 1..3 */
@@ -1582,7 +1582,7 @@ idhdl rDefault(const char *s)
   /* ringorder C for the second block: no vars */
   r->order[1]  = ringorder_C;
   /* the last block: everything is 0 */
-  r->order[2]  = 0;
+  r->order[2]  = (rRingOrder_t)0;
 
   /* complete ring intializations */
   rComplete(r);
@@ -2507,13 +2507,13 @@ static inline BOOLEAN rComposeOrder(const lists  L, const BOOLEAN check_comp, ri
     if (bitmask!=0) n--;
 
     // initialize fields of R
-    R->order=(int *)omAlloc0(n*sizeof(int));
+    R->order=(rRingOrder_t *)omAlloc0(n*sizeof(rRingOrder_t));
     R->block0=(int *)omAlloc0(n*sizeof(int));
     R->block1=(int *)omAlloc0(n*sizeof(int));
     R->wvhdl=(int**)omAlloc0(n*sizeof(int_ptr));
     // init order, so that rBlocks works correctly
     for (j_in_R= n-2; j_in_R>=0; j_in_R--)
-      R->order[j_in_R] = (int) ringorder_unspec;
+      R->order[j_in_R] = ringorder_unspec;
     // orderings
     for(j_in_R=0,j_in_L=0;j_in_R<n-1;j_in_R++,j_in_L++)
     {
@@ -2700,7 +2700,7 @@ static inline BOOLEAN rComposeOrder(const lists  L, const BOOLEAN check_comp, ri
       }
       if (!comp_order)
       {
-        R->order=(int*)omRealloc0Size(R->order,n*sizeof(int),(n+1)*sizeof(int));
+        R->order=(rRingOrder_t*)omRealloc0Size(R->order,n*sizeof(rRingOrder_t),(n+1)*sizeof(rRingOrder_t));
         R->block0=(int*)omRealloc0Size(R->block0,n*sizeof(int),(n+1)*sizeof(int));
         R->block1=(int*)omRealloc0Size(R->block1,n*sizeof(int),(n+1)*sizeof(int));
         R->wvhdl=(int**)omRealloc0Size(R->wvhdl,n*sizeof(int_ptr),(n+1)*sizeof(int_ptr));
@@ -5234,7 +5234,7 @@ BOOLEAN rSleftvOrdering2Ordering(sleftv *ord, ring R)
   }
 
   // initialize fields of R
-  R->order=(int *)omAlloc0(n*sizeof(int));
+  R->order=(rRingOrder_t *)omAlloc0(n*sizeof(rRingOrder_t));
   R->block0=(int *)omAlloc0(n*sizeof(int));
   R->block1=(int *)omAlloc0(n*sizeof(int));
   R->wvhdl=(int**)omAlloc0(n*sizeof(int_ptr));
@@ -5243,7 +5243,7 @@ BOOLEAN rSleftvOrdering2Ordering(sleftv *ord, ring R)
 
   // init order, so that rBlocks works correctly
   for (j=0; j < n-1; j++)
-    R->order[j] = (int) ringorder_unspec;
+    R->order[j] = ringorder_unspec;
   // set last _C order, if no c/C order was given
   if (i == 0) R->order[n-2] = ringorder_C;
 
@@ -5263,7 +5263,7 @@ BOOLEAN rSleftvOrdering2Ordering(sleftv *ord, ring R)
        *  iv[1]: ordering
        *  iv[2..end]: weights
        */
-      R->order[n] = (*iv)[1];
+      R->order[n] = (rRingOrder_t)((*iv)[1]);
       typ=1;
       switch ((*iv)[1])
       {
diff --git a/Singular/links/ssiLink.cc b/Singular/links/ssiLink.cc
index 2bd00fd..ff884d8 100644
--- a/Singular/links/ssiLink.cc
+++ b/Singular/links/ssiLink.cc
@@ -462,13 +462,13 @@ ring ssiReadRing(const ssiInfo *d)
   // read the orderings:
   int num_ord; // number of orderings
   num_ord=s_readint(d->f_read);
-  int *ord=(int *)omAlloc0((num_ord+1)*sizeof(int));
+  rRingOrder_t *ord=(rRingOrder_t *)omAlloc0((num_ord+1)*sizeof(rRingOrder_t));
   int *block0=(int *)omAlloc0((num_ord+1)*sizeof(int));
   int *block1=(int *)omAlloc0((num_ord+1)*sizeof(int));
   int **wvhdl=(int**)omAlloc0((num_ord+1)*sizeof(int*));
   for(i=0;i<num_ord;i++)
   {
-    ord[i]=s_readint(d->f_read);
+    ord[i]=(rRingOrder_t)s_readint(d->f_read);
     block0[i]=s_readint(d->f_read);
     block1[i]=s_readint(d->f_read);
     switch(ord[i])
diff --git a/Singular/walk.cc b/Singular/walk.cc
index 3970707..8c1fb42 100644
--- a/Singular/walk.cc
+++ b/Singular/walk.cc
@@ -2695,14 +2695,18 @@ static ring VMrDefault(intvec* va)
   int nb = 4;
 
   /*weights: entries for 3 blocks: NULL Made:???*/
+  omFree(r->wvhdl);
   r->wvhdl = (int **)omAlloc0(nb * sizeof(int_ptr));
   r->wvhdl[0] = (int*) omAlloc(nv*sizeof(int));
   for(i=0; i<nv; i++)
     r->wvhdl[0][i] = (*va)[i];
 
   /* order: a,lp,C,0 */
-  r->order = (int *) omAlloc(nb * sizeof(int *));
+  omFree(r->order);
+  r->order = (rRingOrder_t *) omAlloc(nb * sizeof(rRingOrder_t *));
+  omFree(r->block0);
   r->block0 = (int *)omAlloc0(nb * sizeof(int *));
+  omFree(r->block1);
   r->block1 = (int *)omAlloc0(nb * sizeof(int *));
 
   // ringorder a for the first block: var 1..nv
@@ -2722,7 +2726,7 @@ static ring VMrDefault(intvec* va)
   r->order[2]  = ringorder_C;
 
   // the last block: everything is 0
-  r->order[3]  = 0;
+  r->order[3]  = (rRingOrder_t)0;
 
   // polynomial ring
   r->OrdSgn    = 1;
@@ -2746,6 +2750,7 @@ static ring VMrRefine(intvec* va, intvec* vb)
   int nb = 5;
 
   //weights: entries for 3 blocks: NULL Made:???
+  omFree(r->wvhdl);
   r->wvhdl = (int **)omAlloc0(nb * sizeof(int_ptr));
   r->wvhdl[0] = (int*) omAlloc(nv*sizeof(int));
   r->wvhdl[1] = (int*) omAlloc(nv*sizeof(int));
@@ -2757,8 +2762,11 @@ static ring VMrRefine(intvec* va, intvec* vb)
   }
 
   // order: (1..1),a,lp,C
-  r->order = (int *) omAlloc(nb * sizeof(int *));
+  omFree(r->order);
+  r->order = (rRingOrder_t *) omAlloc(nb * sizeof(rRingOrder_t *));
+  omFree(r->block0);
   r->block0 = (int *)omAlloc0(nb * sizeof(int *));
+  omFree(r->block1);
   r->block1 = (int *)omAlloc0(nb * sizeof(int *));
 
   // ringorder a for the first block: var 1..nv
@@ -2783,7 +2791,7 @@ static ring VMrRefine(intvec* va, intvec* vb)
   r->order[3]  = ringorder_C;
 
   // the last block: everything is 0
-  r->order[4]  = 0;
+  r->order[4]  = (rRingOrder_t)0;
 
   // complete ring intializations
 
@@ -2805,6 +2813,7 @@ static ring VMatrDefault(intvec* va)
   int nb = 4;
 
   /*weights: entries for 3 blocks: NULL Made:???*/
+  omFree(r->wvhdl);
   r->wvhdl = (int **)omAlloc0(nb * sizeof(int_ptr));
   r->wvhdl[0] = (int*) omAlloc(nv*nv*sizeof(int));
   r->wvhdl[1] =NULL; // (int*) omAlloc(nv*sizeof(int));
@@ -2814,8 +2823,11 @@ static ring VMatrDefault(intvec* va)
     r->wvhdl[0][i] = (*va)[i];
 
   /* order: a,lp,C,0 */
-  r->order = (int *) omAlloc(nb * sizeof(int *));
+  omFree(r->order);
+  r->order = (rRingOrder_t*) omAlloc(nb * sizeof(rRingOrder_t*));
+  omFree(r->block0);
   r->block0 = (int *)omAlloc0(nb * sizeof(int *));
+  omFree(r->block1);
   r->block1 = (int *)omAlloc0(nb * sizeof(int *));
 
   // ringorder a for the first block: var 1..nv
@@ -2834,7 +2846,7 @@ static ring VMatrDefault(intvec* va)
   r->block1[2] = nv;
 
   // the last block: everything is 0
-  r->order[3]  = 0;
+  r->order[3]  = (rRingOrder_t)0;
 
   // complete ring intializations
 
@@ -2857,6 +2869,7 @@ static ring VMatrRefine(intvec* va, intvec* vb)
   int nb = 4;
 
   /*weights: entries for 3 blocks: NULL Made:???*/
+  omFree(r->wvhdl);
   r->wvhdl = (int **)omAlloc0(nb * sizeof(int_ptr));
   r->wvhdl[0] = (int*) omAlloc(nv*sizeof(int));
   r->wvhdl[1] = (int*) omAlloc(nvs*sizeof(int));
@@ -2871,8 +2884,11 @@ static ring VMatrRefine(intvec* va, intvec* vb)
     r->wvhdl[0][i] = (*vb)[i];
   }
   /* order: a,lp,C,0 */
-  r->order = (int *) omAlloc(nb * sizeof(int *));
+  omFree(r->order);
+  r->order = (rRingOrder_t *) omAlloc(nb * sizeof(rRingOrder_t *));
+  omFree(r->block0);
   r->block0 = (int *)omAlloc0(nb * sizeof(int *));
+  omFree(r->block1);
   r->block1 = (int *)omAlloc0(nb * sizeof(int *));
 
   // ringorder a for the first block: var 1..nv
@@ -2891,7 +2907,7 @@ static ring VMatrRefine(intvec* va, intvec* vb)
   r->block1[2] = nv;
 
   // the last block: everything is 0
-  r->order[3]  = 0;
+  r->order[3]  = (rRingOrder_t)0;
 
   // complete ring intializations
 
@@ -2913,11 +2929,15 @@ static void VMrDefaultlp(void)
 
   /*weights: entries for 3 blocks: NULL Made:???*/
 
+ omFree(r->wvhdl);
   r->wvhdl = (int **)omAlloc0(nb * sizeof(int_ptr));
 
   /* order: lp,C,0 */
-  r->order = (int *) omAlloc(nb * sizeof(int *));
+ omFree(r->order);
+  r->order = (rRingOrder_t *) omAlloc(nb * sizeof(rRingOrder_t *));
+ omFree(r->block0);
   r->block0 = (int *)omAlloc0(nb * sizeof(int *));
+ omFree(r->block1);
   r->block1 = (int *)omAlloc0(nb * sizeof(int *));
 
   /* ringorder lp for the first block: var 1..nv */
@@ -2929,7 +2949,7 @@ static void VMrDefaultlp(void)
   r->order[1]  = ringorder_C;
 
   /* the last block: everything is 0 */
-  r->order[2]  = 0;
+  r->order[2]  = (rRingOrder_t)0;
 
   /*polynomial ring*/
   r->OrdSgn    = 1;
@@ -2953,6 +2973,7 @@ static void DefRingPar(intvec* va)
   ring res=rCopy0(currRing,FALSE,FALSE);
 
   /*weights: entries for 3 blocks: NULL Made:???*/
+  omFree(res->wvhdl);
   res->wvhdl = (int **)omAlloc0(nb * sizeof(int_ptr));
   res->wvhdl[0] = (int*) omAlloc(nv*sizeof(int));
   for(int i=0; i<nv; i++)
@@ -2960,8 +2981,11 @@ static void DefRingPar(intvec* va)
 
   /* order: a,lp,C,0 */
 
-  res->order = (int *) omAlloc(nb * sizeof(int *));
+  omFree(res->order);
+  res->order = (rRingOrder_t *) omAlloc(nb * sizeof(rRingOrder_t *));
+  omFree(res->block0);
   res->block0 = (int *)omAlloc0(nb * sizeof(int *));
+  omFree(res->block1);
   res->block1 = (int *)omAlloc0(nb * sizeof(int *));
 
   // ringorder a for the first block: var 1..nv
@@ -2981,7 +3005,7 @@ static void DefRingPar(intvec* va)
   res->order[2]  = ringorder_C;
 
   // the last block: everything is 0
-  res->order[3]  = 0;
+  res->order[3]  = (rRingOrder_t)0;
 
   // polynomial ring
   res->OrdSgn    = 1;
@@ -3004,11 +3028,15 @@ static void DefRingParlp(void)
 
   /*weights: entries for 3 blocks: NULL Made:???*/
 
+  omFree(r->wvhdl);
   r->wvhdl = (int **)omAlloc0(nb * sizeof(int_ptr));
 
   /* order: lp,C,0 */
-  r->order = (int *) omAlloc(nb * sizeof(int *));
+  omFree(r->order);
+  r->order = (rRingOrder_t *) omAlloc(nb * sizeof(rRingOrder_t *));
+  omFree(r->block0);
   r->block0 = (int *)omAlloc0(nb * sizeof(int *));
+  omFree(r->block1);
   r->block1 = (int *)omAlloc0(nb * sizeof(int *));
 
   /* ringorder lp for the first block: var 1..nv */
@@ -3020,7 +3048,7 @@ static void DefRingParlp(void)
   r->order[1]  = ringorder_C;
 
   /* the last block: everything is 0 */
-  r->order[2]  = 0;
+  r->order[2]  = (rRingOrder_t)0;
 
   /*polynomial ring*/
   r->OrdSgn    = 1;
diff --git a/kernel/GBEngine/kutil.cc b/kernel/GBEngine/kutil.cc
index 90a8f8c..34cff54 100644
--- a/kernel/GBEngine/kutil.cc
+++ b/kernel/GBEngine/kutil.cc
@@ -11394,7 +11394,7 @@ ring sbaRing (kStrategy strat, const ring r, BOOLEAN /*complete*/, int /*sgn*/)
       return r;
     }
     ring res = rCopy0(r, TRUE, FALSE);
-    res->order  = (int *)omAlloc0((n+1)*sizeof(int));
+    res->order  = (rRingOrder_t *)omAlloc0((n+1)*sizeof(rRingOrder_t));
     res->block0 = (int *)omAlloc0((n+1)*sizeof(int));
     res->block1 = (int *)omAlloc0((n+1)*sizeof(int));
     int **wvhdl = (int **)omAlloc0((n+1)*sizeof(int*));
@@ -11414,7 +11414,7 @@ ring sbaRing (kStrategy strat, const ring r, BOOLEAN /*complete*/, int /*sgn*/)
     {
       if (res->order[i] == ringorder_C || res->order[i] == ringorder_c)
       {
-        res->order[i] = 0;
+        res->order[i] = (rRingOrder_t)0;
       }
     }
     rComplete(res, 1);
@@ -11442,7 +11442,7 @@ ring sbaRing (kStrategy strat, const ring r, BOOLEAN /*complete*/, int /*sgn*/)
   if (strat->sbaOrder == 3)
   {
     ring res = rCopy0(r, TRUE, FALSE);
-    res->order  = (int *)omAlloc0((n+2)*sizeof(int));
+    res->order  = (rRingOrder_t*)omAlloc0((n+2)*sizeof(rRingOrder_t));
     res->block0 = (int *)omAlloc0((n+2)*sizeof(int));
     res->block1 = (int *)omAlloc0((n+2)*sizeof(int));
     int **wvhdl = (int **)omAlloc0((n+2)*sizeof(int*));
@@ -11470,7 +11470,7 @@ ring sbaRing (kStrategy strat, const ring r, BOOLEAN /*complete*/, int /*sgn*/)
     {
       if (res->order[i] == ringorder_C || res->order[i] == ringorder_c)
       {
-        res->order[i] = 0;
+        res->order[i] = (rRingOrder_t)0;
       }
     }
     rComplete(res, 1);
diff --git a/kernel/ideals.cc b/kernel/ideals.cc
index adf4631..2c6de19 100644
--- a/kernel/ideals.cc
+++ b/kernel/ideals.cc
@@ -145,7 +145,7 @@ ideal idSectWithElim (ideal h1,ideal h2)
   r->block0[0]=1;
   r->block1[0]= r->N;
   omFree(r->order);
-  r->order=(int*)omAlloc0(3*sizeof(int*));
+  r->order=(rRingOrder_t*)omAlloc0(3*sizeof(rRingOrder_t));
   r->order[0]=ringorder_dp;
   r->order[1]=ringorder_C;
   char **names=(char**)omAlloc0(rVar(r) * sizeof(char_ptr));
@@ -1354,7 +1354,8 @@ ideal idElimination (ideal h1,poly delVar,intvec *hilb)
 {
   int    i,j=0,k,l;
   ideal  h,hh, h3;
-  int    *ord,*block0,*block1;
+  rRingOrder_t    *ord;
+  int    *block0,*block1;
   int    ordersize=2;
   int    **wv;
   tHomog hom;
@@ -1434,7 +1435,7 @@ ideal idElimination (ideal h1,poly delVar,intvec *hilb)
     // aa(1,1,1,...,0,0,0),wp(...),C
     // this seems to be better than version 2 below,
     // according to Tst/../elimiate_[3568].tat (- 17 %)
-    ord=(int*)omAlloc0(4*sizeof(int));
+    ord=(rRingOrder_t*)omAlloc0(4*sizeof(rRingOrder_t));
     block0=(int*)omAlloc0(4*sizeof(int));
     block1=(int*)omAlloc0(4*sizeof(int));
     wv=(int**) omAlloc0(4*sizeof(int**));
@@ -1477,13 +1478,13 @@ ideal idElimination (ideal h1,poly delVar,intvec *hilb)
       if (pGetExp(delVar,j+1)!=0) wv[1][j]=1;
     #endif
     ord[2] = ringorder_C;
-    ord[3] = 0;
+    ord[3] = (rRingOrder_t)0;
   }
   else
   {
     // we change to an ordering:
     // aa(....),orig_ordering
-    ord=(int*)omAlloc0(ordersize*sizeof(int));
+    ord=(rRingOrder_t*)omAlloc0(ordersize*sizeof(rRingOrder_t));
     block0=(int*)omAlloc0(ordersize*sizeof(int));
     block1=(int*)omAlloc0(ordersize*sizeof(int));
     wv=(int**) omAlloc0(ordersize*sizeof(int**));
diff --git a/libpolys/polys/monomials/ring.cc b/libpolys/polys/monomials/ring.cc
index d33564a..ca430dd 100644
--- a/libpolys/polys/monomials/ring.cc
+++ b/libpolys/polys/monomials/ring.cc
@@ -110,7 +110,7 @@ static void rOptimizeLDeg(ring r);
 //  return FALSE;
 //}
 
-ring rDefault(const coeffs cf, int N, char **n,int ord_size, int *ord, int *block0, int *block1, int** wvhdl)
+ring rDefault(const coeffs cf, int N, char **n,int ord_size, rRingOrder_t *ord, int *block0, int *block1, int** wvhdl)
 {
   assume( cf != NULL);
   ring r=(ring) omAlloc0Bin(sip_sring_bin);
@@ -137,7 +137,7 @@ ring rDefault(const coeffs cf, int N, char **n,int ord_size, int *ord, int *bloc
   rComplete(r);
   return r;
 }
-ring rDefault(int ch, int N, char **n,int ord_size, int *ord, int *block0, int *block1,int ** wvhdl)
+ring rDefault(int ch, int N, char **n,int ord_size, rRingOrder_t *ord, int *block0, int *block1,int ** wvhdl)
 {
   coeffs cf;
   if (ch==0) cf=nInitChar(n_Q,NULL);
@@ -149,7 +149,7 @@ ring rDefault(const coeffs cf, int N, char **n,  const rRingOrder_t o)
 {
   assume( cf != NULL);
   /*order: o=lp,0*/
-  int *order = (int *) omAlloc(2* sizeof(int));
+  rRingOrder_t *order = (rRingOrder_t *) omAlloc(2* sizeof(rRingOrder_t));
   int *block0 = (int *)omAlloc0(2 * sizeof(int));
   int *block1 = (int *)omAlloc0(2 * sizeof(int));
   /* ringorder o=lp for the first block: var 1..N */
@@ -157,7 +157,7 @@ ring rDefault(const coeffs cf, int N, char **n,  const rRingOrder_t o)
   block0[0] = 1;
   block1[0] = N;
   /* the last block: everything is 0 */
-  order[1]  = 0;
+  order[1]  = (rRingOrder_t)0;
 
   return rDefault(cf,N,n,2,order,block0,block1);
 }
@@ -478,7 +478,7 @@ void rDelete(ring r)
     i=rBlocks(r);
     assume(r->block0 != NULL && r->block1 != NULL && r->wvhdl != NULL);
     // delete order
-    omFreeSize((ADDRESS)r->order,i*sizeof(int));
+    omFreeSize((ADDRESS)r->order,i*sizeof(rRingOrder_t));
     omFreeSize((ADDRESS)r->block0,i*sizeof(int));
     omFreeSize((ADDRESS)r->block1,i*sizeof(int));
     // delete weights
@@ -507,7 +507,7 @@ void rDelete(ring r)
   omFreeBin(r, sip_sring_bin);
 }
 
-int rOrderName(char * ordername)
+rRingOrder_t rOrderName(char * ordername)
 {
   int order=ringorder_unspec;
   while (order!= 0)
@@ -518,7 +518,7 @@ int rOrderName(char * ordername)
   }
   if (order==0) Werror("wrong ring order `%s`",ordername);
   omFree((ADDRESS)ordername);
-  return order;
+  return (rRingOrder_t)order;
 }
 
 char * rOrdStr(ring r)
@@ -900,7 +900,7 @@ int rSumInternal(ring r1, ring r2, ring &sum, BOOLEAN vartest, BOOLEAN dp_dp)
 #endif
      )
   {
-    tmpR.order=(int*)omAlloc0(4*sizeof(int));
+    tmpR.order=(rRingOrder_t*)omAlloc0(4*sizeof(rRingOrder_t));
     tmpR.block0=(int*)omAlloc0(4*sizeof(int));
     tmpR.block1=(int*)omAlloc0(4*sizeof(int));
     tmpR.wvhdl=(int**) omAlloc0(4*sizeof(int**));
@@ -923,7 +923,7 @@ int rSumInternal(ring r1, ring r2, ring &sum, BOOLEAN vartest, BOOLEAN dp_dp)
 #endif
      )
   {
-    tmpR.order=(int*)omAlloc(4*sizeof(int));
+    tmpR.order=(rRingOrder_t*)omAlloc(4*sizeof(rRingOrder_t));
     tmpR.block0=(int*)omAlloc0(4*sizeof(int));
     tmpR.block1=(int*)omAlloc0(4*sizeof(int));
     tmpR.wvhdl=(int**)omAlloc0(4*sizeof(int *));
@@ -954,20 +954,20 @@ int rSumInternal(ring r1, ring r2, ring &sum, BOOLEAN vartest, BOOLEAN dp_dp)
     tmpR.block0[1]=rVar(r1)+1;
     tmpR.block1[1]=rVar(r1)+rVar(r2);
     tmpR.order[2]=ringorder_C;
-    tmpR.order[3]=0;
+    tmpR.order[3]=(rRingOrder_t)0;
   }
   else
   {
     if ((r1->order[0]==ringorder_unspec)
         && (r2->order[0]==ringorder_unspec))
     {
-      tmpR.order=(int*)omAlloc(3*sizeof(int));
+      tmpR.order=(rRingOrder_t*)omAlloc(3*sizeof(rRingOrder_t));
       tmpR.block0=(int*)omAlloc(3*sizeof(int));
       tmpR.block1=(int*)omAlloc(3*sizeof(int));
       tmpR.wvhdl=(int**)omAlloc0(3*sizeof(int *));
       tmpR.order[0]=ringorder_unspec;
       tmpR.order[1]=ringorder_C;
-      tmpR.order[2]=0;
+      tmpR.order[2]=(rRingOrder_t)0;
       tmpR.block0[0]=1;
       tmpR.block1[0]=tmpR.N;
     }
@@ -994,7 +994,7 @@ int rSumInternal(ring r1, ring r2, ring &sum, BOOLEAN vartest, BOOLEAN dp_dp)
         b=rBlocks(r1)+rBlocks(r2)-2; /* for only one order C, only one 0 */
         rb=NULL;
       }
-      tmpR.order=(int*)omAlloc0(b*sizeof(int));
+      tmpR.order=(rRingOrder_t*)omAlloc0(b*sizeof(rRingOrder_t));
       tmpR.block0=(int*)omAlloc0(b*sizeof(int));
       tmpR.block1=(int*)omAlloc0(b*sizeof(int));
       tmpR.wvhdl=(int**)omAlloc0(b*sizeof(int *));
@@ -1054,7 +1054,7 @@ int rSumInternal(ring r1, ring r2, ring &sum, BOOLEAN vartest, BOOLEAN dp_dp)
     {
       int b=rBlocks(r1);
 
-      tmpR.order=(int*)omAlloc0(b*sizeof(int));
+      tmpR.order=(rRingOrder_t*)omAlloc0(b*sizeof(rRingOrder_t));
       tmpR.block0=(int*)omAlloc0(b*sizeof(int));
       tmpR.block1=(int*)omAlloc0(b*sizeof(int));
       tmpR.wvhdl=(int**)omAlloc0(b*sizeof(int *));
@@ -1400,7 +1400,7 @@ ring rCopy0(const ring r, BOOLEAN copy_qideal, BOOLEAN copy_ordering)
     res->MixedOrder=r->MixedOrder; // TRUE for mixed (global/local) ordering, FALSE otherwise,
     i=rBlocks(r);
     res->wvhdl   = (int **)omAlloc(i * sizeof(int *));
-    res->order   = (int *) omAlloc(i * sizeof(int));
+    res->order   = (rRingOrder_t *) omAlloc(i * sizeof(rRingOrder_t));
     res->block0  = (int *) omAlloc(i * sizeof(int));
     res->block1  = (int *) omAlloc(i * sizeof(int));
     for (j=0; j<i; j++)
@@ -1412,7 +1412,7 @@ ring rCopy0(const ring r, BOOLEAN copy_qideal, BOOLEAN copy_ordering)
       else
         res->wvhdl[j]=NULL;
     }
-    memcpy(res->order,r->order,i * sizeof(int));
+    memcpy(res->order,r->order,i * sizeof(rRingOrder_t));
     memcpy(res->block0,r->block0,i * sizeof(int));
     memcpy(res->block1,r->block1,i * sizeof(int));
   }
@@ -1538,7 +1538,7 @@ ring rCopy0AndAddA(const ring r,  int64vec *wv64, BOOLEAN copy_qideal, BOOLEAN c
   {
     i=rBlocks(r)+1; // DIFF to rCopy0
     res->wvhdl   = (int **)omAlloc(i * sizeof(int *));
-    res->order   = (int *) omAlloc(i * sizeof(int));
+    res->order   = (rRingOrder_t *) omAlloc(i * sizeof(rRingOrder_t));
     res->block0  = (int *) omAlloc(i * sizeof(int));
     res->block1  = (int *) omAlloc(i * sizeof(int));
     for (j=0; j<i-1; j++)
@@ -1550,7 +1550,7 @@ ring rCopy0AndAddA(const ring r,  int64vec *wv64, BOOLEAN copy_qideal, BOOLEAN c
       else
         res->wvhdl[j+1]=NULL; //DIFF
     }
-    memcpy(&(res->order[1]),r->order,(i-1) * sizeof(int)); //DIFF
+    memcpy(&(res->order[1]),r->order,(i-1) * sizeof(rRingOrder_t)); //DIFF
     memcpy(&(res->block0[1]),r->block0,(i-1) * sizeof(int)); //DIFF
     memcpy(&(res->block1[1]),r->block1,(i-1) * sizeof(int)); //DIFF
   }
@@ -2611,7 +2611,7 @@ ring rModifyRing(ring r, BOOLEAN omit_degree,
   need_other_ring = (exp_limit != r->bitmask);
 
   int nblocks=rBlocks(r);
-  int *order=(int*)omAlloc0((nblocks+1)*sizeof(int));
+  rRingOrder_t *order=(rRingOrder_t*)omAlloc0((nblocks+1)*sizeof(rRingOrder_t));
   int *block0=(int*)omAlloc0((nblocks+1)*sizeof(int));
   int *block1=(int*)omAlloc0((nblocks+1)*sizeof(int));
   int **wvhdl=(int**)omAlloc0((nblocks+1)*sizeof(int *));
@@ -2619,7 +2619,7 @@ ring rModifyRing(ring r, BOOLEAN omit_degree,
   int i=0;
   int j=0; /*  i index in r, j index in res */
 
-  for( int r_ord=r->order[i]; (r_ord != 0) && (i < nblocks); j++, r_ord=r->order[++i])
+  for( rRingOrder_t r_ord=r->order[i]; (r_ord != (rRingOrder_t)0) && (i < nblocks); j++, r_ord=r->order[++i])
   {
     BOOLEAN copy_block_index=TRUE;
 
@@ -2736,7 +2736,7 @@ ring rModifyRing(ring r, BOOLEAN omit_degree,
   }
   if(!need_other_ring)
   {
-    omFreeSize(order,(nblocks+1)*sizeof(int));
+    omFreeSize(order,(nblocks+1)*sizeof(rRingOrder_t));
     omFreeSize(block0,(nblocks+1)*sizeof(int));
     omFreeSize(block1,(nblocks+1)*sizeof(int));
     omFreeSize(wvhdl,(nblocks+1)*sizeof(int *));
@@ -2853,7 +2853,7 @@ ring rModifyRing_Wp(ring r, int* weights)
   /*weights: entries for 3 blocks: NULL*/
   res->wvhdl = (int **)omAlloc0(3 * sizeof(int *));
   /*order: Wp,C,0*/
-  res->order = (int *) omAlloc(3 * sizeof(int *));
+  res->order = (rRingOrder_t *) omAlloc(3 * sizeof(rRingOrder_t *));
   res->block0 = (int *)omAlloc0(3 * sizeof(int *));
   res->block1 = (int *)omAlloc0(3 * sizeof(int *));
   /* ringorder Wp for the first block: var 1..r->N */
@@ -2864,7 +2864,7 @@ ring rModifyRing_Wp(ring r, int* weights)
   /* ringorder C for the second block: no vars */
   res->order[1]  = ringorder_C;
   /* the last block: everything is 0 */
-  res->order[2]  = 0;
+  res->order[2]  = (rRingOrder_t)0;
 
   //int tmpref=r->cf->ref;
   rComplete(res, 1);
@@ -2903,7 +2903,7 @@ ring rModifyRing_Simple(ring r, BOOLEAN ommit_degree, BOOLEAN ommit_comp, unsign
     exp_limit=rGetExpSize(exp_limit, bits, r->N);
 
     int nblocks=1+(ommit_comp!=0);
-    int *order=(int*)omAlloc0((nblocks+1)*sizeof(int));
+    rRingOrder_t *order=(rRingOrder_t*)omAlloc0((nblocks+1)*sizeof(rRingOrder_t));
     int *block0=(int*)omAlloc0((nblocks+1)*sizeof(int));
     int *block1=(int*)omAlloc0((nblocks+1)*sizeof(int));
     int **wvhdl=(int**)omAlloc0((nblocks+1)*sizeof(int *));
@@ -3022,7 +3022,7 @@ static void rSetOutParams(ring r)
   assume( !( !r->CanShortOut && r->ShortOut ) );
 }
 
-static void rSetFirstWv(ring r, int i, int* order, int* block1, int** wvhdl)
+static void rSetFirstWv(ring r, int i, rRingOrder_t* order, int* block1, int** wvhdl)
 {
   // cheat for ringorder_aa
   if (order[i] == ringorder_aa)
@@ -3084,7 +3084,7 @@ static void rOptimizeLDeg(ring r)
 // set pFDeg, pLDeg, requires OrdSgn already set
 static void rSetDegStuff(ring r)
 {
-  int* order = r->order;
+  rRingOrder_t* order = r->order;
   int* block0 = r->block0;
   int* block1 = r->block1;
   int** wvhdl = r->wvhdl;
@@ -4363,7 +4363,7 @@ ring rAssure_SyzComp(const ring r, BOOLEAN complete)
   int i=rBlocks(r);
   int j;
 
-  res->order=(int *)omAlloc((i+1)*sizeof(int));
+  res->order=(rRingOrder_t *)omAlloc((i+1)*sizeof(rRingOrder_t));
   res->block0=(int *)omAlloc0((i+1)*sizeof(int));
   res->block1=(int *)omAlloc0((i+1)*sizeof(int));
   int ** wvhdl =(int **)omAlloc0((i+1)*sizeof(int**));
@@ -4539,10 +4539,10 @@ ring rAssure_HasComp(const ring r)
   ring new_r = rCopy0(r, FALSE, FALSE);
   i+=2;
   new_r->wvhdl=(int **)omAlloc0(i * sizeof(int *));
-  new_r->order   = (int *) omAlloc0(i * sizeof(int));
+  new_r->order   = (rRingOrder_t *) omAlloc0(i * sizeof(rRingOrder_t));
   new_r->block0   = (int *) omAlloc0(i * sizeof(int));
   new_r->block1   = (int *) omAlloc0(i * sizeof(int));
-  memcpy(new_r->order,r->order,(i-1) * sizeof(int));
+  memcpy(new_r->order,r->order,(i-1) * sizeof(rRingOrder_t));
   memcpy(new_r->block0,r->block0,(i-1) * sizeof(int));
   memcpy(new_r->block1,r->block1,(i-1) * sizeof(int));
   for (int j=0; j<=last_block; j++)
@@ -4699,7 +4699,7 @@ static ring rAssure_Global(rRingOrder_t b1, rRingOrder_t b2, const ring r)
       (r->order[2] == 0))
     return r;
   ring res = rCopy0(r, TRUE, FALSE);
-  res->order = (int*)omAlloc0(3*sizeof(int));
+  res->order = (rRingOrder_t*)omAlloc0(3*sizeof(rRingOrder_t));
   res->block0 = (int*)omAlloc0(3*sizeof(int));
   res->block1 = (int*)omAlloc0(3*sizeof(int));
   res->wvhdl = (int**)omAlloc0(3*sizeof(int*));
@@ -4749,7 +4749,7 @@ ring rAssure_InducedSchreyerOrdering(const ring r, BOOLEAN complete = TRUE, int
   int n = rBlocks(r); // Including trailing zero!
 
   // Create 2 more blocks for prefix/suffix:
-  res->order=(int *)omAlloc0((n+2)*sizeof(int)); // 0  ..  n+1
+  res->order=(rRingOrder_t *)omAlloc0((n+2)*sizeof(rRingOrder_t)); // 0  ..  n+1
   res->block0=(int *)omAlloc0((n+2)*sizeof(int));
   res->block1=(int *)omAlloc0((n+2)*sizeof(int));
   int ** wvhdl =(int **)omAlloc0((n+2)*sizeof(int**));
@@ -5115,12 +5115,12 @@ void rSetWeightVec(ring r, int64 *wv)
 
 static int rRealloc1(ring r, int size, int pos)
 {
-  r->order=(int*)omReallocSize(r->order, size*sizeof(int), (size+1)*sizeof(int));
+  r->order=(rRingOrder_t*)omReallocSize(r->order, size*sizeof(rRingOrder_t), (size+1)*sizeof(rRingOrder_t));
   r->block0=(int*)omReallocSize(r->block0, size*sizeof(int), (size+1)*sizeof(int));
   r->block1=(int*)omReallocSize(r->block1, size*sizeof(int), (size+1)*sizeof(int));
   r->wvhdl=(int **)omReallocSize(r->wvhdl,size*sizeof(int *), (size+1)*sizeof(int *));
   for(int k=size; k>pos; k--) r->wvhdl[k]=r->wvhdl[k-1];
-  r->order[size]=0;
+  r->order[size]=(rRingOrder_t)0;
   size++;
   return size;
 }
diff --git a/libpolys/polys/monomials/ring.h b/libpolys/polys/monomials/ring.h
index a556fe2..62026dd 100644
--- a/libpolys/polys/monomials/ring.h
+++ b/libpolys/polys/monomials/ring.h
@@ -258,7 +258,7 @@ struct ip_sring
 // general ordering: pointer/structs, long, int, short, BOOLEAN/char/enum
 // general defining procedures: rInit, rComplete, interpreter, ??
   idhdl      idroot; /* local objects , interpreter*/
-  int*       order;  /* array of orderings, rInit/rSleftvOrdering2Ordering */
+  rRingOrder_t* order;  /* array of orderings, rInit/rSleftvOrdering2Ordering */
   int*       block0; /* starting pos., rInit/rSleftvOrdering2Ordering*/
   int*       block1; /* ending pos., rInit/rSleftvOrdering2Ordering*/
 //  char**     parameter; /* names of parameters, rInit */
@@ -387,8 +387,8 @@ struct ip_sring
 
 ring   rDefault(int ch, int N, char **n);
 ring   rDefault(const coeffs cf, int N, char **n, const rRingOrder_t o=ringorder_lp);
-ring   rDefault(int ch, int N, char **n,int ord_size, int *ord, int *block0, int *block1, int **wvhdl=NULL);
-ring   rDefault(const coeffs cf, int N, char **n,int ord_size, int *ord, int *block0, int *block1, int **wvhdl=NULL);
+ring   rDefault(int ch, int N, char **n,int ord_size, rRingOrder_t *ord, int *block0, int *block1, int **wvhdl=NULL);
+ring   rDefault(const coeffs cf, int N, char **n,int ord_size, rRingOrder_t *ord, int *block0, int *block1, int **wvhdl=NULL);
 
 // #define rIsRingVar(A) r_IsRingVar(A,currRing)
 int    r_IsRingVar(const char *n, char**names, int N);
@@ -431,7 +431,7 @@ void rGetSComps(int** currComponents, long** currShiftedComponents, int *length,
 
 
 const char * rSimpleOrdStr(int ord);
-int rOrderName(char * ordername);
+rRingOrder_t rOrderName(char * ordername);
 char * rOrdStr(ring r);
 char * rVarStr(ring r);
 char * rCharStr(ring r);
diff --git a/libpolys/polys/sparsmat.cc b/libpolys/polys/sparsmat.cc
index 5f3ae72..739df68 100644
--- a/libpolys/polys/sparsmat.cc
+++ b/libpolys/polys/sparsmat.cc
@@ -263,7 +263,7 @@ ring sm_RingChange(const ring origR, long bound)
 {
 //  *origR =currRing;
   ring tmpR=rCopy0(origR,FALSE,FALSE);
-  int *ord=(int*)omAlloc0(3*sizeof(int));
+  rRingOrder_t *ord=(rRingOrder_t*)omAlloc0(3*sizeof(rRingOrder_t));
   int *block0=(int*)omAlloc(3*sizeof(int));
   int *block1=(int*)omAlloc(3*sizeof(int));
   ord[0]=ringorder_c;
