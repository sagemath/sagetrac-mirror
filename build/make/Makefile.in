# Always use bash for make rules
SHELL = /bin/bash

ifndef SAGE_SPKG_INST
$(error This Makefile needs to be invoked by build/make/install)
endif

# Directory to keep track of which packages are installed
INST = $(SAGE_SPKG_INST)

# Aliases for optional packages selected at configure time
TOOLCHAIN = @SAGE_TOOLCHAIN@
PYTHON = python@SAGE_PYTHON_VERSION@
MP_LIBRARY = @SAGE_MP_LIBRARY@
BLAS = @SAGE_BLAS@

# Files to track installation of packages
BUILT_PACKAGES = @SAGE_BUILT_PACKAGES@
DUMMY_PACKAGES = @SAGE_DUMMY_PACKAGES@

# Versions of all the packages, in the format
#
# vers_<pkgname> = <pkgvers>

@SAGE_PACKAGE_VERSIONS@

# Dependencies for all packages, in the format
#
# deps_<pkgname> = <dep1> <dep2> etc...

@SAGE_PACKAGE_DEPENDENCIES@

# All standard packages
STANDARD_PACKAGES = @SAGE_STANDARD_PACKAGES@
STANDARD_PACKAGE_INSTS = \
	$(foreach pkgname,$(STANDARD_PACKAGES),$(inst_$(pkgname)))

# All optional installed packages (triggers the auto-update)
OPTIONAL_INSTALLED_PACKAGES = @SAGE_OPTIONAL_INSTALLED_PACKAGES@
OPTIONAL_INSTALLED_PACKAGE_INSTS = \
    $(foreach pkgname,$(OPTIONAL_INSTALLED_PACKAGES),$(inst_$(pkgname)))

# All packages which should be downloaded
SDIST_PACKAGES = @SAGE_SDIST_PACKAGES@
SDIST_PACKAGE_INSTS = $(foreach pkgname,$(SDIST_PACKAGES),$(inst_$(pkgname)))

SCRIPTS = @SAGE_SCRIPTS@

EXTCODE = @SAGE_EXTCODE@

# Packages that use the 'normal' build rules
NORMAL_PACKAGES = @SAGE_NORMAL_PACKAGES@

# Packages that use the 'pip' package build rules
PIP_PACKAGES = @SAGE_PIP_PACKAGES@

# Packages that use the 'script' package build rules (not to be confused with
# the $(SCRIPTS) list)
SCRIPT_PACKAGES = @SAGE_SCRIPT_PACKAGES@



# Generate the actual inst_<pkgname> variables; for each package that is
# actually built this generates a line like:
#
# inst_<pkgname> = $(INST)/<pkgname>-<pkgvers>
#
# And for 'dummy' package that are not actually built/installed:
#
# inst_<pkgname> = $(INST)/.dummy

$(foreach pkgname,$(BUILT_PACKAGES),\
	$(eval inst_$(pkgname) = $$(INST)/$(pkgname)-$(vers_$(pkgname))))

$(foreach pkgname,$(DUMMY_PACKAGES),\
	$(eval inst_$(pkgname) = $$(INST)/.dummy))


# Dummy target for packages which are not installed
$(INST)/.dummy:
	touch $@


@SAGE_MAKE_DEPS@


#==============================================================================
# Rules generated from pkgs/<package>/dependencies files
#==============================================================================

# Generate build rules for 'normal' packages; this template is used to generate
# three rules in the form:
#
# $(INST)/<pkgname>-<pkgvers>: $(foreach dep,$(deps_<pkname>),$(inst_$(dep)))
#     +$(AM_V_at)sage-logger -p '$(SAGE_SPKG) <pkgname>-<pkgvers>' '$(SAGE_LOGS)/<pkgname>-<pkgvers>.log'
#
# <pkgname>: $(INST)/<pkgname>-<pkgvers>
#
# <pkgname>-clean:
#     rm -rf $(INST)/<pkgname>-<pkgvers>
#
# Note: In these rules the $(INST)/<pkgname>-<pkgvers> target is used
# explicitly, rather than expanding the $(inst_<pkgname>) variable, since
# it may expand to $(INST)/.dummy for packages that were not configured
# for installation by default.  However, we wish to be able to manually
# install those packages later.

define NORMAL_PACKAGE_templ
$$(INST)/$(1)-$$(vers_$(1)): $$(foreach dep,$$(deps_$(1)),$$(inst_$$(dep)))
	+$(AM_V_at)sage-logger -p '$(SAGE_SPKG) $(1)-$$(vers_$(1))' '$(SAGE_LOGS)/$(1)-$$(vers_$(1)).log'

$(1): $$(INST)/$(1)-$$(vers_$(1))

$(1)-clean:
	rm -rf $$(INST)/$(1)-$$(vers_$(1))
endef

$(foreach pkgname,$(NORMAL_PACKAGES),\
	$(eval $(call NORMAL_PACKAGE_templ,$(pkgname))))

# Generate build rules for 'pip' packages; this template is used to generate
# two rules in the form:
#
# <pkgname>: $(foreach dep,$(deps_<pkname>),$(inst_$(dep)))
#     $(AM_V_at)sage-logger -p 'sage --pip install <pkgname>' '$(SAGE_LOGS)/<pkgname>.log'
#
# <pkgname>-clean:
#     -sage --pip uninstall -y <pkgname>

define PIP_PACKAGE_templ
$(1): $$(foreach dep,$$(deps_$(1)),$$(inst_$$(dep)))
	$(AM_V_at)sage-logger -p 'sage --pip install $(1)' '$(SAGE_LOGS)/$(1).log'

$(1)-clean:
	-sage --pip uninstall -y $(1)
endef

$(foreach pkgname,$(PIP_PACKAGES),\
	$(eval $(call PIP_PACKAGE_templ,$(pkgname))))

# Generate build rules for 'script' packages; this template is used to generate
# two rules in the form:
#
# <pkgname>: $(foreach dep,$(deps_<pkname>),$(inst_$(dep)))
#     $(AM_V_at)cd '$SAGE_ROOT' && \\
#         source '$SAGE_ROOT/src/bin/sage-env' && \\
#         sage-logger -p '$SAGE_ROOT/build/pkgs/<pkgname>/spkg-install' '$(SAGE_LOGS)/<pkgname>.log'
#
# <pkgname>-clean:
#     -$(AM_V_at)cd '$SAGE_ROOT' && \\
#         source '$SAGE_ROOT/src/bin/sage-env' && \\
#         '$SAGE_ROOT/build/pkgs/$PKG_NAME/spkg-uninstall'

define SCRIPT_PACKAGE_templ
$(1): $$(foreach dep,$$(deps_$(1)),$$(inst_$$(dep)))
	$(AM_V_at)cd '$(SAGE_ROOT)' && \
		source '$(SAGE_ROOT)/src/bin/sage-env' && \
		sage-logger -p '$(SAGE_ROOT)/build/pkgs/$(1)/spkg-install' '$(SAGE_LOGS)/$(1).log'

$(1)-clean:
	-$(AM_V_at)cd '$(SAGE_ROOT)' && \
		source '$(SAGE_ROOT)/src/bin/sage-env' && \
		'$(SAGE_ROOT)/build/pkgs/$(1)/spkg-uninstall'
endef

$(foreach pkgname,$(SCRIPT_PACKAGES),\
	$(eval $(call SCRIPT_PACKAGE_templ,$(pkgname))))

.PHONY: $(NORMAL_PACKAGES) $(addsuffix -clean,$(NORMAL_PACKAGES)) \
        $(PIP_PACKAGES) $(addsuffix -clean,$(PIP_PACKAGES)) \
        $(SCRIPT_PACKAGES) $(addsuffix -clean,$(SCRIPT_PACKAGES))
