###############################################################################
# This file (deps.in) is included by the toplevel makefile template
###############################################################################
#
# FIXME: move package dependencies to packages
#

# compilation/install output will be teed to here

# Let e.g. SAGE_ROOT/spkg/install pass options to sage-spkg, i.e. currently
# "-f", to force rebuilding dependent packages during an upgrade (#9896).
#
# When upgrading from a 4.x version of Sage, the script "sage-spkg" will be
# found in SAGE_ROOT/local/bin until the new sage_root repo is installed.
# After that, it will be found in SAGE_ROOT/spkg/bin
# (SAGE_ROOT/spkg/bin is added to the PATH in spkg/install).
# Therefore, do not put an explicit path for sage-spkg here.
SAGE_SPKG = sage-spkg $${SAGE_SPKG_OPTS}

# Tell make not to look for files with these names:
.PHONY: all all-sage base toolchain toolchain-deps

# Make the 4 build phases: base, toolchain, toolchain-deps, all-sage
# During the toolchain build, we export SAGE_BUILD_TOOLCHAIN=yes
# such that packages can do different things when they are built
# as prerequisite of GCC.
all-old:
	$(MAKE) base # FIXME: isnt base a part of toolchain?
	env SAGE_BUILD_TOOLCHAIN=yes $(MAKE) toolchain # toolchain builds gcc, gcc deletes mp{3} stamps
	$(MAKE) toolchain-deps # actually reverse deps?
	$(MAKE) all-sage

# Base packages
# FP_prereq = $(call newest_version_base,prereq)

# Usage: newest_version_base $pkg
# Print version number of latest (according to modification time)
# base package $pkg
# As a fallback, we also look at the latest installed package.
define newest_version_base
$(shell \
    PKG="$(1)";\
    for FILE in `{ ls -1t @abs_top_srcdir@/build/base/$$PKG-*-install; ls -1t installed/$$PKG-*; } 2>/dev/null`;\
    do\
        ANS=`echo "$$FILE" | sed 's|.*/||; s|-install||'`;\
        if test -n "$$ANS"; then\
            echo "$$ANS";\
            exit 0;\
        fi;\
    done;\
    echo >&2 "Cannot determine latest version of $$PKG.";\
    echo "$$PKG"; )
endef

# Standard foreign package versions
@FP_VERSIONS@

# All targets except for the base packages
# ... generate from configure.ac.

scripts: $(BIN)

# nonsense? no. but not needed. covered by sagelib spkg
#     $(BIN) \
#     $(SAGE) \
#     $(CSAGE) \
#     $(EXTCODE)

# toolchain is a virtual "package"
TOOLCHAIN = $(INST)/toolchain

# note on $(DEP_gcc_maybe)
# set
# DEP_gcc_maybe = @DEP_gcc@
# if you want *all* packages to rebuild upon gcc-upgrade

# Build all packages that GCC links against serially, otherwise this
# leads to race conditions where some library which is used by GCC gets
# reinstalled. Since system GCCs might use Sage's libraries, we do this
# unconditionally. We still use the dependency checking from $(MAKE),
# so this will not trigger useless rebuilds.
# See http://trac.sagemath.org/sage_trac/ticket/14168
toolchain-deps: $(GCC_REVERSE_DEPS)

GCC_REVERSE_DEPS = @DEP_zlib@ @DEP_mpir@ @DEP_mpfr@ @DEP_mpc@ @DEP_ppl@

# toolchain inner dependencies, must add patch manually
$(INST)/toolchain-mpir: @DEP_patch@
$(INST)/toolchain-mpc: $(INST)/toolchain-mpir @DEP_patch@
$(INST)/toolchain-mpc: $(INST)/toolchain-mpfr @DEP_patch@
$(INST)/toolchain-mpfr: $(INST)/toolchain-mpir @DEP_patch@
# needed? why?
$(INST)/toolchain-ppl: $(INST)/toolchain-mpir @DEP_patch@

# Everything needed to start up Sage using "./sage".  Of course, not
# every part of Sage will work.  It does not include Maxima for example.
SAGERUNTIME = @DEP_sagelib@

# hmm this might be a temporary kludge
sagelib_DEPS = $(CORE_MODULES:%=%-configure-stamp) \
               src/sage-stage-stamp

sagelib_DEPS+= @DEP_sagenb@ @DEP_ipython@ @DEP_gap@ $(DEP_gcc_maybe)


###############################################################################
# Building the base system
# FIXME: this wont work properly
#
# This consists of packages which are required for the Sage build system
# but not for Sage itself.  Since nothing explicitly depends on these,
# an update of these packages will not trigger a rebuild of every other
# package during an upgrade, see #13415.
###############################################################################
# this should be not required.
base: @DEP_bzip2@ @DEP_patch@

# If we are upgrading from a version 4.x of Sage, don't build bzip2.
# This is because the old sage-spkg script cannot install the new bzip2
# spkg (which is gzip compressed).  We continue using the old bzip2
# installation (which is version 1.0.5 since sage-3.3), which is fine.
bzip2):

patch_DEPS = @DEP_bzip2@

###############################################################################
# normal packages dependencies
###############################################################################
atlas_DEPS = @DEP_lapack@ @DEP_python@ $(DEP_gcc_maybe)

# HACK?
$(INST)/$(FP_atlas): upstream/lapack-3.4.2.tar

blas_DEPS = $(DEP_gcc_maybe)
blas_OODEPS = $(GCC_REVERSE_DEPS)

cephes_DEPS = @DEP_cython@

boehm_gc_DEPS = $(DEP_gcc_maybe)

cliquer_DEPS = $(DEP_gcc_maybe)

cddlib_DEPS = @DEP_mpir@

# CONWAY depends on SAGERUNTIME because it runs Sage code to
# generate a Sage object (.sobj). FIXME: use juliens build
conway_polynomials_DEPS = $(SAGERUNTIME)

cvxopt_DEPS = \
    @DEP_numpy@ \
    @DEP_atlas@ @DEP_cephes@ @DEP_gsl@ \
    @DEP_glpk@ $(DEP_gcc_maybe)

# matplotlib is needed to test cvxopt (i.e., if SAGE_CHECK=yes). See #12742.
cvxopt_DEPS+= $(if filter($(SAGE_CHECK),yes),$(INST)/$(FP_matplotlib))

docutils_DEPS = @DEP_python@ $(DEP_gcc_maybe)

elliptic_curves_DEPS = @DEP_python@ @DEP_sqlite@ $(DEP_gcc_maybe)

eclib_DEPS = @DEP_mpir@ @DEP_pari@ @DEP_ntl@ $(DEP_gcc_maybe)

ecm_DEPS = @DEP_mpir@ $(DEP_gcc_maybe)

fflas_ffpack_DEPS = @DEP_mpir@ @DEP_givaro@ @DEP_gsl@ @DEP_atlas@ $(DEP_gcc_maybe)

freetype_DEPS =

gap_DEPS = @DEP_termcap@ @DEP_readline@ @DEP_mpir@ $(DEP_gcc_maybe)

genus2reduction_DEPS = @DEP_pari@

# git_DEPS = @DEP_zlib@ @DEP_python@

gd_DEPS = @DEP_libpng@ @DEP_freetype@ @DEP_iconv@ $(DEP_gcc_maybe)

gdmodule_DEPS = @DEP_python@ @DEP_gd@ @DEP_iconv@ $(DEP_gcc_maybe)

givaro_DEPS = @DEP_mpir@

glpk_DEPS = @DEP_mpir@ @DEP_zlib@ $(DEP_gcc_maybe)

gf2x_DEPS =

gfan_DEPS = @DEP_mpir@ @DEP_cddlib@ $(DEP_gcc_maybe)

gsl_DEPS = @DEP_atlas@ $(DEP_gcc_maybe)

lcalc_DEPS = @DEP_pari@ @DEP_mpfr@ $(DEP_gcc_maybe)

ipython_DEPS = @DEP_python@ $(DEP_gcc_maybe)

iml_DEPS = @DEP_mpir@ @DEP_gsl@ @DEP_atlas@ $(DEP_gcc_maybe)

jmol_DEPS = @DEP_sagenb@

lapack_DEPS = $(DEP_gcc_maybe)

linbox_DEPS = @DEP_mpir@ @DEP_ntl@ @DEP_givaro@ \
              @DEP_mpfr@ @DEP_libfplll@ @DEP_iml@ \
              @DEP_libm4ri@ @DEP_libm4rie@ @DEP_fflas_ffpack@ \
              $(DEP_gcc_maybe)

libpng_DEPS = @DEP_zlib@ $(DEP_gcc_maybe)

libfplll_DEPS = @DEP_mpir@ @DEP_mpfr@ $(DEP_gcc_maybe)

lrcalc_DEPS =

mpmath_DEPS = @DEP_python@

matplotlib_DEPS = \
    @DEP_python@ @DEP_numpy@ @DEP_freetype@ @DEP_libpng@ \
    @DEP_gdmodule@ $(DEP_gcc_maybe)

mpir_DEPS = @DEP_iconv@ @DEP_gcc@ @DEP_zlib@

mpc_DEPS = @DEP_mpir@ @DEP_mpfr@ @DEP_gcc@

mpfr_DEPS = @DEP_mpir@ @DEP_gcc@

mpfi_DEPS = @DEP_mpir@ @DEP_mpfr@ $(DEP_gcc_maybe)

networkx_DEPS = @DEP_python@

ntl_DEPS = @DEP_mpir@ @DEP_gf2x@ $(DEP_gcc_maybe)

numpy_DEPS = @DEP_python@ @DEP_atlas@ $(DEP_gcc_maybe)

libgap_DEPS = @DEP_gap@ @DEP_readline@ @DEP_mpir@ $(DEP_gcc_maybe)

polybori_DEPS = @DEP_python@ @DEP_ipython@ @DEP_scons@ @DEP_boost_cropped@ \
                @DEP_libm4ri@ @DEP_gd@ $(DEP_gcc_maybe)

polytopes_db_DEPS =

ppl_DEPS = @DEP_mpir@ $(DEP_gcc_maybe)

# Python links against -lbz2.  Technically speaking, we should add
# BZIP2 as dependency here.  But we don't do that to avoid needless
# recompiles of Python when upgrading.  Since bzip2 is part of the
# "base" target, we are guaranteed anyway that some version of bzip2
# is present.
python_DEPS = @DEP_zlib@ @DEP_readline@ @DEP_sqlite@ @DEP_libpng@ $(DEP_gcc_maybe)

readline_DEPS = @DEP_ncurses@ $(DEP_gcc_maybe)

pycrypto_DEPS = @DEP_python@ $(DEP_gcc_maybe)

pil_DEPS = @DEP_python@ $(DEP_gcc_maybe)

pynac_DEPS = @DEP_python@

pexpect_DEPS = @DEP_python@ $(DEP_gcc_maybe)

scons_DEPS = @DEP_python@

rubiks_DEPS =

scipy_DEPS = @DEP_atlas@ @DEP_numpy@ $(DEP_gcc_maybe)

sqlite_DEPS = @DEP_readline@ $(DEP_gcc_maybe)

# To build SageTeX, you just need Python, but to test (SAGE_CHECK=yes)
# SageTeX, you actually need to run sage, produce plots,...
sagetex_DEPS = @DEP_python@ $(SAGERUNTIME) @DEP_maxima@ @DEP_scipy@ \
               @DEP_matplotlib@ @DEP_pil@ @DEP_tachyon@ $(DEP_gcc_maybe)

setuptools_DEPS = @DEP_python@

singular_DEPS = @DEP_mpir@ @DEP_ntl@ @DEP_readline@ @DEP_mpfr@ $(DEP_gcc_maybe)

termcap_DEPS  = $(DEP_gcc_maybe)

tachyon_DEPS = @DEP_libpng@ $(DEP_gcc_maybe)

ratpoints_DEPS = @DEP_mpir@ $(DEP_gcc_maybe)

ecl_DEPS = @DEP_mpir@ @DEP_readline@ @DEP_boehm_gc@ $(DEP_gcc_maybe)

maxima_DEPS = @DEP_ecl@ $(DEP_gcc_maybe)

r_DEPS = @DEP_atlas@ @DEP_iconv@ @DEP_readline@ $(DEP_gcc_maybe)

rpy2_DEPS = @DEP_python@ @DEP_r@ $(DEP_gcc_maybe)

sympy_DEPS = @DEP_python@ $(DEP_gcc_maybe)

cython_DEPS = @DEP_python@ $(DEP_gcc_maybe)

flintqs_DEPS = @DEP_mpir@ $(DEP_gcc_maybe)

flint_DEPS = @DEP_mpir@ @DEP_mpfr@ @DEP_ntl@ $(DEP_gcc_maybe)

libm4ri_DEPS = @DEP_libpng@ $(DEP_gcc_maybe)

libm4rie_DEPS = @DEP_libm4ri@ @DEP_givaro@ @DEP_ntl@ $(DEP_gcc_maybe)

# zn_poly really does depend on Python, despite this is far from obvious.
# The 'configure' script in zn_poly calls Python to make a 'makefile'.
zn_poly_DEPS = @DEP_mpir@ @DEP_python@ $(DEP_gcc_maybe)

sagenb_DEPS = @DEP_python@ @DEP_setuptools@ @DEP_pexpect@ \
              @DEP_jinja2@ @DEP_sphinx@ @DEP_docutils@
sagenb_DEPS+= @DEP_sphinx@

sqlalchemy_DEPS = @DEP_python@ @DEP_setuptools@

sphinx_DEPS = @DEP_python@ @DEP_setuptools@ @DEP_docutils@ \
              @DEP_jinja2@ @DEP_pygments@

jinja2_DEPS = @DEP_python@ @DEP_setuptools@ @DEP_docutils@
jinja2_DEPS+= @DEP_pygments@

palp_DEPS =

symmetrica_DEPS =

sympow_DEPS =

pygments_DEPS = @DEP_python@ @DEP_setuptools@
pygments_DEPS+= @DEP_sqlalchemy@

# List all *build-time* dependencies of the Sage library.  These are,
# on the one hand, programs needed for the build/install process of the
# Sage library (e.g. JINJA2), and on the
# other hand all dependencies for Cython files (e.g. PARI, NTL, MPIR).
#
# WHY?! this way ./sage -sh fails until all of them have been compiled
scripts_DEPS = \
    @DEP_atlas@ \
    @DEP_cephes@ \
    @DEP_cliquer@ \
    @DEP_ecl@ \
    @DEP_eclib@ \
    @DEP_ecm@ \
    @DEP_flint@ \
    @DEP_libfplll@ \
    @DEP_gd@ \
    @DEP_givaro@ \
    @DEP_glpk@ \
    @DEP_gsl@ \
    @DEP_iml@ \
    @DEP_jinja2@ \
    @DEP_lcalc@ \
    @DEP_libgap@ \
    @DEP_libpng@ \
    @DEP_linbox@ \
    @DEP_libm4ri@ \
    @DEP_libm4rie@ \
    @DEP_mpc@ \
    @DEP_mpfi@ \
    @DEP_mpfr@ \
    @DEP_mpir@ \
    @DEP_ntl@ \
    @DEP_numpy@ \
    @DEP_pari@ \
    @DEP_polybori@ \
    @DEP_ppl@ \
    @DEP_pynac@ \
    @DEP_python@ \
    @DEP_ratpoints@ \
    @DEP_readline@ \
    @DEP_singular@ \
    @DEP_symmetrica@ \
    @DEP_zn_poly@

src/c_lib-configure-stamp: $(csage_DEPS)
src/bin-configure-stamp: $(scripts_DEPS)
src/sage-configure-stamp: @DEP_cython@ src/c_lib-configure-stamp \
                          @DEP_elliptic_curves@ \
                          @DEP_graphs@ \
                          @DEP_cython@ \
                          @DEP_polytopes_db@ \
                          @DEP_lrcalc@ \
                          $(scripts_DEPS) @DEP_libgap@ \
                          src/c_lib-build-stamp

extcode: $(EXTCODE_TARGETS)

zlib_DEPS = $(DEP_gcc_maybe)

# lib_c
src/c_lib-configure-stamp: $(csage_DEPS)
csage_DEPS = @DEP_mpir@ @DEP_ntl@ @DEP_pari@ @DEP_polybori@ @DEP_pynac@ \
             @DEP_python@ $(scripts_DEPS)

#FIXME:
$(INST)/ccache: $(BASE) @DEP_zlib@
	+$(PIPE) "$(SAGE_SPKG) ccache 2>&1" "tee -a $(SAGE_LOGS)/ccache.log"
	touch $(INST)/ccache

# actual gcc dependencies
GCC_OODEPS = @DEP_mpir@ @DEP_mpfr@ @DEP_mpir@ @DEP_mpc@ @DEP_ppl@ @DEP_zlib@

# gcc dependency hack, escape bootstrapping phase
gcc_DEPS = $(if $(wildcard $(INST)/gcc-*),,$(toolchain_DEPS))
gcc_OODEPS = $(if $(wildcard $(INST)/gcc-*),$(GCC_OODEPS))

# these need to be built twice (before & after gcc)
toolchain_DEPS = \
    $(INST)/toolchain-mpir \
    $(INST)/toolchain-mpfr \
    $(INST)/toolchain-mpc
#    $(INST)/toolchain-ppl really?

debug:
	echo gcc_DEPS $(gcc_DEPS)

###############################################################################

# setuptools forgets to update easy-install.pth during parallel
# builds, so we build the relevant packages serially.
